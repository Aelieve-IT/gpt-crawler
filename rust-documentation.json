[
  {
    "title": "The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/print.html",
    "html": "The Rust Programming Language\n\nWelcome! This book will teach you about the Rust Programming Language. Rust is a systems programming language focused on three goals: safety, speed, and concurrency. It maintains these goals without having a garbage collector, making it a useful language for a number of use cases other languages aren‚Äôt good at: embedding in other languages, programs with specific space and time requirements, and writing low-level code, like device drivers and operating systems. It improves on current languages targeting this space by having a number of compile-time safety checks that produce no runtime overhead, while eliminating all data races. Rust also aims to achieve ‚Äòzero-cost abstractions‚Äô even though some of these abstractions feel like those of a high-level language. Even then, Rust still allows precise control like a low-level language would.\n\n‚ÄúThe Rust Programming Language‚Äù is split into chapters. This introduction is the first. After this:\n\nGetting started - Set up your computer for Rust development.\nTutorial: Guessing Game - Learn some Rust with a small project.\nSyntax and Semantics - Each bit of Rust, broken down into small chunks.\nEffective Rust - Higher-level concepts for writing excellent Rust code.\nGlossary - A reference of terms used in the book.\nBibliography - Background on Rust's influences, papers about Rust.\nContributing\n\nThe source files from which this book is generated can be found on GitHub.\n\nSecond edition of this book\n\nThere are two editions of \"The Rust Programming Language\", this being the first edition.\n\nThe second edition is a complete re-write. It is still under construction, though it is far enough along to learn most of Rust. We suggest reading the second edition and then checking out the first edition later to pick up some of the more esoteric parts of the language.\n\nGetting Started\n\nThis first chapter of the book will get us going with Rust and its tooling. First, we‚Äôll install Rust. Then, the classic ‚ÄòHello World‚Äô program. Finally, we‚Äôll talk about Cargo, Rust‚Äôs build system and package manager.\n\nWe‚Äôll be showing off a number of commands using a terminal, and those lines all start with $. You don't need to type in the $s, they are there to indicate the start of each command. We‚Äôll see many tutorials and examples around the web that follow this convention: $ for commands run as our regular user, and # for commands we should be running as an administrator.\n\nInstalling Rust\n\nThe first step to using Rust is to install it. Generally speaking, you‚Äôll need an Internet connection to run the commands in this section, as we‚Äôll be downloading Rust from the Internet.\n\nThe Rust compiler runs on, and compiles to, a great number of platforms, but is best supported on Linux, Mac, and Windows, on the x86 and x86-64 CPU architecture. There are official builds of the Rust compiler and standard library for these platforms and more. For full details on Rust platform support see the website.\n\nInstalling Rust\n\nAll you need to do on Unix systems like Linux and macOS is open a terminal and type this:\n\n$ curl https://sh.rustup.rs -sSf | sh\n\n\nIt will download a script, and start the installation. If everything goes well, you‚Äôll see this appear:\n\nRust is installed now. Great! \n\n\nInstalling on Windows is nearly as easy: download and run rustup-init.exe. It will start the installation in a console and present the above message on success.\n\nFor other installation options and information, visit the install page of the Rust website.\n\nUninstalling\n\nUninstalling Rust is as easy as installing it:\n\n$ rustup self uninstall\n\nTroubleshooting\n\nIf we've got Rust installed, we can open up a shell, and type this:\n\n$ rustc --version\n\n\nYou should see the version number, commit hash, and commit date.\n\nIf you do, Rust has been installed successfully! Congrats!\n\nIf you don't, that probably means that the PATH environment variable doesn't include Cargo's binary directory, ~/.cargo/bin on Unix, or %USERPROFILE%\\.cargo\\bin on Windows. This is the directory where Rust development tools live, and most Rust developers keep it in their PATH environment variable, which makes it possible to run rustc on the command line. Due to differences in operating systems, command shells, and bugs in installation, you may need to restart your shell, log out of the system, or configure PATH manually as appropriate for your operating environment.\n\nRust does not do its own linking, and so you‚Äôll need to have a linker installed. Doing so will depend on your specific system. For Linux-based systems, Rust will attempt to call cc for linking. On windows-msvc (Rust built on Windows with Microsoft Visual Studio), this depends on having Microsoft Visual C++ Build Tools installed. These do not need to be in %PATH% as rustc will find them automatically. In general, if you have your linker in a non-traditional location you can call rustc linker=/path/to/cc, where /path/to/cc should point to your linker path.\n\nIf you are still stuck, there are a number of places where we can get help. The easiest is the #rust-beginners IRC channel on irc.mozilla.org and for general discussion the #rust IRC channel on irc.mozilla.org, which we can access through Mibbit. Then we'll be chatting with other Rustaceans (a silly nickname we call ourselves) who can help us out. Other great resources include the user‚Äôs forum and Stack Overflow.\n\nThis installer also installs a copy of the documentation locally, so we can read it offline. It's only a rustup doc away!\n\nHello, world!\n\nNow that you have Rust installed, we'll help you write your first Rust program. It's traditional when learning a new language to write a little program to print the text ‚ÄúHello, world!‚Äù to the screen, and in this section, we'll follow that tradition.\n\nThe nice thing about starting with such a simple program is that you can quickly verify that your compiler is installed, and that it's working properly. Printing information to the screen is also a pretty common thing to do, so practicing it early on is good.\n\nNote: This book assumes basic familiarity with the command line. Rust itself makes no specific demands about your editing, tooling, or where your code lives, so if you prefer an IDE to the command line, that's an option. You may want to check out SolidOak, which was built specifically with Rust in mind. There are a number of extensions in development by the community, and the Rust team ships plugins for various editors. Configuring your editor or IDE is out of the scope of this tutorial, so check the documentation for your specific setup.\n\nCreating a Project File\n\nFirst, make a file to put your Rust code in. Rust doesn't care where your code lives, but for this book, I suggest making a projects directory in your home directory, and keeping all your projects there. Open a terminal and enter the following commands to make a directory for this particular project:\n\n$ mkdir ~/projects\n$ cd ~/projects\n$ mkdir hello_world\n$ cd hello_world\n\n\nNote: If you‚Äôre on Windows and not using PowerShell, the ~ may not work. Consult the documentation for your shell for more details.\n\nWriting and Running a Rust Program\n\nWe need to create a source file for our Rust program. Rust files always end in a .rs extension. If you are using more than one word in your filename, use an underscore to separate them; for example, you would use my_program.rs rather than myprogram.rs.\n\nNow, make a new file and call it main.rs. Open the file and type the following code:\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nSave the file, and go back to your terminal window. On Linux or macOS, enter the following commands:\n\n$ rustc main.rs\n$ ./main\nHello, world!\n\n\nIn Windows, replace main with main.exe. Regardless of your operating system, you should see the string Hello, world! print to the terminal. If you did, then congratulations! You've officially written a Rust program. That makes you a Rust programmer! Welcome.\n\nAnatomy of a Rust Program\n\nNow, let‚Äôs go over what just happened in your \"Hello, world!\" program in detail. Here's the first piece of the puzzle:\n\nfn main() {\n\n}\n\n\nThese lines define a function in Rust. The main function is special: it's the beginning of every Rust program. The first line says, ‚ÄúI‚Äôm declaring a function named main that takes no arguments and returns nothing.‚Äù If there were arguments, they would go inside the parentheses (( and )), and because we aren‚Äôt returning anything from this function, we can omit the return type entirely.\n\nAlso note that the function body is wrapped in curly braces ({ and }). Rust requires these around all function bodies. It's considered good style to put the opening curly brace on the same line as the function declaration, with one space in between.\n\nInside the main() function:\n\n\n    println!(\"Hello, world!\");\n\nThis line does all of the work in this little program: it prints text to the screen. There are a number of details that are important here. The first is that it‚Äôs indented with four spaces, not tabs.\n\nThe second important part is the println!() line. This is calling a Rust macro, which is how metaprogramming is done in Rust. If it were calling a function instead, it would look like this: println() (without the !). We'll discuss Rust macros in more detail later, but for now you only need to know that when you see a ! that means that you‚Äôre calling a macro instead of a normal function.\n\nNext is \"Hello, world!\" which is a string. Strings are a surprisingly complicated topic in a systems programming language, and this is a statically allocated string. We pass this string as an argument to println!, which prints the string to the screen. Easy enough!\n\nThe line ends with a semicolon (;). Rust is an expression-oriented language, which means that most things are expressions, rather than statements. The ; indicates that this expression is over, and the next one is ready to begin. Most lines of Rust code end with a ;.\n\nCompiling and Running Are Separate Steps\n\nIn \"Writing and Running a Rust Program\", we showed you how to run a newly created program. We'll break that process down and examine each step now.\n\nBefore running a Rust program, you have to compile it. You can use the Rust compiler by entering the rustc command and passing it the name of your source file, like this:\n\n$ rustc main.rs\n\n\nIf you come from a C or C++ background, you'll notice that this is similar to gcc or clang. After compiling successfully, Rust should output a binary executable, which you can see on Linux or macOS by entering the ls command in your shell as follows:\n\n$ ls\nmain  main.rs\n\n\nOn Windows, you'd enter:\n\n$ dir\nmain.exe\nmain.rs\n\n\nThis shows we have two files: the source code, with an .rs extension, and the executable (main.exe on Windows, main everywhere else). All that's left to do from here is run the main or main.exe file, like this:\n\n$ ./main  # or .\\main.exe on Windows\n\n\nIf main.rs were your \"Hello, world!\" program, this would print Hello, world! to your terminal.\n\nIf you come from a dynamic language like Ruby, Python, or JavaScript, you may not be used to compiling and running a program being separate steps. Rust is an ahead-of-time compiled language, which means that you can compile a program, give it to someone else, and they can run it even without Rust installed. If you give someone a .rb or .py or .js file, on the other hand, they need to have a Ruby, Python, or JavaScript implementation installed (respectively), but you only need one command to both compile and run your program. Everything is a tradeoff in language design.\n\nJust compiling with rustc is fine for simple programs, but as your project grows, you'll want to be able to manage all of the options your project has, and make it easy to share your code with other people and projects. Next, I'll introduce you to a tool called Cargo, which will help you write real-world Rust programs.\n\nHello, Cargo!\n\nCargo is Rust‚Äôs build system and package manager, and Rustaceans use Cargo to manage their Rust projects. Cargo manages three things: building your code, downloading the libraries your code depends on, and building those libraries. We call libraries your code needs ‚Äòdependencies‚Äô since your code depends on them.\n\nThe simplest Rust programs don‚Äôt have any dependencies, so right now, you'd only use the first part of its functionality. As you write more complex Rust programs, you‚Äôll want to add dependencies, and if you start off using Cargo, that will be a lot easier to do.\n\nAs the vast, vast majority of Rust projects use Cargo, we will assume that you‚Äôre using it for the rest of the book. Cargo comes installed with Rust itself, if you used the official installers. If you installed Rust through some other means, you can check if you have Cargo installed by typing:\n\n$ cargo --version\n\n\nInto a terminal. If you see a version number, great! If you see an error like ‚Äòcommand not found‚Äô, then you should look at the documentation for the system in which you installed Rust, to determine if Cargo is separate.\n\nConverting to Cargo\n\nLet‚Äôs convert the Hello World program to Cargo. To Cargo-fy a project, you need to do three things:\n\nPut your source file in the right directory.\nGet rid of the old executable (main.exe on Windows, main everywhere else).\nMake a Cargo configuration file.\n\nLet's get started!\n\nCreating a Source Directory and Removing the Old Executable\n\nFirst, go back to your terminal, move to your hello_world directory, and enter the following commands:\n\n$ mkdir src\n$ mv main.rs src/main.rs # or 'move main.rs src/main.rs' on Windows\n$ rm main  # or 'del main.exe' on Windows\n\n\nCargo expects your source files to live inside a src directory, so do that first. This leaves the top-level project directory (in this case, hello_world) for READMEs, license information, and anything else not related to your code. In this way, using Cargo helps you keep your projects nice and tidy. There's a place for everything, and everything is in its place.\n\nNow, move main.rs into the src directory, and delete the compiled file you created with rustc. As usual, replace main with main.exe if you're on Windows.\n\nThis example retains main.rs as the source filename because it's creating an executable. If you wanted to make a library instead, you'd name the file lib.rs. This convention is used by Cargo to successfully compile your projects, but it can be overridden if you wish.\n\nCreating a Configuration File\n\nNext, create a new file inside your hello_world directory, and call it Cargo.toml.\n\nMake sure to capitalize the C in Cargo.toml, or Cargo won't know what to do with the configuration file.\n\nThis file is in the TOML (Tom's Obvious, Minimal Language) format. TOML is similar to INI, but has some extra goodies, and is used as Cargo‚Äôs configuration format.\n\nInside this file, type the following information:\n\n[package]\n\nname = \"hello_world\"\nversion = \"0.0.1\"\nauthors = [ \"Your name <you@example.com>\" ]\n\n\nThe first line, [package], indicates that the following statements are configuring a package. As we add more information to this file, we‚Äôll add other sections, but for now, we only have the package configuration.\n\nThe other three lines set the three bits of configuration that Cargo needs to know to compile your program: its name, what version it is, and who wrote it.\n\nOnce you've added this information to the Cargo.toml file, save it to finish creating the configuration file.\n\nBuilding and Running a Cargo Project\n\nWith your Cargo.toml file in place in your project's root directory, you should be ready to build and run your Hello World program! To do so, enter the following commands:\n\n$ cargo build\n   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n$ ./target/debug/hello_world\nHello, world!\n\n\nBam! If all goes well, Hello, world! should print to the terminal once more.\n\nYou just built a project with cargo build and ran it with ./target/debug/hello_world, but you can actually do both in one step with cargo run as follows:\n\n$ cargo run\n     Running `target/debug/hello_world`\nHello, world!\n\n\nThe run command comes in handy when you need to rapidly iterate on a project.\n\nNotice that this example didn‚Äôt re-build the project. Cargo figured out that the file hasn‚Äôt changed, and so it just ran the binary. If you'd modified your source code, Cargo would have rebuilt the project before running it, and you would have seen something like this:\n\n$ cargo run\n   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n     Running `target/debug/hello_world`\nHello, world!\n\n\nCargo checks to see if any of your project‚Äôs files have been modified, and only rebuilds your project if they‚Äôve changed since the last time you built it.\n\nWith simple projects, Cargo doesn't bring a whole lot over just using rustc, but it will become useful in the future. This is especially true when you start using crates; these are synonymous with a ‚Äòlibrary‚Äô or ‚Äòpackage‚Äô in other programming languages. For complex projects composed of multiple crates, it‚Äôs much easier to let Cargo coordinate the build. Using Cargo, you can run cargo build, and it should work the right way.\n\nBuilding for Release\n\nWhen your project is ready for release, you can use cargo build --release to compile your project with optimizations. These optimizations make your Rust code run faster, but turning them on makes your program take longer to compile. This is why there are two different profiles, one for development, and one for building the final program you‚Äôll give to a user.\n\nWhat Is That Cargo.lock?\n\nRunning cargo build also causes Cargo to create a new file called Cargo.lock, which looks like this:\n\n[root]\nname = \"hello_world\"\nversion = \"0.0.1\"\n\n\nCargo uses the Cargo.lock file to keep track of dependencies in your application. This is the Hello World project's Cargo.lock file. This project doesn't have dependencies, so the file is a bit sparse. Realistically, you won't ever need to touch this file yourself; just let Cargo handle it.\n\nThat‚Äôs it! If you've been following along, you should have successfully built hello_world with Cargo.\n\nEven though the project is simple, it now uses much of the real tooling you‚Äôll use for the rest of your Rust career. In fact, you can expect to start virtually all Rust projects with some variation on the following commands:\n\n$ git clone someurl.com/foo\n$ cd foo\n$ cargo build\n\nMaking A New Cargo Project the Easy Way\n\nYou don‚Äôt have to go through that previous process every time you want to start a new project! Cargo can quickly make a bare-bones project directory that you can start developing in right away.\n\nTo start a new project with Cargo, enter cargo new at the command line:\n\n$ cargo new hello_world --bin\n\n\nThis command passes --bin because the goal is to get straight to making an executable application, as opposed to a library. Executables are often called binaries (as in /usr/bin, if you‚Äôre on a Unix system).\n\nCargo has generated two files and one directory for us: a Cargo.toml and a src directory with a main.rs file inside. These should look familiar, they‚Äôre exactly what we created by hand, above.\n\nThis output is all you need to get started. First, open Cargo.toml. It should look something like this:\n\n[package]\n\nname = \"hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[dependencies]\n\n\nDo not worry about the [dependencies] line, we will come back to it later.\n\nCargo has populated Cargo.toml with reasonable defaults based on the arguments you gave it and your git global configuration. You may notice that Cargo has also initialized the hello_world directory as a git repository.\n\nHere‚Äôs what should be in src/main.rs:\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nCargo has generated a \"Hello World!\" for you, and you‚Äôre ready to start coding!\n\nNote: If you want to look at Cargo in more detail, check out the official Cargo guide, which covers all of its features.\n\nClosing Thoughts\n\nThis chapter covered the basics that will serve you well through the rest of this book, and the rest of your time with Rust. Now that you‚Äôve got the tools down, we'll cover more about the Rust language itself.\n\nYou have two options: Dive into a project with ‚ÄòTutorial: Guessing Game‚Äô, or start from the bottom and work your way up with ‚ÄòSyntax and Semantics‚Äô. More experienced systems programmers will probably prefer ‚ÄòTutorial: Guessing Game‚Äô, while those from dynamic backgrounds may enjoy either. Different people learn differently! Choose whatever‚Äôs right for you.\n\nGuessing Game\n\nLet‚Äôs learn some Rust! For our first project, we‚Äôll implement a classic beginner programming problem: the guessing game. Here‚Äôs how it works: Our program will generate a random integer between one and a hundred. It will then prompt us to enter a guess. Upon entering our guess, it will tell us if we‚Äôre too low or too high. Once we guess correctly, it will congratulate us. Sounds good?\n\nAlong the way, we‚Äôll learn a little bit about Rust. The next chapter, ‚ÄòSyntax and Semantics‚Äô, will dive deeper into each part.\n\nSet up\n\nLet‚Äôs set up a new project. Go to your projects directory. Remember how we had to create our directory structure and a Cargo.toml for hello_world? Cargo has a command that does that for us. Let‚Äôs give it a shot:\n\n$ cd ~/projects\n$ cargo new guessing_game --bin\n     Created binary (application) `guessing_game` project\n$ cd guessing_game\n\n\nWe pass the name of our project to cargo new, and then the --bin flag, since we‚Äôre making a binary, rather than a library.\n\nCheck out the generated Cargo.toml:\n\n[package]\n\nname = \"guessing_game\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <you@example.com>\"]\n\n\nCargo gets this information from your environment. If it‚Äôs not correct, go ahead and fix that.\n\nFinally, Cargo generated a ‚ÄòHello, world!‚Äô for us. Check out src/main.rs:\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nLet‚Äôs try compiling what Cargo gave us:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.53 secs\n\n\nExcellent! Open up your src/main.rs again. We‚Äôll be writing all of our code in this file.\n\nRemember the run command from last chapter? Try it out again here:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/guessing_game`\nHello, world!\n\n\nGreat! Our game is just the kind of project run is good for: we need to quickly test each iteration before moving on to the next one.\n\nProcessing a Guess\n\nLet‚Äôs get to it! The first thing we need to do for our guessing game is allow our player to input a guess. Put this in your src/main.rs:\n\nuse std::io;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {}\", guess);\n}\n\n\nThere‚Äôs a lot here! Let‚Äôs go over it, bit by bit.\n\nuse std::io;\n\n\nWe‚Äôll need to take user input, and then print the result as output. As such, we need the io library from the standard library. Rust only imports a few things by default into every program, the ‚Äòprelude‚Äô. If it‚Äôs not in the prelude, you‚Äôll have to use it directly. There is also a second ‚Äòprelude‚Äô, the io prelude, which serves a similar function: you import it, and it imports a number of useful, io-related things.\n\nfn main() {\n\n\nAs you‚Äôve seen before, the main() function is the entry point into your program. The fn syntax declares a new function, the ()s indicate that there are no arguments, and { starts the body of the function. Because we didn‚Äôt include a return type, it‚Äôs assumed to be (), an empty tuple.\n\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n\n\nWe previously learned that println!() is a macro that prints a string to the screen.\n\n    let mut guess = String::new();\n\n\nNow we‚Äôre getting interesting! There‚Äôs a lot going on in this little line. The first thing to notice is that this is a let statement, which is used to create ‚Äòvariable bindings‚Äô. They take this form:\n\nlet foo = bar;\n\n\nThis will create a new binding named foo, and bind it to the value bar. In many languages, this is called a ‚Äòvariable‚Äô, but Rust‚Äôs variable bindings have a few tricks up their sleeves.\n\nFor example, they‚Äôre immutable by default. That‚Äôs why our example uses mut: it makes a binding mutable, rather than immutable. let doesn‚Äôt take a name on the left hand side of the assignment, it actually accepts a ‚Äòpattern‚Äô. We‚Äôll use patterns later. It‚Äôs easy enough to use for now:\n\n\nlet foo = 5; // `foo` is immutable.\nlet mut bar = 5; // `bar` is mutable.\n\nOh, and // will start a comment, until the end of the line. Rust ignores everything in comments.\n\nSo now we know that let mut guess will introduce a mutable binding named guess, but we have to look at the other side of the = for what it‚Äôs bound to: String::new().\n\nString is a string type, provided by the standard library. A String is a growable, UTF-8 encoded bit of text.\n\nThe ::new() syntax uses :: because this is an ‚Äòassociated function‚Äô of a particular type. That is to say, it‚Äôs associated with String itself, rather than a particular instance of a String. Some languages call this a ‚Äòstatic method‚Äô.\n\nThis function is named new(), because it creates a new, empty String. You‚Äôll find a new() function on many types, as it‚Äôs a common name for making a new value of some kind.\n\nLet‚Äôs move forward:\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n\nThat‚Äôs a lot more! Let‚Äôs go bit-by-bit. The first line has two parts. Here‚Äôs the first:\n\nio::stdin()\n\n\nRemember how we used std::io on the first line of the program? We‚Äôre now calling an associated function on it. If we didn‚Äôt use std::io, we could have written this line as std::io::stdin().\n\nThis particular function returns a handle to the standard input for your terminal. More specifically, a std::io::Stdin.\n\nThe next part will use this handle to get input from the user:\n\n.read_line(&mut guess)\n\n\nHere, we call the read_line method on our handle. Methods are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We‚Äôre also passing one argument to read_line(): &mut guess.\n\nRemember how we bound guess above? We said it was mutable. However, read_line doesn‚Äôt take a String as an argument: it takes a &mut String. Rust has a feature called ‚Äòreferences‚Äô, which allows you to have multiple references to one piece of data, which can reduce copying. References are a complex feature, as one of Rust‚Äôs major selling points is how safe and easy it is to use references. We don‚Äôt need to know a lot of those details to finish our program right now, though. For now, all we need to know is that like let bindings, references are immutable by default. Hence, we need to write &mut guess, rather than &guess.\n\nWhy does read_line() take a mutable reference to a string? Its job is to take what the user types into standard input, and place that into a string. So it takes that string as an argument, and in order to add the input, it needs to be mutable.\n\nBut we‚Äôre not quite done with this line of code, though. While it‚Äôs a single line of text, it‚Äôs only the first part of the single logical line of code:\n\n        .expect(\"Failed to read line\");\n\n\nWhen you call a method with the .foo() syntax, you may introduce a newline and other whitespace. This helps you split up long lines. We could have done:\n\n    io::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n\n\nBut that gets hard to read. So we‚Äôve split it up, two lines for two method calls. We already talked about read_line(), but what about expect()? Well, we already mentioned that read_line() puts what the user types into the &mut String we pass it. But it also returns a value: in this case, an io::Result. Rust has a number of types named Result in its standard library: a generic Result, and then specific versions for sub-libraries, like io::Result.\n\nThe purpose of these Result types is to encode error handling information. Values of the Result type, like any type, have methods defined on them. In this case, io::Result has an expect() method that takes a value it‚Äôs called on, and if it isn‚Äôt a successful one, panic!s with a message you passed it. A panic! like this will cause our program to crash, displaying the message.\n\nIf we do not call expect(), our program will compile, but we‚Äôll get a warning:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\nwarning: unused result which must be used, #[warn(unused_must_use)] on by default\n  --> src/main.rs:10:5\n   |\n10 |     io::stdin().read_line(&mut guess);\n   |     ^\n\n    Finished debug [unoptimized + debuginfo] target(s) in 0.42 secs\n\n\nRust warns us that we haven‚Äôt used the Result value. This warning comes from a special annotation that io::Result has. Rust is trying to tell you that you haven‚Äôt handled a possible error. The right way to suppress the error is to actually write error handling. Luckily, if we want to crash if there‚Äôs a problem, we can use expect(). If we can recover from the error somehow, we‚Äôd do something else, but we‚Äôll save that for a future project.\n\nThere‚Äôs only one line of this first example left:\n\n    println!(\"You guessed: {}\", guess);\n}\n\n\nThis prints out the string we saved our input in. The {}s are a placeholder, and so we pass it guess as an argument. If we had multiple {}s, we would pass multiple arguments:\n\n\nlet x = 5;\nlet y = 10;\n\nprintln!(\"x and y: {} and {}\", x, y);\n\nEasy.\n\nAnyway, that‚Äôs the tour. We can run what we have with cargo run:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.44 secs\n     Running `target/debug/guessing_game`\nGuess the number!\nPlease input your guess.\n6\nYou guessed: 6\n\n\nAll right! Our first part is done: we can get input from the keyboard, and then print it back out.\n\nGenerating a secret number\n\nNext, we need to generate a secret number. Rust does not yet include random number functionality in its standard library. The Rust team does, however, provide a rand crate. A ‚Äòcrate‚Äô is a package of Rust code. We‚Äôve been building a ‚Äòbinary crate‚Äô, which is an executable. rand is a ‚Äòlibrary crate‚Äô, which contains code that‚Äôs intended to be used with other programs.\n\nUsing external crates is where Cargo really shines. Before we can write the code using rand, we need to modify our Cargo.toml. Open it up, and add these few lines at the bottom:\n\n[dependencies]\n\nrand = \"0.3.0\"\n\n\nThe [dependencies] section of Cargo.toml is like the [package] section: everything that follows it is part of it, until the next section starts. Cargo uses the dependencies section to know what dependencies on external crates you have, and what versions you require. In this case, we‚Äôve specified version 0.3.0, which Cargo understands to be any release that‚Äôs compatible with this specific version. Cargo understands Semantic Versioning, which is a standard for writing version numbers. A bare number like above is actually shorthand for ^0.3.0, meaning \"anything compatible with 0.3.0\". If we wanted to use only 0.3.0 exactly, we could say rand = \"=0.3.0\" (note the two equal signs). We could also use a range of versions. Cargo‚Äôs documentation contains more details.\n\nNow, without changing any of our code, let‚Äôs build our project:\n\n$ cargo build\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n Downloading rand v0.3.14\n Downloading libc v0.2.17\n   Compiling libc v0.2.17\n   Compiling rand v0.3.14\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 5.88 secs\n\n\n(You may see different versions, of course.)\n\nLots of new output! Now that we have an external dependency, Cargo fetches the latest versions of everything from the registry, which is a copy of data from Crates.io. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.\n\nAfter updating the registry, Cargo checks our [dependencies] and downloads any we don‚Äôt have yet. In this case, while we only said we wanted to depend on rand, we‚Äôve also grabbed a copy of libc. This is because rand depends on libc to work. After downloading them, it compiles them, and then compiles our project.\n\nIf we run cargo build again, we‚Äôll get different output:\n\n$ cargo build\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n\n\nThat‚Äôs right, nothing was done! Cargo knows that our project has been built, and that all of its dependencies are built, and so there‚Äôs no reason to do all that stuff. With nothing to do, it simply exits. If we open up src/main.rs again, make a trivial change, and then save it again, we‚Äôll only see two lines:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.45 secs\n\n\nSo, we told Cargo we wanted any 0.3.x version of rand, and so it fetched the latest version at the time this was written, v0.3.14. But what happens when next week, version v0.3.15 comes out, with an important bugfix? While getting bugfixes is important, what if 0.3.15 contains a regression that breaks our code?\n\nThe answer to this problem is the Cargo.lock file you‚Äôll now find in your project directory. When you build your project for the first time, Cargo figures out all of the versions that fit your criteria, and then writes them to the Cargo.lock file. When you build your project in the future, Cargo will see that the Cargo.lock file exists, and then use that specific version rather than do all the work of figuring out versions again. This lets you have a repeatable build automatically. In other words, we‚Äôll stay at 0.3.14 until we explicitly upgrade, and so will anyone who we share our code with, thanks to the lock file.\n\nWhat about when we do want to use v0.3.15? Cargo has another command, update, which says ‚Äòignore the lock, figure out all the latest versions that fit what we‚Äôve specified. If that works, write those versions out to the lock file‚Äô. But, by default, Cargo will only look for versions larger than 0.3.0 and smaller than 0.4.0. If we want to move to 0.4.x, we‚Äôd have to update the Cargo.toml directly. When we do, the next time we cargo build, Cargo will update the index and re-evaluate our rand requirements.\n\nThere‚Äôs a lot more to say about Cargo and its ecosystem, but for now, that‚Äôs all we need to know. Cargo makes it really easy to re-use libraries, and so Rustaceans tend to write smaller projects which are assembled out of a number of sub-packages.\n\nLet‚Äôs get on to actually using rand. Here‚Äôs our next step:\n\nextern crate rand;\n\nuse std::io;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {}\", guess);\n}\n\n\nThe first thing we‚Äôve done is change the first line. It now says extern crate rand. Because we declared rand in our [dependencies], we can use extern crate to let Rust know we‚Äôll be making use of it. This also does the equivalent of a use rand; as well, so we can make use of anything in the rand crate by prefixing it with rand::.\n\nNext, we added another use line: use rand::Rng. We‚Äôre going to use a method in a moment, and it requires that Rng be in scope to work. The basic idea is this: methods are defined on something called ‚Äòtraits‚Äô, and for the method to work, it needs the trait to be in scope. For more about the details, read the traits section.\n\nThere are two other lines we added, in the middle:\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n\nWe use the rand::thread_rng() function to get a copy of the random number generator, which is local to the particular thread of execution we‚Äôre in. Because we use rand::Rng‚Äôd above, it has a gen_range() method available. This method takes two arguments, and generates a number between them. It‚Äôs inclusive on the lower bound, but exclusive on the upper bound, so we need 1 and 101 to get a number ranging from one to a hundred.\n\nThe second line prints out the secret number. This is useful while we‚Äôre developing our program, so we can easily test it out. But we‚Äôll be deleting it for the final version. It‚Äôs not much of a game if it prints out the answer when you start it up!\n\nTry running our new program a few times:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.55 secs\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 7\nPlease input your guess.\n4\nYou guessed: 4\n$ cargo run\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 83\nPlease input your guess.\n5\nYou guessed: 5\n\n\nGreat! Next up: comparing our guess to the secret number.\n\nComparing guesses\n\nNow that we‚Äôve got user input, let‚Äôs compare our guess to the secret number. Here‚Äôs our next step, though it doesn‚Äôt quite compile yet:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {}\", guess);\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less    => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal   => println!(\"You win!\"),\n    }\n}\n\n\nA few new bits here. The first is another use. We bring a type called std::cmp::Ordering into scope. Then, five new lines at the bottom that use it:\n\nmatch guess.cmp(&secret_number) {\n    Ordering::Less    => println!(\"Too small!\"),\n    Ordering::Greater => println!(\"Too big!\"),\n    Ordering::Equal   => println!(\"You win!\"),\n}\n\n\nThe cmp() method can be called on anything that can be compared, and it takes a reference to the thing you want to compare it to. It returns the Ordering type we used earlier. We use a match statement to determine exactly what kind of Ordering it is. Ordering is an enum, short for ‚Äòenumeration‚Äô, which looks like this:\n\n\nenum Foo {\n    Bar,\n    Baz,\n}\n\nWith this definition, anything of type Foo can be either a Foo::Bar or a Foo::Baz. We use the :: to indicate the namespace for a particular enum variant.\n\nThe Ordering enum has three possible variants: Less, Equal, and Greater. The match statement takes a value of a type, and lets you create an ‚Äòarm‚Äô for each possible value. Since we have three types of Ordering, we have three arms:\n\nmatch guess.cmp(&secret_number) {\n    Ordering::Less    => println!(\"Too small!\"),\n    Ordering::Greater => println!(\"Too big!\"),\n    Ordering::Equal   => println!(\"You win!\"),\n}\n\n\nIf it‚Äôs Less, we print Too small!, if it‚Äôs Greater, Too big!, and if Equal, You win!. match is really useful, and is used often in Rust.\n\nI did mention that this won‚Äôt quite compile yet, though. Let‚Äôs try it:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\nerror[E0308]: mismatched types\n  --> src/main.rs:23:21\n   |\n23 |     match guess.cmp(&secret_number) {\n   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable\n   |\n   = note: expected type `&std::string::String`\n   = note:    found type `&{integer}`\n\nerror: aborting due to previous error\n\nerror: Could not compile `guessing_game`.\n\nTo learn more, run the command again with --verbose.\n\n\nWhew! This is a big error. The core of it is that we have ‚Äòmismatched types‚Äô. Rust has a strong, static type system. However, it also has type inference. When we wrote let guess = String::new(), Rust was able to infer that guess should be a String, and so it doesn‚Äôt make us write out the type. And with our secret_number, there are a number of types which can have a value between one and a hundred: i32, a thirty-two-bit number, or u32, an unsigned thirty-two-bit number, or i64, a sixty-four-bit number or others. So far, that hasn‚Äôt mattered, and so Rust defaults to an i32. However, here, Rust doesn‚Äôt know how to compare the guess and the secret_number. They need to be the same type. Ultimately, we want to convert the String we read as input into a real number type, for comparison. We can do that with two more lines. Here‚Äôs our new program:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    let guess: u32 = guess.trim().parse()\n        .expect(\"Please type a number!\");\n\n    println!(\"You guessed: {}\", guess);\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less    => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal   => println!(\"You win!\"),\n    }\n}\n\n\nThe new two lines:\n\n    let guess: u32 = guess.trim().parse()\n        .expect(\"Please type a number!\");\n\n\nWait a minute, I thought we already had a guess? We do, but Rust allows us to ‚Äòshadow‚Äô the previous guess with a new one. This is often used in this exact situation, where guess starts as a String, but we want to convert it to an u32. Shadowing lets us re-use the guess name, rather than forcing us to come up with two unique names like guess_str and guess, or something else.\n\nWe bind guess to an expression that looks like something we wrote earlier:\n\nguess.trim().parse()\n\n\nHere, guess refers to the old guess, the one that was a String with our input in it. The trim() method on Strings will eliminate any white space at the beginning and end of our string. This is important, as we had to press the ‚Äòreturn‚Äô key to satisfy read_line(). This means that if we type 5 and hit return, guess looks like this: 5\\n. The \\n represents ‚Äònewline‚Äô, the enter key. trim() gets rid of this, leaving our string with only the 5. The parse() method on strings parses a string into some kind of number. Since it can parse a variety of numbers, we need to give Rust a hint as to the exact type of number we want. Hence, let guess: u32. The colon (:) after guess tells Rust we‚Äôre going to annotate its type. u32 is an unsigned, thirty-two bit integer. Rust has a number of built-in number types, but we‚Äôve chosen u32. It‚Äôs a good default choice for a small positive number.\n\nJust like read_line(), our call to parse() could cause an error. What if our string contained Aüëç%? There‚Äôd be no way to convert that to a number. As such, we‚Äôll do the same thing we did with read_line(): use the expect() method to crash if there‚Äôs an error.\n\nLet‚Äôs try our program out!\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.57 secs\n     Running `target/guessing_game`\nGuess the number!\nThe secret number is: 58\nPlease input your guess.\n  76\nYou guessed: 76\nToo big!\n\n\nNice! You can see I even added spaces before my guess, and it still figured out that I guessed 76. Run the program a few times, and verify that guessing the number works, as well as guessing a number too small.\n\nNow we‚Äôve got most of the game working, but we can only make one guess. Let‚Äôs change that by adding loops!\n\nLooping\n\nThe loop keyword gives us an infinite loop. Let‚Äôs add that in:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = guess.trim().parse()\n            .expect(\"Please type a number!\");\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => println!(\"You win!\"),\n        }\n    }\n}\n\n\nAnd try it out. But wait, didn‚Äôt we just add an infinite loop? Yup. Remember our discussion about parse()? If we give a non-number answer, we‚Äôll panic! and quit. Observe:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.58 secs\n     Running `target/guessing_game`\nGuess the number!\nThe secret number is: 59\nPlease input your guess.\n45\nYou guessed: 45\nToo small!\nPlease input your guess.\n60\nYou guessed: 60\nToo big!\nPlease input your guess.\n59\nYou guessed: 59\nYou win!\nPlease input your guess.\nquit\nthread 'main' panicked at 'Please type a number!'\n\n\nHa! quit actually quits. As does any other non-number input. Well, this is suboptimal to say the least. First, let‚Äôs actually quit when you win the game:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = guess.trim().parse()\n            .expect(\"Please type a number!\");\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\n\nBy adding the break line after the You win!, we‚Äôll exit the loop when we win. Exiting the loop also means exiting the program, since it‚Äôs the last thing in main(). We have only one more tweak to make: when someone inputs a non-number, we don‚Äôt want to quit, we want to ignore it. We can do that like this:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\n\nThese are the lines that changed:\n\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};\n\n\nThis is how you generally move from ‚Äòcrash on error‚Äô to ‚Äòactually handle the error‚Äô, by switching from expect() to a match statement. A Result is returned by parse(), this is an enum like Ordering, but in this case, each variant has some data associated with it: Ok is a success, and Err is a failure. Each contains more information: the successfully parsed integer, or an error type. In this case, we match on Ok(num), which sets the name num to the unwrapped Ok value (the integer), and then we return it on the right-hand side. In the Err case, we don‚Äôt care what kind of error it is, so we just use the catch all _ instead of a name. This catches everything that isn't Ok, and continue lets us move to the next iteration of the loop; in effect, this enables us to ignore all errors and continue with our program.\n\nNow we should be good! Let‚Äôs try:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.57 secs\n     Running `target/guessing_game`\nGuess the number!\nThe secret number is: 61\nPlease input your guess.\n10\nYou guessed: 10\nToo small!\nPlease input your guess.\n99\nYou guessed: 99\nToo big!\nPlease input your guess.\nfoo\nPlease input your guess.\n61\nYou guessed: 61\nYou win!\n\n\nAwesome! With one tiny last tweak, we have finished the guessing game. Can you think of what it is? That‚Äôs right, we don‚Äôt want to print out the secret number. It was good for testing, but it kind of ruins the game. Here‚Äôs our final source:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\nComplete!\n\nThis project showed you a lot: let, match, methods, associated functions, using external crates, and more.\n\nAt this point, you have successfully built the Guessing Game! Congratulations!\n\nSyntax and Semantics\n\nThis chapter breaks Rust down into small chunks, one for each concept.\n\nIf you‚Äôd like to learn Rust from the bottom up, reading this in order is a great way to do that.\n\nThese sections also form a reference for each concept, so if you‚Äôre reading another tutorial and find something confusing, you can find it explained somewhere in here.\n\nVariable Bindings\n\nVirtually every non-'Hello World‚Äô Rust program uses variable bindings. They bind some value to a name, so it can be used later. let is used to introduce a binding, like this:\n\nfn main() {\n    let x = 5;\n}\n\n\nPutting fn main() { in each example is a bit tedious, so we‚Äôll leave that out in the future. If you‚Äôre following along, make sure to edit your main() function, rather than leaving it off. Otherwise, you‚Äôll get an error.\n\nPatterns\n\nIn many languages, a variable binding would be called a variable, but Rust‚Äôs variable bindings have a few tricks up their sleeves. For example the left-hand side of a let statement is a ‚Äòpattern‚Äô, not a variable name. This means we can do things like:\n\n\nlet (x, y) = (1, 2);\n\nAfter this statement is evaluated, x will be one, and y will be two. Patterns are really powerful, and have their own section in the book. We don‚Äôt need those features for now, so we‚Äôll keep this in the back of our minds as we go forward.\n\nType annotations\n\nRust is a statically typed language, which means that we specify our types up front, and they‚Äôre checked at compile time. So why does our first example compile? Well, Rust has this thing called ‚Äòtype inference‚Äô. If it can figure out what the type of something is, Rust doesn‚Äôt require you to explicitly type it out.\n\nWe can add the type if we want to, though. Types come after a colon (:):\n\n\nlet x: i32 = 5;\n\nIf I asked you to read this out loud to the rest of the class, you‚Äôd say ‚Äúx is a binding with the type i32 and the value 5.‚Äù\n\nIn this case we chose to represent x as a 32-bit signed integer. Rust has many different primitive integer types. They begin with i for signed integers and u for unsigned integers. The possible integer sizes are 8, 16, 32, and 64 bits.\n\nIn future examples, we may annotate the type in a comment. The examples will look like this:\n\nfn main() {\n    let x = 5; // x: i32\n}\n\n\nNote the similarities between this annotation and the syntax you use with let. Including these kinds of comments is not idiomatic Rust, but we'll occasionally include them to help you understand what the types that Rust infers are.\n\nMutability\n\nBy default, bindings are immutable. This code will not compile:\n\nlet x = 5;\nx = 10;\n\n\nIt will give you this error:\n\nerror: re-assignment of immutable variable `x`\n     x = 10;\n     ^~~~~~~\n\n\nIf you want a binding to be mutable, you can use mut:\n\n\nlet mut x = 5; // mut x: i32\nx = 10;\n\nThere is no single reason that bindings are immutable by default, but we can think about it through one of Rust‚Äôs primary focuses: safety. If you forget to say mut, the compiler will catch it, and let you know that you have mutated something you may not have intended to mutate. If bindings were mutable by default, the compiler would not be able to tell you this. If you did intend mutation, then the solution is quite easy: add mut.\n\nThere are other good reasons to avoid mutable state when possible, but they‚Äôre out of the scope of this guide. In general, you can often avoid explicit mutation, and so it is preferable in Rust. That said, sometimes, mutation is what you need, so it‚Äôs not forbidden.\n\nInitializing bindings\n\nRust variable bindings have one more aspect that differs from other languages: bindings are required to be initialized with a value before you're allowed to use them.\n\nLet‚Äôs try it out. Change your src/main.rs file to look like this:\n\nfn main() {\n    let x: i32;\n\n    println!(\"Hello world!\");\n}\n\n\nYou can use cargo build on the command line to build it. You‚Äôll get a warning, but it will still print \"Hello, world!\":\n\n   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\nsrc/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variables)]\n   on by default\nsrc/main.rs:2     let x: i32;\n                      ^\n\n\nRust warns us that we never use the variable binding, but since we never use it, no harm, no foul. Things change if we try to actually use this x, however. Let‚Äôs do that. Change your program to look like this:\n\nfn main() {\n    let x: i32;\n\n    println!(\"The value of x is: {}\", x);\n}\n\n\nAnd try to build it. You‚Äôll get an error:\n\n$ cargo build\n   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\nsrc/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\nsrc/main.rs:4     println!(\"The value of x is: {}\", x);\n                                                    ^\nnote: in expansion of format_args!\n<std macros>:2:23: 2:77 note: expansion site\n<std macros>:1:1: 3:2 note: in expansion of println!\nsrc/main.rs:4:5: 4:42 note: expansion site\nerror: aborting due to previous error\nCould not compile `hello_world`.\n\n\nRust will not let us use a value that has not been initialized.\n\nLet us take a minute to talk about this stuff we've added to println!.\n\nIf you include two curly braces ({}, some call them moustaches...) in your string to print, Rust will interpret this as a request to interpolate some sort of value. String interpolation is a computer science term that means \"stick in the middle of a string.\" We add a comma, and then x, to indicate that we want x to be the value we‚Äôre interpolating. The comma is used to separate arguments we pass to functions and macros, if you‚Äôre passing more than one.\n\nWhen you use the curly braces, Rust will attempt to display the value in a meaningful way by checking out its type. If you want to specify the format in a more detailed manner, there are a wide number of options available. For now, we'll stick to the default: integers aren't very complicated to print.\n\nScope and shadowing\n\nLet‚Äôs get back to bindings. Variable bindings have a scope - they are constrained to live in the block they were defined in. A block is a collection of statements enclosed by { and }. Function definitions are also blocks! In the following example we define two variable bindings, x and y, which live in different blocks. x can be accessed from inside the fn main() {} block, while y can be accessed only from inside the inner block:\n\nfn main() {\n    let x: i32 = 17;\n    {\n        let y: i32 = 3;\n        println!(\"The value of x is {} and value of y is {}\", x, y);\n    }\n    println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n}\n\n\nThe first println! would print \"The value of x is 17 and the value of y is 3\", but this example cannot be compiled successfully, because the second println! cannot access the value of y, since it is not in scope anymore. Instead we get this error:\n\n$ cargo build\n   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)\nmain.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]\nmain.rs:7     println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n                                                                       ^\nnote: in expansion of format_args!\n<std macros>:2:25: 2:56 note: expansion site\n<std macros>:1:1: 2:62 note: in expansion of print!\n<std macros>:3:1: 3:54 note: expansion site\n<std macros>:1:1: 3:58 note: in expansion of println!\nmain.rs:7:5: 7:65 note: expansion site\nmain.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation\nerror: aborting due to previous error\nCould not compile `hello`.\n\nTo learn more, run the command again with --verbose.\n\n\nAdditionally, variable bindings can be shadowed. This means that a later variable binding with the same name as another binding that is currently in scope will override the previous binding.\n\n\nlet x: i32 = 8;\n{\n    println!(\"{}\", x); // Prints \"8\".\n    let x = 12;\n    println!(\"{}\", x); // Prints \"12\".\n}\nprintln!(\"{}\", x); // Prints \"8\".\nlet x =  42;\nprintln!(\"{}\", x); // Prints \"42\".\n\nShadowing and mutable bindings may appear as two sides of the same coin, but they are two distinct concepts that can't always be used interchangeably. For one, shadowing enables us to rebind a name to a value of a different type. It is also possible to change the mutability of a binding. Note that shadowing a name does not alter or destroy the value it was bound to, and the value will continue to exist until it goes out of scope, even if it is no longer accessible by any means.\n\n\nlet mut x: i32 = 1;\nx = 7;\nlet x = x; // `x` is now immutable and is bound to `7`.\n\nlet y = 4;\nlet y = \"I can also be bound to text!\"; // `y` is now of a different type.\nFunctions\n\nEvery Rust program has at least one function, the main function:\n\nfn main() {\n}\n\n\nThis is the simplest possible function declaration. As we mentioned before, fn says ‚Äòthis is a function‚Äô, followed by the name, some parentheses because this function takes no arguments, and then some curly braces to indicate the body. Here‚Äôs a function named foo:\n\n\nfn foo() {\n}\n\nSo, what about taking arguments? Here‚Äôs a function that prints a number:\n\n\nfn print_number(x: i32) {\n    println!(\"x is: {}\", x);\n}\n\nHere‚Äôs a complete program that uses print_number:\n\nfn main() {\n    print_number(5);\n}\n\nfn print_number(x: i32) {\n    println!(\"x is: {}\", x);\n}\n\n\nAs you can see, function arguments work very similar to let declarations: you add a type to the argument name, after a colon.\n\nHere‚Äôs a complete program that adds two numbers together and prints them:\n\nfn main() {\n    print_sum(5, 6);\n}\n\nfn print_sum(x: i32, y: i32) {\n    println!(\"sum is: {}\", x + y);\n}\n\n\nYou separate arguments with a comma, both when you call the function, as well as when you declare it.\n\nUnlike let, you must declare the types of function arguments. This does not work:\n\nfn print_sum(x, y) {\n    println!(\"sum is: {}\", x + y);\n}\n\n\nYou get this error:\n\nexpected one of `!`, `:`, or `@`, found `)`\nfn print_sum(x, y) {\n\n\nThis is a deliberate design decision. While full-program inference is possible, languages which have it, like Haskell, often suggest that documenting your types explicitly is a best-practice. We agree that forcing functions to declare types while allowing for inference inside of function bodies is a wonderful sweet spot between full inference and no inference.\n\nWhat about returning a value? Here‚Äôs a function that adds one to an integer:\n\n\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nRust functions return exactly one value, and you declare the type after an ‚Äòarrow‚Äô, which is a dash (-) followed by a greater-than sign (>). The last line of a function determines what it returns. You‚Äôll note the lack of a semicolon here. If we added it in:\n\nfn add_one(x: i32) -> i32 {\n    x + 1;\n}\n\n\nWe would get an error:\n\nerror: not all control paths return a value\nfn add_one(x: i32) -> i32 {\n     x + 1;\n}\n\nhelp: consider removing this semicolon:\n     x + 1;\n          ^\n\n\nThis reveals two interesting things about Rust: it is an expression-based language, and semicolons are different from semicolons in other ‚Äòcurly brace and semicolon‚Äô-based languages. These two things are related.\n\nExpressions vs. Statements\n\nRust is primarily an expression-based language. There are only two kinds of statements, and everything else is an expression.\n\nSo what's the difference? Expressions return a value, and statements do not. That‚Äôs why we end up with ‚Äònot all control paths return a value‚Äô here: the statement x + 1; doesn‚Äôt return a value. There are two kinds of statements in Rust: ‚Äòdeclaration statements‚Äô and ‚Äòexpression statements‚Äô. Everything else is an expression. Let‚Äôs talk about declaration statements first.\n\nIn some languages, variable bindings can be written as expressions, not statements. Like Ruby:\n\nx = y = 5\n\n\nIn Rust, however, using let to introduce a binding is not an expression. The following will produce a compile-time error:\n\nlet x = (let y = 5); // Expected identifier, found keyword `let`.\n\n\nThe compiler is telling us here that it was expecting to see the beginning of an expression, and a let can only begin a statement, not an expression.\n\nNote that assigning to an already-bound variable (e.g. y = 5) is still an expression, although its value is not particularly useful. Unlike other languages where an assignment evaluates to the assigned value (e.g. 5 in the previous example), in Rust the value of an assignment is an empty tuple () because the assigned value can have only one owner, and any other returned value would be too surprising:\n\n\nlet mut y = 5;\n\nlet x = (y = 6);  // `x` has the value `()`, not `6`.\n\nThe second kind of statement in Rust is the expression statement. Its purpose is to turn any expression into a statement. In practical terms, Rust's grammar expects statements to follow other statements. This means that you use semicolons to separate expressions from each other. This means that Rust looks a lot like most other languages that require you to use semicolons at the end of every line, and you will see semicolons at the end of almost every line of Rust code you see.\n\nWhat is this exception that makes us say \"almost\"? You saw it already, in this code:\n\n\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nOur function claims to return an i32, but with a semicolon, it would return () instead. Rust realizes this probably isn‚Äôt what we want, and suggests removing the semicolon in the error we saw before.\n\nEarly returns\n\nBut what about early returns? Rust does have a keyword for that, return:\n\n\nfn foo(x: i32) -> i32 {\n    return x;\n\n    // We never run this code!\n    x + 1\n}\n\nUsing a return as the last line of a function works, but is considered poor style:\n\n\nfn foo(x: i32) -> i32 {\n    return x + 1;\n}\n\nThe previous definition without return may look a bit strange if you haven‚Äôt worked in an expression-based language before, but it becomes intuitive over time.\n\nDiverging functions\n\nRust has some special syntax for ‚Äòdiverging functions‚Äô, which are functions that do not return:\n\n\nfn diverges() -> ! {\n    panic!(\"This function never returns!\");\n}\n\npanic! is a macro, similar to println!() that we‚Äôve already seen. Unlike println!(), panic!() causes the current thread of execution to crash with the given message. Because this function will cause a crash, it will never return, and so it has the type ‚Äò!‚Äô, which is read ‚Äòdiverges‚Äô.\n\nIf you add a main function that calls diverges() and run it, you‚Äôll get some output that looks like this:\n\nthread ‚Äòmain‚Äô panicked at ‚ÄòThis function never returns!‚Äô, hello.rs:2\n\n\nIf you want more information, you can get a backtrace by setting the RUST_BACKTRACE environment variable:\n\n$ RUST_BACKTRACE=1 ./diverges\nthread 'main' panicked at 'This function never returns!', hello.rs:2\nSome details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\nstack backtrace:\n  hello::diverges\n        at ./hello.rs:2\n  hello::main\n        at ./hello.rs:6\n\n\nIf you want the complete backtrace and filenames:\n\n$ RUST_BACKTRACE=full ./diverges\nthread 'main' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n\n\nIf you need to override an already set RUST_BACKTRACE, in cases when you cannot just unset the variable, then set it to 0 to avoid getting a backtrace. Any other value (even no value at all) turns on backtrace.\n\n$ export RUST_BACKTRACE=1\n...\n$ RUST_BACKTRACE=0 ./diverges \nthread 'main' panicked at 'This function never returns!', hello.rs:2\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\n\nRUST_BACKTRACE also works with Cargo‚Äôs run command:\n\n$ RUST_BACKTRACE=full cargo run\n     Running `target/debug/diverges`\nthread 'main' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n\n\nA diverging function can be used as any type:\n\n\nlet x: i32 = diverges();\nlet x: String = diverges();\nFunction pointers\n\nWe can also create variable bindings which point to functions:\n\n\nlet f: fn(i32) -> i32;\n\nf is a variable binding which points to a function that takes an i32 as an argument and returns an i32. For example:\n\n\nfn plus_one(i: i32) -> i32 {\n    i + 1\n}\n\n// Without type inference:\nlet f: fn(i32) -> i32 = plus_one;\n\n// With type inference:\nlet f = plus_one;\n\nWe can then use f to call the function:\n\n\nlet six = f(5);\nPrimitive Types\n\nThe Rust language has a number of types that are considered ‚Äòprimitive‚Äô. This means that they‚Äôre built-in to the language. Rust is structured in such a way that the standard library also provides a number of useful types built on top of these ones, as well, but these are the most primitive.\n\nBooleans\n\nRust has a built-in boolean type, named bool. It has two values, true and false:\n\n\nlet x = true;\n\nlet y: bool = false;\n\nA common use of booleans is in if conditionals.\n\nYou can find more documentation for bools in the standard library documentation.\n\nchar\n\nThe char type represents a single Unicode scalar value. You can create chars with a single tick: (')\n\n\nlet x = 'x';\nlet two_hearts = 'üíï';\n\nUnlike some other languages, this means that Rust‚Äôs char is not a single byte, but four.\n\nYou can find more documentation for chars in the standard library documentation.\n\nNumeric types\n\nRust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.\n\nThese types consist of two parts: the category, and the size. For example, u16 is an unsigned type with sixteen bits of size. More bits lets you have bigger numbers.\n\nIf a number literal has nothing to cause its type to be inferred, it defaults:\n\n\nlet x = 42; // `x` has type `i32`.\n\nlet y = 1.0; // `y` has type `f64`.\n\nHere‚Äôs a list of the different numeric types, with links to their documentation in the standard library:\n\ni8\ni16\ni32\ni64\nu8\nu16\nu32\nu64\nisize\nusize\nf32\nf64\n\nLet‚Äôs go over them by category:\n\nSigned and Unsigned\n\nInteger types come in two varieties: signed and unsigned. To understand the difference, let‚Äôs consider a number with four bits of size. A signed, four-bit number would let you store numbers from -8 to +7. Signed numbers use ‚Äútwo‚Äôs complement representation‚Äù. An unsigned four bit number, since it does not need to store negatives, can store values from 0 to +15.\n\nUnsigned types use a u for their category, and signed types use i. The i is for ‚Äòinteger‚Äô. So u8 is an eight-bit unsigned number, and i8 is an eight-bit signed number.\n\nFixed-size types\n\nFixed-size types have a specific number of bits in their representation. Valid bit sizes are 8, 16, 32, and 64. So, u32 is an unsigned, 32-bit integer, and i64 is a signed, 64-bit integer.\n\nVariable-size types\n\nRust also provides types whose particular size depends on the underlying machine architecture. Their range is sufficient to express the size of any collection, so these types have ‚Äòsize‚Äô as the category. They come in signed and unsigned varieties which account for two types: isize and usize.\n\nFloating-point types\n\nRust also has two floating point types: f32 and f64. These correspond to IEEE-754 single and double precision numbers.\n\nArrays\n\nLike many programming languages, Rust has list types to represent a sequence of things. The most basic is the array, a fixed-size list of elements of the same type. By default, arrays are immutable.\n\n\nlet a = [1, 2, 3]; // a: [i32; 3]\nlet mut m = [1, 2, 3]; // m: [i32; 3]\n\nArrays have type [T; N]. We‚Äôll talk about this T notation in the generics section. The N is a compile-time constant, for the length of the array.\n\nThere‚Äôs a shorthand for initializing each element of an array to the same value. In this example, each element of a will be initialized to 0:\n\n\nlet a = [0; 20]; // a: [i32; 20]\n\nYou can get the number of elements in an array a with a.len():\n\n\nlet a = [1, 2, 3];\n\nprintln!(\"a has {} elements\", a.len());\n\nYou can access a particular element of an array with subscript notation:\n\n\nlet names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n\nprintln!(\"The second name is: {}\", names[1]);\n\nSubscripts start at zero, like in most programming languages, so the first name is names[0] and the second name is names[1]. The above example prints The second name is: Brian. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.\n\nYou can find more documentation for arrays in the standard library documentation.\n\nSlices\n\nA ‚Äòslice‚Äô is a reference to (or ‚Äúview‚Äù into) another data structure. They are useful for allowing safe, efficient access to a portion of an array without copying. For example, you might want to reference only one line of a file read into memory. By nature, a slice is not created directly, but from an existing variable binding. Slices have a defined length, and can be mutable or immutable.\n\nInternally, slices are represented as a pointer to the beginning of the data and a length.\n\nSlicing syntax\n\nYou can use a combo of & and [] to create a slice from various things. The & indicates that slices are similar to references, which we will cover in detail later in this section. The []s, with a range, let you define the length of the slice:\n\n\nlet a = [0, 1, 2, 3, 4];\nlet complete = &a[..]; // A slice containing all of the elements in `a`.\nlet middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.\n\nSlices have type &[T]. We‚Äôll talk about that T when we cover generics.\n\nYou can find more documentation for slices in the standard library documentation.\n\nstr\n\nRust‚Äôs str type is the most primitive string type. As an unsized type, it‚Äôs not very useful by itself, but becomes useful when placed behind a reference, like &str. We'll elaborate further when we cover Strings and references.\n\nYou can find more documentation for str in the standard library documentation.\n\nTuples\n\nA tuple is an ordered list of fixed size. Like this:\n\n\nlet x = (1, \"hello\");\n\nThe parentheses and commas form this two-length tuple. Here‚Äôs the same code, but with the type annotated:\n\n\nlet x: (i32, &str) = (1, \"hello\");\n\nAs you can see, the type of a tuple looks like the tuple, but with each position having a type name rather than the value. Careful readers will also note that tuples are heterogeneous: we have an i32 and a &str in this tuple. In systems programming languages, strings are a bit more complex than in other languages. For now, read &str as a string slice, and we‚Äôll learn more soon.\n\nYou can assign one tuple into another, if they have the same contained types and arity. Tuples have the same arity when they have the same length.\n\n\nlet mut x = (1, 2); // x: (i32, i32)\nlet y = (2, 3); // y: (i32, i32)\n\nx = y;\n\nYou can access the fields in a tuple through a destructuring let. Here‚Äôs an example:\n\n\nlet (x, y, z) = (1, 2, 3);\n\nprintln!(\"x is {}\", x);\n\nRemember before when I said the left-hand side of a let statement was more powerful than assigning a binding? Here we are. We can put a pattern on the left-hand side of the let, and if it matches up to the right-hand side, we can assign multiple bindings at once. In this case, let ‚Äúdestructures‚Äù or ‚Äúbreaks up‚Äù the tuple, and assigns the bits to three bindings.\n\nThis pattern is very powerful, and we‚Äôll see it repeated more later.\n\nYou can disambiguate a single-element tuple from a value in parentheses with a comma:\n\n\n(0,); // A single-element tuple.\n(0); // A zero in parentheses.\nTuple Indexing\n\nYou can also access fields of a tuple with indexing syntax:\n\n\nlet tuple = (1, 2, 3);\n\nlet x = tuple.0;\nlet y = tuple.1;\nlet z = tuple.2;\n\nprintln!(\"x is {}\", x);\n\nLike array indexing, it starts at zero, but unlike array indexing, it uses a ., rather than []s.\n\nYou can find more documentation for tuples in the standard library documentation.\n\nFunctions\n\nFunctions also have a type! They look like this:\n\n\nfn foo(x: i32) -> i32 { x }\n\nlet x: fn(i32) -> i32 = foo;\n\nIn this case, x is a ‚Äòfunction pointer‚Äô to a function that takes an i32 and returns an i32.\n\nComments\n\nNow that we have some functions, it‚Äôs a good idea to learn about comments. Comments are notes that you leave to other programmers to help explain things about your code. The compiler mostly ignores them.\n\nRust has two kinds of comments that you should care about: line comments and doc comments.\n\n\n// Line comments are anything after ‚Äò//‚Äô and extend to the end of the line.\n\nlet x = 5; // This is also a line comment.\n\n// If you have a long explanation for something, you can put line comments next\n// to each other. Put a space between the // and your comment so that it‚Äôs\n// more readable.\n\nThe other kind of comment is a doc comment. Doc comments use /// instead of //, and support Markdown notation inside:\n\n\n/// Adds one to the number given.\n///\n/// # Examples\n///\n/// ```\n/// let five = 5;\n///\n/// assert_eq!(6, add_one(5));\n/// # fn add_one(x: i32) -> i32 {\n/// #     x + 1\n/// # }\n/// ```\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nThere is another style of doc comment, //!, to comment containing items (e.g. crates, modules or functions), instead of the items following it. Commonly used inside crates root (lib.rs) or modules root (mod.rs):\n\n//! # The Rust Standard Library\n//!\n//! The Rust Standard Library provides the essential runtime\n//! functionality for building portable Rust software.\n\n\nWhen writing doc comments, providing some examples of usage is very, very helpful. You‚Äôll notice we‚Äôve used a new macro here: assert_eq!. This compares two values, and panic!s if they‚Äôre not equal to each other. It‚Äôs very helpful in documentation. There‚Äôs another macro, assert!, which panic!s if the value passed to it is false.\n\nYou can use the rustdoc tool to generate HTML documentation from these doc comments, and also to run the code examples as tests!\n\nif\n\nRust‚Äôs take on if is not particularly complex, but it‚Äôs much more like the if you‚Äôll find in a dynamically typed language than in a more traditional systems language. So let‚Äôs talk about it, to make sure you grasp the nuances.\n\nif is a specific form of a more general concept, the ‚Äòbranch‚Äô, whose name comes from a branch in a tree: a decision point, where depending on a choice, multiple paths can be taken.\n\nIn the case of if, there is one choice that leads down two paths:\n\n\nlet x = 5;\n\nif x == 5 {\n    println!(\"x is five!\");\n}\n\nIf we changed the value of x to something else, this line would not print. More specifically, if the expression after the if evaluates to true, then the block is executed. If it‚Äôs false, then it is not.\n\nIf you want something to happen in the false case, use an else:\n\n\nlet x = 5;\n\nif x == 5 {\n    println!(\"x is five!\");\n} else {\n    println!(\"x is not five :(\");\n}\n\nIf there is more than one case, use an else if:\n\n\nlet x = 5;\n\nif x == 5 {\n    println!(\"x is five!\");\n} else if x == 6 {\n    println!(\"x is six!\");\n} else {\n    println!(\"x is not five or six :(\");\n}\n\nThis is all pretty standard. However, you can also do this:\n\n\nlet x = 5;\n\nlet y = if x == 5 {\n    10\n} else {\n    15\n}; // y: i32\n\nWhich we can (and probably should) write like this:\n\n\nlet x = 5;\n\nlet y = if x == 5 { 10 } else { 15 }; // y: i32\n\nThis works because if is an expression. The value of the expression is the value of the last expression in whichever branch was chosen. An if without an else always results in () as the value.\n\nLoops\n\nRust currently provides three approaches to performing some kind of iterative activity. They are: loop, while and for. Each approach has its own set of uses.\n\nloop\n\nThe infinite loop is the simplest form of loop available in Rust. Using the keyword loop, Rust provides a way to loop indefinitely until some terminating statement is reached. Rust's infinite loops look like this:\n\nloop {\n    println!(\"Loop forever!\");\n}\n\nwhile\n\nRust also has a while loop. It looks like this:\n\n\nlet mut x = 5; // mut x: i32\nlet mut done = false; // mut done: bool\n\nwhile !done {\n    x += x - 3;\n\n    println!(\"{}\", x);\n\n    if x % 5 == 0 {\n        done = true;\n    }\n}\n\nwhile loops are the correct choice when you‚Äôre not sure how many times you need to loop.\n\nIf you need an infinite loop, you may be tempted to write this:\n\nwhile true {\n\n\nHowever, loop is far better suited to handle this case:\n\nloop {\n\n\nRust‚Äôs control-flow analysis treats this construct differently than a while true, since we know that it will always loop. In general, the more information we can give to the compiler, the better it can do with safety and code generation, so you should always prefer loop when you plan to loop infinitely.\n\nfor\n\nThe for loop is used to loop a particular number of times. Rust‚Äôs for loops work a bit differently than in other systems languages, however. Rust‚Äôs for loop doesn‚Äôt look like this ‚ÄúC-style‚Äù for loop:\n\nfor (x = 0; x < 10; x++) {\n    printf( \"%d\\n\", x );\n}\n\n\nInstead, it looks like this:\n\n\nfor x in 0..10 {\n    println!(\"{}\", x); // x: i32\n}\n\nIn slightly more abstract terms,\n\nfor var in expression {\n    code\n}\n\n\nThe expression is an item that can be converted into an iterator using IntoIterator. The iterator gives back a series of elements, one element per iteration of the loop. That value is then bound to the name var, which is valid for the loop body. Once the body is over, the next value is fetched from the iterator, and we loop another time. When there are no more values, the for loop is over.\n\nIn our example, 0..10 is an expression that takes a start and an end position, and gives an iterator over those values. The upper bound is exclusive, though, so our loop will print 0 through 9, not 10.\n\nRust does not have the ‚ÄúC-style‚Äù for loop on purpose. Manually controlling each element of the loop is complicated and error prone, even for experienced C developers.\n\nEnumerate\n\nWhen you need to keep track of how many times you have already looped, you can use the .enumerate() function.\n\nOn ranges:\n\nfor (index, value) in (5..10).enumerate() {\n    println!(\"index = {} and value = {}\", index, value);\n}\n\nOutputs:\n\nindex = 0 and value = 5\nindex = 1 and value = 6\nindex = 2 and value = 7\nindex = 3 and value = 8\nindex = 4 and value = 9\n\n\nDon't forget to add the parentheses around the range.\n\nOn iterators:\n\nlet lines = \"hello\\nworld\".lines();\n\nfor (linenumber, line) in lines.enumerate() {\n    println!(\"{}: {}\", linenumber, line);\n}\n\nOutputs:\n\n0: hello\n1: world\n\nEnding iteration early\n\nLet‚Äôs take a look at that while loop we had earlier:\n\n\nlet mut x = 5;\nlet mut done = false;\n\nwhile !done {\n    x += x - 3;\n\n    println!(\"{}\", x);\n\n    if x % 5 == 0 {\n        done = true;\n    }\n}\n\nWe had to keep a dedicated mut boolean variable binding, done, to know when we should exit out of the loop. Rust has two keywords to help us with modifying iteration: break and continue.\n\nIn this case, we can write the loop in a better way with break:\n\n\nlet mut x = 5;\n\nloop {\n    x += x - 3;\n\n    println!(\"{}\", x);\n\n    if x % 5 == 0 { break; }\n}\n\nWe now loop forever with loop and use break to break out early. Issuing an explicit return statement will also serve to terminate the loop early.\n\ncontinue is similar, but instead of ending the loop, it goes to the next iteration. This will only print the odd numbers:\n\n\nfor x in 0..10 {\n    if x % 2 == 0 { continue; }\n\n    println!(\"{}\", x);\n}\nLoop labels\n\nYou may also encounter situations where you have nested loops and need to specify which one your break or continue statement is for. Like most other languages, Rust's break or continue apply to the innermost loop. In a situation where you would like to break or continue for one of the outer loops, you can use labels to specify which loop the break or continue statement applies to.\n\nIn the example below, we continue to the next iteration of outer loop when x is even, while we continue to the next iteration of inner loop when y is even. So it will execute the println! when both x and y are odd.\n\n\n'outer: for x in 0..10 {\n    'inner: for y in 0..10 {\n        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.\n        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.\n        println!(\"x: {}, y: {}\", x, y);\n    }\n}\nVectors\n\nA ‚Äòvector‚Äô is a dynamic or ‚Äògrowable‚Äô array, implemented as the standard library type Vec<T>. The T means that we can have vectors of any type (see the chapter on generics for more). Vectors always allocate their data on the heap. You can create them with the vec! macro:\n\n\nlet v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>\n\n(Notice that unlike the println! macro we‚Äôve used in the past, we use square brackets [] with vec! macro. Rust allows you to use either in either situation, this is just convention.)\n\nThere‚Äôs an alternate form of vec! for repeating an initial value:\n\n\nlet v = vec![0; 10]; // A vector of ten zeroes.\n\nVectors store their contents as contiguous arrays of T on the heap. This means that they must be able to know the size of T at compile time (that is, how many bytes are needed to store a T?). The size of some things can't be known at compile time. For these you'll have to store a pointer to that thing: thankfully, the Box type works perfectly for this.\n\nAccessing elements\n\nTo get the value at a particular index in the vector, we use []s:\n\n\nlet v = vec![1, 2, 3, 4, 5];\n\nprintln!(\"The third element of v is {}\", v[2]);\n\nThe indices count from 0, so the third element is v[2].\n\nIt‚Äôs also important to note that you must index with the usize type:\n\nlet v = vec![1, 2, 3, 4, 5];\n\nlet i: usize = 0;\nlet j: i32 = 0;\n\n// Works:\nv[i];\n\n// Doesn‚Äôt:\nv[j];\n\n\nIndexing with a non-usize type gives an error that looks like this:\n\nerror: the trait bound `collections::vec::Vec<_> : core::ops::Index<i32>`\nis not satisfied [E0277]\nv[j];\n^~~~\nnote: the type `collections::vec::Vec<_>` cannot be indexed by `i32`\nerror: aborting due to previous error\n\n\nThere‚Äôs a lot of punctuation in that message, but the core of it makes sense: you cannot index with an i32.\n\nOut-of-bounds Access\n\nIf you try to access an index that doesn‚Äôt exist:\n\nlet v = vec![1, 2, 3];\nprintln!(\"Item 7 is {}\", v[7]);\n\n\nthen the current thread will panic with a message like this:\n\nthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 7'\n\n\nIf you want to handle out-of-bounds errors without panicking, you can use methods like get or get_mut that return None when given an invalid index:\n\n\nlet v = vec![1, 2, 3];\nmatch v.get(7) {\n    Some(x) => println!(\"Item 7 is {}\", x),\n    None => println!(\"Sorry, this vector is too short.\")\n}\nIterating\n\nOnce you have a vector, you can iterate through its elements with for. There are three versions:\n\n\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n\nNote: You cannot use the vector again once you have iterated by taking ownership of the vector. You can iterate the vector multiple times by taking a reference to the vector whilst iterating. For example, the following code does not compile.\n\nlet v = vec![1, 2, 3, 4, 5];\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n\n\nWhereas the following works perfectly,\n\n\nlet v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"This is a reference to {}\", i);\n}\n\nfor i in &v {\n    println!(\"This is a reference to {}\", i);\n}\n\nVectors have many more useful methods, which you can read about in their API documentation.\n\nOwnership\n\nThis is the first of three sections presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:\n\nownership, which you‚Äôre reading now\nborrowing, and their associated feature ‚Äòreferences‚Äô\nlifetimes, an advanced concept of borrowing\n\nThese three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.\n\nMeta\n\nBefore we get to the details, two important notes about the ownership system.\n\nRust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is done at compile time. You do not pay any run-time cost for any of these features.\n\nHowever, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.\n\nWith that in mind, let‚Äôs learn about ownership.\n\nOwnership\n\nVariable bindings have a property in Rust: they ‚Äòhave ownership‚Äô of what they‚Äôre bound to. This means that when a binding goes out of scope, Rust will free the bound resources. For example:\n\n\nfn foo() {\n    let v = vec![1, 2, 3];\n}\n\nWhen v comes into scope, a new vector is created on the stack, and it allocates space on the heap for its elements. When v goes out of scope at the end of foo(), Rust will clean up everything related to the vector, even the heap-allocated memory. This happens deterministically, at the end of the scope.\n\nWe covered vectors in the previous chapter; we use them here as an example of a type that allocates space on the heap at runtime. They behave like arrays, except their size may change by push()ing more elements onto them.\n\nVectors have a generic type Vec<T>, so in this example v will have type Vec<i32>. We'll cover generics in detail in a later chapter.\n\nMove semantics\n\nThere‚Äôs some more subtlety here, though: Rust ensures that there is exactly one binding to any given resource. For example, if we have a vector, we can assign it to another binding:\n\n\nlet v = vec![1, 2, 3];\n\nlet v2 = v;\n\nBut, if we try to use v afterwards, we get an error:\n\nlet v = vec![1, 2, 3];\n\nlet v2 = v;\n\nprintln!(\"v[0] is: {}\", v[0]);\n\n\nIt looks like this:\n\nerror: use of moved value: `v`\nprintln!(\"v[0] is: {}\", v[0]);\n                        ^\n\n\nA similar thing happens if we define a function which takes ownership, and try to use something after we‚Äôve passed it as an argument:\n\nfn take(v: Vec<i32>) {\n    // What happens here isn‚Äôt important.\n}\n\nlet v = vec![1, 2, 3];\n\ntake(v);\n\nprintln!(\"v[0] is: {}\", v[0]);\n\n\nSame error: ‚Äòuse of moved value‚Äô. When we transfer ownership to something else, we say that we‚Äôve ‚Äòmoved‚Äô the thing we refer to. You don‚Äôt need some sort of special annotation here, it‚Äôs the default thing that Rust does.\n\nThe details\n\nThe reason that we cannot use a binding after we‚Äôve moved it is subtle, but important.\n\nWhen we write code like this:\n\n\nlet x = 10;\n\nRust allocates memory for an integer i32 on the stack, copies the bit pattern representing the value of 10 to the allocated memory and binds the variable name x to this memory region for future reference.\n\nNow consider the following code fragment:\n\n\nlet v = vec![1, 2, 3];\n\nlet mut v2 = v;\n\nThe first line allocates memory for the vector object v on the stack like it does for x above. But in addition to that it also allocates some memory on the heap for the actual data ([1, 2, 3]). Rust copies the address of this heap allocation to an internal pointer, which is part of the vector object placed on the stack (let's call it the data pointer).\n\nIt is worth pointing out (even at the risk of stating the obvious) that the vector object and its data live in separate memory regions instead of being a single contiguous memory allocation (due to reasons we will not go into at this point of time). These two parts of the vector (the one on the stack and one on the heap) must agree with each other at all times with regards to things like the length, capacity, etc.\n\nWhen we move v to v2, Rust actually does a bitwise copy of the vector object v into the stack allocation represented by v2. This shallow copy does not create a copy of the heap allocation containing the actual data. Which means that there would be two pointers to the contents of the vector both pointing to the same memory allocation on the heap. It would violate Rust‚Äôs safety guarantees by introducing a data race if one could access both v and v2 at the same time.\n\nFor example if we truncated the vector to just two elements through v2:\n\n\nv2.truncate(2);\n\nand v were still accessible we'd end up with an invalid vector since v would not know that the heap data has been truncated. Now, the part of the vector v on the stack does not agree with the corresponding part on the heap. v still thinks there are three elements in the vector and will happily let us access the non existent element v[2] but as you might already know this is a recipe for disaster. Especially because it might lead to a segmentation fault or worse allow an unauthorized user to read from memory to which they don't have access.\n\nThis is why Rust forbids using v after we‚Äôve done the move.\n\nIt‚Äôs also important to note that optimizations may remove the actual copy of the bytes on the stack, depending on circumstances. So it may not be as inefficient as it initially seems.\n\nCopy types\n\nWe‚Äôve established that when ownership is transferred to another binding, you cannot use the original binding. However, there‚Äôs a trait that changes this behavior, and it‚Äôs called Copy. We haven‚Äôt discussed traits yet, but for now, you can think of them as an annotation to a particular type that adds extra behavior. For example:\n\n\nlet v = 1;\n\nlet v2 = v;\n\nprintln!(\"v is: {}\", v);\n\nIn this case, v is an i32, which implements the Copy trait. This means that, just like a move, when we assign v to v2, a copy of the data is made. But, unlike a move, we can still use v afterward. This is because an i32 has no pointers to data somewhere else, copying it is a full copy.\n\nAll primitive types implement the Copy trait and their ownership is therefore not moved like one would assume, following the ‚Äòownership rules‚Äô. To give an example, the two following snippets of code only compile because the i32 and bool types implement the Copy trait.\n\nfn main() {\n    let a = 5;\n\n    let _y = double(a);\n    println!(\"{}\", a);\n}\n\nfn double(x: i32) -> i32 {\n    x * 2\n}\n\nfn main() {\n    let a = true;\n\n    let _y = change_truth(a);\n    println!(\"{}\", a);\n}\n\nfn change_truth(x: bool) -> bool {\n    !x\n}\n\n\nIf we had used types that do not implement the Copy trait, we would have gotten a compile error because we tried to use a moved value.\n\nerror: use of moved value: `a`\nprintln!(\"{}\", a);\n               ^\n\n\nWe will discuss how to make your own types Copy in the traits section.\n\nMore than ownership\n\nOf course, if we had to hand ownership back with every function we wrote:\n\n\nfn foo(v: Vec<i32>) -> Vec<i32> {\n    // Do stuff with `v`.\n\n    // Hand back ownership.\n    v\n}\n\nThis would get very tedious. It gets worse the more things we want to take ownership of:\n\n\nfn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n    // Do stuff with `v1` and `v2`.\n\n    // Hand back ownership, and the result of our function.\n    (v1, v2, 42)\n}\n\nlet v1 = vec![1, 2, 3];\nlet v2 = vec![1, 2, 3];\n\nlet (v1, v2, answer) = foo(v1, v2);\n\nUgh! The return type, return line, and calling the function gets way more complicated.\n\nLuckily, Rust offers a feature which helps us solve this problem. It‚Äôs called borrowing and is the topic of the next section!\n\nReferences and Borrowing\n\nThis is the second of three sections presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:\n\nownership, the key concept\nborrowing, which you‚Äôre reading now\nlifetimes, an advanced concept of borrowing\n\nThese three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.\n\nMeta\n\nBefore we get to the details, two important notes about the ownership system.\n\nRust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is done at compile time. You do not pay any run-time cost for any of these features.\n\nHowever, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.\n\nWith that in mind, let‚Äôs learn about borrowing.\n\nBorrowing\n\nAt the end of the ownership section, we had a nasty function that looked like this:\n\n\nfn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n    // Do stuff with `v1` and `v2`.\n\n    // Hand back ownership, and the result of our function.\n    (v1, v2, 42)\n}\n\nlet v1 = vec![1, 2, 3];\nlet v2 = vec![1, 2, 3];\n\nlet (v1, v2, answer) = foo(v1, v2);\n\nThis is not idiomatic Rust, however, as it doesn‚Äôt take advantage of borrowing. Here‚Äôs the first step:\n\n\nfn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n    // Do stuff with `v1` and `v2`.\n\n    // Return the answer.\n    42\n}\n\nlet v1 = vec![1, 2, 3];\nlet v2 = vec![1, 2, 3];\n\nlet answer = foo(&v1, &v2);\n\n// We can use `v1` and `v2` here!\n\nA more concrete example:\n\nfn main() {\n    // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed.\n    fn sum_vec(v: &Vec<i32>) -> i32 {\n        v.iter().fold(0, |a, &b| a + b)\n    }\n    // Borrow two vectors and sum them.\n    // This kind of borrowing does not allow mutation through the borrowed reference.\n    fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n        // Do stuff with `v1` and `v2`.\n        let s1 = sum_vec(v1);\n        let s2 = sum_vec(v2);\n        // Return the answer.\n        s1 + s2\n    }\n\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![4, 5, 6];\n\n    let answer = foo(&v1, &v2);\n    println!(\"{}\", answer);\n}\n\n\nInstead of taking Vec<i32>s as our arguments, we take a reference: &Vec<i32>. And instead of passing v1 and v2 directly, we pass &v1 and &v2. We call the &T type a ‚Äòreference‚Äô, and rather than owning the resource, it borrows ownership. A binding that borrows something does not deallocate the resource when it goes out of scope. This means that after the call to foo(), we can use our original bindings again.\n\nReferences are immutable, like bindings. This means that inside of foo(), the vectors can‚Äôt be changed at all:\n\nfn foo(v: &Vec<i32>) {\n     v.push(5);\n}\n\nlet v = vec![];\n\nfoo(&v);\n\n\nwill give us this error:\n\nerror: cannot borrow immutable borrowed content `*v` as mutable\nv.push(5);\n^\n\n\nPushing a value mutates the vector, and so we aren‚Äôt allowed to do it.\n\n&mut references\n\nThere‚Äôs a second kind of reference: &mut T. A ‚Äòmutable reference‚Äô allows you to mutate the resource you‚Äôre borrowing. For example:\n\n\nlet mut x = 5;\n{\n    let y = &mut x;\n    *y += 1;\n}\nprintln!(\"{}\", x);\n\nThis will print 6. We make y a mutable reference to x, then add one to the thing y points at. You‚Äôll notice that x had to be marked mut as well. If it wasn‚Äôt, we couldn‚Äôt take a mutable borrow to an immutable value.\n\nYou'll also notice we added an asterisk (*) in front of y, making it *y, this is because y is a &mut reference. You'll need to use asterisks to access the contents of a reference as well.\n\nOtherwise, &mut references are like references. There is a large difference between the two, and how they interact, though. You can tell something is fishy in the above example, because we need that extra scope, with the { and }. If we remove them, we get an error:\n\nerror: cannot borrow `x` as immutable because it is also borrowed as mutable\n    println!(\"{}\", x);\n                   ^\nnote: previous borrow of `x` occurs here; the mutable borrow prevents\nsubsequent moves, borrows, or modification of `x` until the borrow ends\n        let y = &mut x;\n                     ^\nnote: previous borrow ends here\nfn main() {\n\n}\n^\n\n\nAs it turns out, there are rules.\n\nThe Rules\n\nHere are the rules for borrowing in Rust:\n\nFirst, any borrow must last for a scope no greater than that of the owner. Second, you may have one or the other of these two kinds of borrows, but not both at the same time:\n\none or more references (&T) to a resource,\nexactly one mutable reference (&mut T).\n\nYou may notice that this is very similar to, though not exactly the same as, the definition of a data race:\n\nThere is a ‚Äòdata race‚Äô when two or more pointers access the same memory location at the same time, where at least one of them is writing, and the operations are not synchronized.\n\nWith references, you may have as many as you‚Äôd like, since none of them are writing. However, as we can only have one &mut at a time, it is impossible to have a data race. This is how Rust prevents data races at compile time: we‚Äôll get errors if we break the rules.\n\nWith this in mind, let‚Äôs consider our example again.\n\nThinking in scopes\n\nHere‚Äôs the code:\n\nfn main() {\n    let mut x = 5;\n    let y = &mut x;\n\n    *y += 1;\n\n    println!(\"{}\", x);\n}\n\n\nThis code gives us this error:\n\nerror: cannot borrow `x` as immutable because it is also borrowed as mutable\n    println!(\"{}\", x);\n                   ^\n\n\nThis is because we‚Äôve violated the rules: we have a &mut T pointing to x, and so we aren‚Äôt allowed to create any &Ts. It's one or the other. The note hints at how to think about this problem:\n\nnote: previous borrow ends here\nfn main() {\n\n}\n^\n\n\nIn other words, the mutable borrow is held through the rest of our example. What we want is for the mutable borrow by y to end so that the resource can be returned to the owner, x. x can then provide an immutable borrow to println!. In Rust, borrowing is tied to the scope that the borrow is valid for. And our scopes look like this:\n\nfn main() {\n    let mut x = 5;\n\n    let y = &mut x;    // -+ &mut borrow of `x` starts here.\n                       //  |\n    *y += 1;           //  |\n                       //  |\n    println!(\"{}\", x); // -+ - Try to borrow `x` here.\n}                      // -+ &mut borrow of `x` ends here.\n                       \n\n\nThe scopes conflict: we can‚Äôt make an &x while y is in scope.\n\nSo when we add the curly braces:\n\n\nlet mut x = 5;\n\n{\n    let y = &mut x; // -+ &mut borrow starts here.\n    *y += 1;        //  |\n}                   // -+ ... and ends here.\n\nprintln!(\"{}\", x);  // <- Try to borrow `x` here.\n\nThere‚Äôs no problem. Our mutable borrow goes out of scope before we create an immutable one. So scope is the key to seeing how long a borrow lasts for.\n\nIssues borrowing prevents\n\nWhy have these restrictive rules? Well, as we noted, these rules prevent data races. What kinds of issues do data races cause? Here are a few.\n\nIterator invalidation\n\nOne example is ‚Äòiterator invalidation‚Äô, which happens when you try to mutate a collection that you‚Äôre iterating over. Rust‚Äôs borrow checker prevents this from happening:\n\n\nlet mut v = vec![1, 2, 3];\n\nfor i in &v {\n    println!(\"{}\", i);\n}\n\nThis prints out one through three. As we iterate through the vector, we‚Äôre only given references to the elements. And v is itself borrowed as immutable, which means we can‚Äôt change it while we‚Äôre iterating:\n\nlet mut v = vec![1, 2, 3];\n\nfor i in &v {\n    println!(\"{}\", i);\n    v.push(34);\n}\n\n\nHere‚Äôs the error:\n\nerror: cannot borrow `v` as mutable because it is also borrowed as immutable\n    v.push(34);\n    ^\nnote: previous borrow of `v` occurs here; the immutable borrow prevents\nsubsequent moves or mutable borrows of `v` until the borrow ends\nfor i in &v {\n          ^\nnote: previous borrow ends here\nfor i in &v {\n    println!(‚Äú{}‚Äù, i);\n    v.push(34);\n}\n^\n\n\nWe can‚Äôt modify v because it‚Äôs borrowed by the loop.\n\nUse after free\n\nReferences must not live longer than the resource they refer to. Rust will check the scopes of your references to ensure that this is true.\n\nIf Rust didn‚Äôt check this property, we could accidentally use a reference which was invalid. For example:\n\nlet y: &i32;\n{\n    let x = 5;\n    y = &x;\n}\n\nprintln!(\"{}\", y);\n\n\nWe get this error:\n\nerror: `x` does not live long enough\n    y = &x;\n         ^\nnote: reference must be valid for the block suffix following statement 0 at\n2:16...\nlet y: &i32;\n{\n    let x = 5;\n    y = &x;\n}\n\nnote: ...but borrowed value is only valid for the block suffix following\nstatement 0 at 4:18\n    let x = 5;\n    y = &x;\n}\n\n\nIn other words, y is only valid for the scope where x exists. As soon as x goes away, it becomes invalid to refer to it. As such, the error says that the borrow ‚Äòdoesn‚Äôt live long enough‚Äô because it‚Äôs not valid for the right amount of time.\n\nThe same problem occurs when the reference is declared before the variable it refers to. This is because resources within the same scope are freed in the opposite order they were declared:\n\nlet y: &i32;\nlet x = 5;\ny = &x;\n\nprintln!(\"{}\", y);\n\n\nWe get this error:\n\nerror: `x` does not live long enough\ny = &x;\n     ^\nnote: reference must be valid for the block suffix following statement 0 at\n2:16...\n    let y: &i32;\n    let x = 5;\n    y = &x;\n\n    println!(\"{}\", y);\n}\n\nnote: ...but borrowed value is only valid for the block suffix following\nstatement 1 at 3:14\n    let x = 5;\n    y = &x;\n\n    println!(\"{}\", y);\n}\n\n\nIn the above example, y is declared before x, meaning that y lives longer than x, which is not allowed.\n\nLifetimes\n\nThis is the last of three sections presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:\n\nownership, the key concept\nborrowing, and their associated feature ‚Äòreferences‚Äô\nlifetimes, which you‚Äôre reading now\n\nThese three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.\n\nMeta\n\nBefore we get to the details, two important notes about the ownership system.\n\nRust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is done at compile time. You do not pay any run-time cost for any of these features.\n\nHowever, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.\n\nWith that in mind, let‚Äôs learn about lifetimes.\n\nLifetimes\n\nLending out a reference to a resource that someone else owns can be complicated. For example, imagine this set of operations:\n\nI acquire a handle to some kind of resource.\nI lend you a reference to the resource.\nI decide I‚Äôm done with the resource, and deallocate it, while you still have your reference.\nYou decide to use the resource.\n\nUh oh! Your reference is pointing to an invalid resource. This is called a dangling pointer or ‚Äòuse after free‚Äô, when the resource is memory. A small example of such a situation would be:\n\nlet r;              // Introduce reference: `r`.\n{\n    let i = 1;      // Introduce scoped value: `i`.\n    r = &i;         // Store reference of `i` in `r`.\n}                   // `i` goes out of scope and is dropped.\n\nprintln!(\"{}\", r);  // `r` still refers to `i`.\n\n\nTo fix this, we have to make sure that step four never happens after step three. In the small example above the Rust compiler is able to report the issue as it can see the lifetimes of the various values in the function.\n\nWhen we have a function that takes arguments by reference the situation becomes more complex. Consider the following example:\n\nfn skip_prefix(line: &str, prefix: &str) -> &str {\n    // ...\n}\n\nlet line = \"lang:en=Hello World!\";\nlet lang = \"en\";\n\nlet v;\n{\n    let p = format!(\"lang:{}=\", lang);  // -+ `p` comes into scope.\n    v = skip_prefix(line, p.as_str());  //  |\n}                                       // -+ `p` goes out of scope.\nprintln!(\"{}\", v);\n\n\nHere we have a function skip_prefix which takes two &str references as parameters and returns a single &str reference. We call it by passing in references to line and p: Two variables with different lifetimes. Now the safety of the println!-line depends on whether the reference returned by skip_prefix function references the still living line or the already dropped p string.\n\nBecause of the above ambiguity, Rust will refuse to compile the example code. To get it to compile we need to tell the compiler more about the lifetimes of the references. This can be done by making the lifetimes explicit in the function declaration:\n\n\nfn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {\n    // ...\n}\n\nLet's examine the changes without going too deep into the syntax for now - we'll get to that later. The first change was adding the <'a, 'b> after the method name. This introduces two lifetime parameters: 'a and 'b. Next, each reference in the function signature was associated with one of the lifetime parameters by adding the lifetime name after the &. This tells the compiler how the lifetimes between different references are related.\n\nAs a result the compiler is now able to deduce that the return value of skip_prefix has the same lifetime as the line parameter, which makes the v reference safe to use even after the p goes out of scope in the original example.\n\nIn addition to the compiler being able to validate the usage of skip_prefix return value, it can also ensure that the implementation follows the contract established by the function declaration. This is useful especially when you are implementing traits that are introduced later in the book.\n\nNote It's important to understand that lifetime annotations are descriptive, not prescriptive. This means that how long a reference is valid is determined by the code, not by the annotations. The annotations, however, give information about lifetimes to the compiler that uses them to check the validity of references. The compiler can do so without annotations in simple cases, but needs the programmer's support in complex scenarios.\n\nSyntax\n\nThe 'a reads ‚Äòthe lifetime a‚Äô. Technically, every reference has some lifetime associated with it, but the compiler lets you elide (i.e. omit, see \"Lifetime Elision\" below) them in common cases. Before we get to that, though, let‚Äôs look at a short example with explicit lifetimes:\n\nfn bar<'a>(...)\n\n\nWe previously talked a little about function syntax, but we didn‚Äôt discuss the <>s after a function‚Äôs name. A function can have ‚Äògeneric parameters‚Äô between the <>s, of which lifetimes are one kind. We‚Äôll discuss other kinds of generics later in the book, but for now, let‚Äôs focus on the lifetimes aspect.\n\nWe use <> to declare our lifetimes. This says that bar has one lifetime, 'a. If we had two reference parameters with different lifetimes, it would look like this:\n\nfn bar<'a, 'b>(...)\n\n\nThen in our parameter list, we use the lifetimes we‚Äôve named:\n\n...(x: &'a i32)\n\n\nIf we wanted a &mut reference, we‚Äôd do this:\n\n...(x: &'a mut i32)\n\n\nIf you compare &mut i32 to &'a mut i32, they‚Äôre the same, it‚Äôs that the lifetime 'a has snuck in between the & and the mut i32. We read &mut i32 as ‚Äòa mutable reference to an i32‚Äô and &'a mut i32 as ‚Äòa mutable reference to an i32 with the lifetime 'a‚Äô.\n\nIn structs\n\nYou‚Äôll also need explicit lifetimes when working with structs that contain references:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n    let f = Foo { x: y };\n\n    println!(\"{}\", f.x);\n}\n\n\nAs you can see, structs can also have lifetimes. In a similar way to functions,\n\n\nstruct Foo<'a> {\n\ndeclares a lifetime, and\n\n\nx: &'a i32,\n\nuses it. So why do we need a lifetime here? We need to ensure that any reference to a Foo cannot outlive the reference to an i32 it contains.\n\nimpl blocks\n\nLet‚Äôs implement a method on Foo:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nimpl<'a> Foo<'a> {\n    fn x(&self) -> &'a i32 { self.x }\n}\n\nfn main() {\n    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n    let f = Foo { x: y };\n\n    println!(\"x is: {}\", f.x());\n}\n\n\nAs you can see, we need to declare a lifetime for Foo in the impl line. We repeat 'a twice, like on functions: impl<'a> defines a lifetime 'a, and Foo<'a> uses it.\n\nMultiple lifetimes\n\nIf you have multiple references, you can use the same lifetime multiple times:\n\n\nfn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {\n\nThis says that x and y both are alive for the same scope, and that the return value is also alive for that scope. If you wanted x and y to have different lifetimes, you can use multiple lifetime parameters:\n\n\nfn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {\n\nIn this example, x and y have different valid scopes, but the return value has the same lifetime as x.\n\nThinking in scopes\n\nA way to think about lifetimes is to visualize the scope that a reference is valid for. For example:\n\nfn main() {\n    let y = &5;     // -+ `y` comes into scope.\n                    //  |\n    // Stuff...     //  |\n                    //  |\n}                   // -+ `y` goes out of scope.\n\n\nAdding in our Foo:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let y = &5;           // -+ `y` comes into scope.\n    let f = Foo { x: y }; // -+ `f` comes into scope.\n                          //  |\n    // Stuff...           //  |\n                          //  |\n}                         // -+ `f` and `y` go out of scope.\n\n\nOur f lives within the scope of y, so everything works. What if it didn‚Äôt? This code won‚Äôt work:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let x;                    // -+ `x` comes into scope.\n                              //  |\n    {                         //  |\n        let y = &5;           // ---+ `y` comes into scope.\n        let f = Foo { x: y }; // ---+ `f` comes into scope.\n        x = &f.x;             //  | | This causes an error.\n    }                         // ---+ `f` and y go out of scope.\n                              //  |\n    println!(\"{}\", x);        //  |\n}                             // -+ `x` goes out of scope.\n\n\nWhew! As you can see here, the scopes of f and y are smaller than the scope of x. But when we do x = &f.x, we make x a reference to something that‚Äôs about to go out of scope.\n\nNamed lifetimes are a way of giving these scopes a name. Giving something a name is the first step towards being able to talk about it.\n\n'static\n\nThe lifetime named ‚Äòstatic‚Äô is a special lifetime. It signals that something has the lifetime of the entire program. Most Rust programmers first come across 'static when dealing with strings:\n\n\nlet x: &'static str = \"Hello, world.\";\n\nString literals have the type &'static str because the reference is always alive: they are baked into the data segment of the final binary. Another example are globals:\n\n\nstatic FOO: i32 = 5;\nlet x: &'static i32 = &FOO;\n\nThis adds an i32 to the data segment of the binary, and x is a reference to it.\n\nLifetime Elision\n\nRust supports powerful local type inference in the bodies of functions, but it deliberately does not perform any reasoning about types for item signatures. However, for ergonomic reasons, a very restricted secondary inference algorithm called ‚Äúlifetime elision‚Äù does apply when judging lifetimes. Lifetime elision is concerned solely with inferring lifetime parameters using three easily memorizable and unambiguous rules. This means lifetime elision acts as a shorthand for writing an item signature, while not hiding away the actual types involved as full local inference would if applied to it.\n\nWhen talking about lifetime elision, we use the terms input lifetime and output lifetime. An input lifetime is a lifetime associated with a parameter of a function, and an output lifetime is a lifetime associated with the return value of a function. For example, this function has an input lifetime:\n\nfn foo<'a>(bar: &'a str)\n\n\nThis one has an output lifetime:\n\nfn foo<'a>() -> &'a str\n\n\nThis one has a lifetime in both positions:\n\nfn foo<'a>(bar: &'a str) -> &'a str\n\n\nHere are the three rules:\n\nEach elided lifetime in a function‚Äôs arguments becomes a distinct lifetime parameter.\n\nIf there is exactly one input lifetime, elided or not, that lifetime is assigned to all elided lifetimes in the return values of that function.\n\nIf there are multiple input lifetimes, but one of them is &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n\nOtherwise, it is an error to elide an output lifetime.\n\nExamples\n\nHere are some examples of functions with elided lifetimes. We‚Äôve paired each example of an elided lifetime with its expanded form.\n\nfn print(s: &str); // elided\nfn print<'a>(s: &'a str); // expanded\n\nfn debug(lvl: u32, s: &str); // elided\nfn debug<'a>(lvl: u32, s: &'a str); // expanded\n\n\nIn the preceding example, lvl doesn‚Äôt need a lifetime because it‚Äôs not a reference (&). Only things relating to references (such as a struct which contains a reference) need lifetimes.\n\nfn substr(s: &str, until: u32) -> &str; // elided\nfn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n\nfn get_str() -> &str; // ILLEGAL, no inputs\n\nfn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\nfn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is ambiguous\n\nfn get_mut(&mut self) -> &mut T; // elided\nfn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n\nfn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // elided\nfn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded\n\nfn new(buf: &mut [u8]) -> BufWriter; // elided\nfn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // expanded\n\nMutability\n\nMutability, the ability to change something, works a bit differently in Rust than in other languages. The first aspect of mutability is its non-default status:\n\nlet x = 5;\nx = 6; // Error!\n\n\nWe can introduce mutability with the mut keyword:\n\n\nlet mut x = 5;\n\nx = 6; // No problem!\n\nThis is a mutable variable binding. When a binding is mutable, it means you‚Äôre allowed to change what the binding points to. So in the above example, it‚Äôs not so much that the value at x is changing, but that the binding changed from one i32 to another.\n\nYou can also create a reference to it, using &x, but if you want to use the reference to change it, you will need a mutable reference:\n\n\nlet mut x = 5;\nlet y = &mut x;\n\ny is an immutable binding to a mutable reference, which means that you can‚Äôt bind 'y' to something else (y = &mut z), but y can be used to bind x to something else (*y = 5). A subtle distinction.\n\nOf course, if you need both:\n\n\nlet mut x = 5;\nlet mut y = &mut x;\n\nNow y can be bound to another value, and the value it‚Äôs referencing can be changed.\n\nIt‚Äôs important to note that mut is part of a pattern, so you can do things like this:\n\n\nlet (mut x, y) = (5, 6);\n\nfn foo(mut x: i32) {\n\nNote that here, the x is mutable, but not the y.\n\nInterior vs. Exterior Mutability\n\nHowever, when we say something is ‚Äòimmutable‚Äô in Rust, that doesn‚Äôt mean that it‚Äôs not able to be changed: we are referring to its ‚Äòexterior mutability‚Äô that in this case is immutable. Consider, for example, Arc<T>:\n\n\nuse std::sync::Arc;\n\nlet x = Arc::new(5);\nlet y = x.clone();\n\nWhen we call clone(), the Arc<T> needs to update the reference count. Yet we‚Äôve not used any muts here, x is an immutable binding, and we didn‚Äôt take &mut 5 or anything. So what gives?\n\nTo understand this, we have to go back to the core of Rust‚Äôs guiding philosophy, memory safety, and the mechanism by which Rust guarantees it, the ownership system, and more specifically, borrowing:\n\nYou may have one or the other of these two kinds of borrows, but not both at the same time:\n\none or more references (&T) to a resource,\nexactly one mutable reference (&mut T).\n\nSo, that‚Äôs the real definition of ‚Äòimmutability‚Äô: is this safe to have two pointers to? In Arc<T>‚Äôs case, yes: the mutation is entirely contained inside the structure itself. It‚Äôs not user facing. For this reason, it hands out &T with clone(). If it handed out &mut Ts, though, that would be a problem.\n\nOther types, like the ones in the std::cell module, have the opposite: interior mutability. For example:\n\n\nuse std::cell::RefCell;\n\nlet x = RefCell::new(42);\n\nlet y = x.borrow_mut();\n\nRefCell hands out &mut references to what‚Äôs inside of it with the borrow_mut() method. Isn‚Äôt that dangerous? What if we do:\n\nuse std::cell::RefCell;\n\nlet x = RefCell::new(42);\n\nlet y = x.borrow_mut();\nlet z = x.borrow_mut();\n\n\nThis will in fact panic, at runtime. This is what RefCell does: it enforces Rust‚Äôs borrowing rules at runtime, and panic!s if they‚Äôre violated. This allows us to get around another aspect of Rust‚Äôs mutability rules. Let‚Äôs talk about it first.\n\nField-level mutability\n\nMutability is a property of either a borrow (&mut) or a binding (let mut). This means that, for example, you cannot have a struct with some fields mutable and some immutable:\n\nstruct Point {\n    x: i32,\n    mut y: i32, // Nope.\n}\n\n\nThe mutability of a struct is in its binding:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet mut a = Point { x: 5, y: 6 };\n\na.x = 10;\n\nlet b = Point { x: 5, y: 6 };\n\nb.x = 10; // Error: cannot assign to immutable field `b.x`.\n\n\nHowever, by using Cell<T>, you can emulate field-level mutability:\n\n\nuse std::cell::Cell;\n\nstruct Point {\n    x: i32,\n    y: Cell<i32>,\n}\n\nlet point = Point { x: 5, y: Cell::new(6) };\n\npoint.y.set(7);\n\nprintln!(\"y: {:?}\", point.y);\n\nThis will print y: Cell { value: 7 }. We‚Äôve successfully updated y.\n\nStructs\n\nstructs are a way of creating more complex data types. For example, if we were doing calculations involving coordinates in 2D space, we would need both an x and a y value:\n\n\nlet origin_x = 0;\nlet origin_y = 0;\n\nA struct lets us combine these two into a single, unified datatype with x and y as field labels:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let origin = Point { x: 0, y: 0 }; // origin: Point\n\n    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n}\n\n\nThere‚Äôs a lot going on here, so let‚Äôs break it down. We declare a struct with the struct keyword, and then with a name. By convention, structs begin with a capital letter and are camel cased: PointInSpace, not Point_In_Space.\n\nWe can create an instance of our struct via let, as usual, but we use a key: value style syntax to set each field. The order doesn‚Äôt need to be the same as in the original declaration.\n\nFinally, because fields have names, we can access them through dot notation: origin.x.\n\nThe values in structs are immutable by default, like other bindings in Rust. Use mut to make them mutable:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    point.x = 5;\n\n    println!(\"The point is at ({}, {})\", point.x, point.y);\n}\n\n\nThis will print The point is at (5, 0).\n\nRust does not support field mutability at the language level, so you cannot write something like this:\n\nstruct Point {\n    mut x: i32, // This causes an error.\n    y: i32,\n}\n\n\nMutability is a property of the binding, not of the structure itself. If you‚Äôre used to field-level mutability, this may seem strange at first, but it significantly simplifies things. It even lets you make things mutable on a temporary basis:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    point.x = 5;\n\n    let point = point; // `point` is now immutable.\n\n    point.y = 6; // This causes an error.\n}\n\n\nYour structure can still contain &mut references, which will let you do some kinds of mutation:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nstruct PointRef<'a> {\n    x: &'a mut i32,\n    y: &'a mut i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    {\n        let r = PointRef { x: &mut point.x, y: &mut point.y };\n\n        *r.x = 5;\n        *r.y = 6;\n    }\n\n    assert_eq!(5, point.x);\n    assert_eq!(6, point.y);\n}\n\n\nInitialization of a data structure (struct, enum, union) can be simplified when fields of the data structure are initialized with variables of the same names as the fields.\n\n#[derive(Debug)]\nstruct Person<'a> {\n    name: &'a str,\n    age: u8\n}\n\nfn main() {\n    // Create struct with field init shorthand\n    let name = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n\n    // Debug-print struct\n    println!(\"{:?}\", peter);\n}\n\nUpdate syntax\n\nA struct can include .. to indicate that you want to use a copy of some other struct for some of the values. For example:\n\n\nstruct Point3d {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet mut point = Point3d { x: 0, y: 0, z: 0 };\npoint = Point3d { y: 1, .. point };\n\nThis gives point a new y, but keeps the old x and z values. It doesn‚Äôt have to be the same struct either, you can use this syntax when making new ones, and it will copy the values you don‚Äôt specify:\n\n\nlet origin = Point3d { x: 0, y: 0, z: 0 };\nlet point = Point3d { z: 1, x: 2, .. origin };\nTuple structs\n\nRust has another data type that‚Äôs like a hybrid between a tuple and a struct, called a ‚Äòtuple struct‚Äô. Tuple structs have a name, but their fields don't. They are declared with the struct keyword, and then with a name followed by a tuple:\n\n\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n\nHere, black and origin are not the same type, even though they contain the same values.\n\nThe members of a tuple struct may be accessed by dot notation or destructuring let, just like regular tuples:\n\n\nlet black_r = black.0;\nlet Point(_, origin_y, origin_z) = origin;\n\nPatterns like Point(_, origin_y, origin_z) are also used in match expressions.\n\nOne case when a tuple struct is very useful is when it has only one element. We call this the ‚Äònewtype‚Äô pattern, because it allows you to create a new type that is distinct from its contained value and also expresses its own semantic meaning:\n\n\nstruct Inches(i32);\n\nlet length = Inches(10);\n\nlet Inches(integer_length) = length;\nprintln!(\"length is {} inches\", integer_length);\n\nAs above, you can extract the inner integer type through a destructuring let. In this case, the let Inches(integer_length) assigns 10 to integer_length. We could have used dot notation to do the same thing:\n\n\nlet integer_length = length.0;\n\nIt's always possible to use a struct instead of a tuple struct, and can be clearer. We could write Color and Point like this instead:\n\n\nstruct Color {\n    red: i32,\n    blue: i32,\n    green: i32,\n}\n\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nGood names are important, and while values in a tuple struct can be referenced with dot notation as well, a struct gives us actual names, rather than positions.\n\nUnit-like structs\n\nYou can define a struct with no members at all:\n\nstruct Electron {} // Use empty braces...\nstruct Proton;     // ...or just a semicolon.\n\n// Use the same notation when creating an instance.\nlet x = Electron {};\nlet y = Proton;\nlet z = Electron; // Error\n\n\nSuch a struct is called ‚Äòunit-like‚Äô because it resembles the empty tuple, (), sometimes called ‚Äòunit‚Äô. Like a tuple struct, it defines a new type.\n\nThis is rarely useful on its own (although sometimes it can serve as a marker type), but in combination with other features, it can become useful. For instance, a library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct.\n\nEnums\n\nAn enum in Rust is a type that represents data that is one of several possible variants. Each variant in the enum can optionally have data associated with it:\n\n\nenum Message {\n    Quit,\n    ChangeColor(i32, i32, i32),\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n\nThe syntax for defining variants resembles the syntaxes used to define structs: you can have variants with no data (like unit-like structs), variants with named data, and variants with unnamed data (like tuple structs). Unlike separate struct definitions, however, an enum is a single type. A value of the enum can match any of the variants. For this reason, an enum is sometimes called a ‚Äòsum type‚Äô: the set of possible values of the enum is the sum of the sets of possible values for each variant.\n\nWe use the :: syntax to use the name of each variant: they‚Äôre scoped by the name of the enum itself. This allows both of these to work:\n\n\nlet x: Message = Message::Move { x: 3, y: 4 };\n\nenum BoardGameTurn {\n    Move { squares: i32 },\n    Pass,\n}\n\nlet y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };\n\nBoth variants are named Move, but since they‚Äôre scoped to the name of the enum, they can both be used without conflict.\n\nA value of an enum type contains information about which variant it is, in addition to any data associated with that variant. This is sometimes referred to as a ‚Äòtagged union‚Äô, since the data includes a ‚Äòtag‚Äô indicating what type it is. The compiler uses this information to enforce that you‚Äôre accessing the data in the enum safely. For instance, you can‚Äôt simply try to destructure a value as if it were one of the possible variants:\n\nfn process_color_change(msg: Message) {\n    let Message::ChangeColor(r, g, b) = msg; // This causes a compile-time error.\n}\n\n\nNot supporting these operations may seem rather limiting, but it‚Äôs a limitation which we can overcome. There are two ways: by implementing equality ourselves, or by pattern matching variants with match expressions, which you‚Äôll learn in the next section. We don‚Äôt know enough about Rust to implement equality yet, but we‚Äôll find out in the traits section.\n\nConstructors as functions\n\nAn enum constructor can also be used like a function. For example:\n\n\nlet m = Message::Write(\"Hello, world\".to_string());\n\nis the same as\n\n\nfn foo(x: String) -> Message {\n    Message::Write(x)\n}\n\nlet x = foo(\"Hello, world\".to_string());\n\nThis is not immediately useful to us, but when we get to closures, we‚Äôll talk about passing functions as arguments to other functions. For example, with iterators, we can do this to convert a vector of Strings into a vector of Message::Writes:\n\n\n\nlet v = vec![\"Hello\".to_string(), \"World\".to_string()];\n\nlet v1: Vec<Message> = v.into_iter().map(Message::Write).collect();\nMatch\n\nOften, a simple if/else isn‚Äôt enough, because you have more than two possible options. Also, conditions can get quite complex. Rust has a keyword, match, that allows you to replace complicated if/else groupings with something more powerful. Check it out:\n\n\nlet x = 5;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    4 => println!(\"four\"),\n    5 => println!(\"five\"),\n    _ => println!(\"something else\"),\n}\n\nmatch takes an expression and then branches based on its value. Each ‚Äòarm‚Äô of the branch is of the form val => expression. When the value matches, that arm‚Äôs expression will be evaluated. It‚Äôs called match because of the term ‚Äòpattern matching‚Äô, which match is an implementation of. There‚Äôs a separate section on patterns that covers all the patterns that are possible here.\n\nOne of the many advantages of match is it enforces ‚Äòexhaustiveness checking‚Äô. For example if we remove the last arm with the underscore _, the compiler will give us an error:\n\nerror: non-exhaustive patterns: `_` not covered\n\n\nRust is telling us that we forgot some value. The compiler infers from x that it can have any 32bit integer value; for example -2,147,483,648 to 2,147,483,647. The _ acts as a 'catch-all', and will catch all possible values that aren't specified in an arm of match. As you can see in the previous example, we provide match arms for integers 1-5, if x is 6 or any other value, then it is caught by _.\n\nmatch is also an expression, which means we can use it on the right-hand side of a let binding or directly where an expression is used:\n\n\nlet x = 5;\n\nlet number = match x {\n    1 => \"one\",\n    2 => \"two\",\n    3 => \"three\",\n    4 => \"four\",\n    5 => \"five\",\n    _ => \"something else\",\n};\n\nSometimes it‚Äôs a nice way of converting something from one type to another; in this example the integers are converted to String.\n\nMatching on enums\n\nAnother important use of the match keyword is to process the possible variants of an enum:\n\n\nenum Message {\n    Quit,\n    ChangeColor(i32, i32, i32),\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n\nfn quit() { /* ... */ }\nfn change_color(r: i32, g: i32, b: i32) { /* ... */ }\nfn move_cursor(x: i32, y: i32) { /* ... */ }\n\nfn process_message(msg: Message) {\n    match msg {\n        Message::Quit => quit(),\n        Message::ChangeColor(r, g, b) => change_color(r, g, b),\n        Message::Move { x, y: new_name_for_y } => move_cursor(x, new_name_for_y),\n        Message::Write(s) => println!(\"{}\", s),\n    };\n}\n\nAgain, the Rust compiler checks exhaustiveness, so it demands that you have a match arm for every variant of the enum. If you leave one off, it will give you a compile-time error unless you use _ or provide all possible arms.\n\nUnlike the previous uses of match, you can‚Äôt use the normal if statement to do this. You can use the if let statement, which can be seen as an abbreviated form of match.\n\nPatterns\n\nPatterns are quite common in Rust. We use them in variable bindings, match expressions, and other places, too. Let‚Äôs go on a whirlwind tour of all of the things patterns can do!\n\nA quick refresher: you can match against literals directly, and _ acts as an ‚Äòany‚Äô case:\n\n\nlet x = 1;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n\nThis prints one.\n\nIt's possible to create a binding for the value in the any case:\n\n\nlet x = 1;\n\nmatch x {\n    y => println!(\"x: {} y: {}\", x, y),\n}\n\nThis prints:\n\nx: 1 y: 1\n\n\nNote it is an error to have both a catch-all _ and a catch-all binding in the same match block:\n\n\nlet x = 1;\n\nmatch x {\n    y => println!(\"x: {} y: {}\", x, y),\n    _ => println!(\"anything\"), // this causes an error as it is unreachable\n}\n\nThere‚Äôs one pitfall with patterns: like anything that introduces a new binding, they introduce shadowing. For example:\n\n\nlet x = 1;\nlet c = 'c';\n\nmatch c {\n    x => println!(\"x: {} c: {}\", x, c),\n}\n\nprintln!(\"x: {}\", x)\n\nThis prints:\n\nx: c c: c\nx: 1\n\n\nIn other words, x => matches the pattern and introduces a new binding named x. This new binding is in scope for the match arm and takes on the value of c. Notice that the value of x outside the scope of the match has no bearing on the value of x within it. Because we already have a binding named x, this new x shadows it.\n\nMultiple patterns\n\nYou can match multiple patterns with |:\n\n\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n\nThis prints one or two.\n\nDestructuring\n\nIf you have a compound data type, like a struct, you can destructure it inside of a pattern:\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet origin = Point { x: 0, y: 0 };\n\nmatch origin {\n    Point { x, y } => println!(\"({},{})\", x, y),\n}\n\nWe can use : to give a value a different name.\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet origin = Point { x: 0, y: 0 };\n\nmatch origin {\n    Point { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n}\n\nIf we only care about some of the values, we don‚Äôt have to give them all names:\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet point = Point { x: 2, y: 3 };\n\nmatch point {\n    Point { x, .. } => println!(\"x is {}\", x),\n}\n\nThis prints x is 2.\n\nYou can do this kind of match on any member, not only the first:\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet point = Point { x: 2, y: 3 };\n\nmatch point {\n    Point { y, .. } => println!(\"y is {}\", y),\n}\n\nThis prints y is 3.\n\nThis ‚Äòdestructuring‚Äô behavior works on any compound data type, like tuples or enums.\n\nIgnoring bindings\n\nYou can use _ in a pattern to disregard the type and value. For example, here‚Äôs a match against a Result<T, E>:\n\n\nmatch some_value {\n    Ok(value) => println!(\"got a value: {}\", value),\n    Err(_) => println!(\"an error occurred\"),\n}\n\nIn the first arm, we bind the value inside the Ok variant to value. But in the Err arm, we use _ to disregard the specific error, and print a general error message.\n\n_ is valid in any pattern that creates a binding. This can be useful to ignore parts of a larger structure:\n\n\nfn coordinate() -> (i32, i32, i32) {\n    // Generate and return some sort of triple tuple.\n}\n\nlet (x, _, z) = coordinate();\n\nHere, we bind the first and last element of the tuple to x and z, but ignore the middle element.\n\nIt‚Äôs worth noting that using _ never binds the value in the first place, which means that the value does not move:\n\n\nlet tuple: (u32, String) = (5, String::from(\"five\"));\n\n// Here, tuple is moved, because the String moved:\nlet (x, _s) = tuple;\n\n// The next line would give \"error: use of partially moved value: `tuple`\".\n// println!(\"Tuple is: {:?}\", tuple);\n\n// However,\n\nlet tuple = (5, String::from(\"five\"));\n\n// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:\nlet (x, _) = tuple;\n\n// That means this works:\nprintln!(\"Tuple is: {:?}\", tuple);\n\nThis also means that any temporary variables will be dropped at the end of the statement:\n\n\n// Here, the String created will be dropped immediately, as it‚Äôs not bound:\n\nlet _ = String::from(\"  hello  \").trim();\n\nYou can also use .. in a pattern to disregard multiple values:\n\n\nenum OptionalTuple {\n    Value(i32, i32, i32),\n    Missing,\n}\n\nlet x = OptionalTuple::Value(5, -2, 3);\n\nmatch x {\n    OptionalTuple::Value(..) => println!(\"Got a tuple!\"),\n    OptionalTuple::Missing => println!(\"No such luck.\"),\n}\n\nThis prints Got a tuple!.\n\nref and ref mut\n\nIf you want to get a reference, use the ref keyword:\n\n\nlet x = 5;\n\nmatch x {\n    ref r => println!(\"Got a reference to {}\", r),\n}\n\nThis prints Got a reference to 5.\n\nHere, the r inside the match has the type &i32. In other words, the ref keyword creates a reference, for use in the pattern. If you need a mutable reference, ref mut will work in the same way:\n\n\nlet mut x = 5;\n\nmatch x {\n    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n}\nRanges\n\nYou can match a range of values with ...:\n\n\nlet x = 1;\n\nmatch x {\n    1 ... 5 => println!(\"one through five\"),\n    _ => println!(\"anything\"),\n}\n\nThis prints one through five.\n\nRanges are mostly used with integers and chars:\n\n\nlet x = 'üíÖ';\n\nmatch x {\n    'a' ... 'j' => println!(\"early letter\"),\n    'k' ... 'z' => println!(\"late letter\"),\n    _ => println!(\"something else\"),\n}\n\nThis prints something else.\n\nBindings\n\nYou can bind values to names with @:\n\n\nlet x = 1;\n\nmatch x {\n    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n    _ => println!(\"anything\"),\n}\n\nThis prints got a range element 1. This is useful when you want to do a complicated match of part of a data structure:\n\n\n#[derive(Debug)]\nstruct Person {\n    name: Option<String>,\n}\n\nlet name = \"Steve\".to_string();\nlet x: Option<Person> = Some(Person { name: Some(name) });\nmatch x {\n    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n    _ => {}\n}\n\nThis prints Some(\"Steve\"): we‚Äôve bound the inner name to a.\n\nIf you use @ with |, you need to make sure the name is bound in each part of the pattern:\n\n\nlet x = 5;\n\nmatch x {\n    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n    _ => println!(\"anything\"),\n}\nGuards\n\nYou can introduce ‚Äòmatch guards‚Äô with if:\n\n\nenum OptionalInt {\n    Value(i32),\n    Missing,\n}\n\nlet x = OptionalInt::Value(5);\n\nmatch x {\n    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n    OptionalInt::Value(..) => println!(\"Got an int!\"),\n    OptionalInt::Missing => println!(\"No such luck.\"),\n}\n\nThis prints Got an int!.\n\nIf you‚Äôre using if with multiple patterns, the if applies to both sides:\n\n\nlet x = 4;\nlet y = false;\n\nmatch x {\n    4 | 5 if y => println!(\"yes\"),\n    _ => println!(\"no\"),\n}\n\nThis prints no, because the if applies to the whole of 4 | 5, and not to only the 5. In other words, the precedence of if behaves like this:\n\n(4 | 5) if y => ...\n\n\nnot this:\n\n4 | (5 if y) => ...\n\nMix and Match\n\nWhew! That‚Äôs a lot of different ways to match things, and they can all be mixed and matched, depending on what you‚Äôre doing:\n\nmatch x {\n    Foo { x: Some(ref name), y: None } => ...\n}\n\n\nPatterns are very powerful. Make good use of them.\n\nMethod Syntax\n\nFunctions are great, but if you want to call a bunch of them on some data, it can be awkward. Consider this code:\n\nbaz(bar(foo));\n\n\nWe would read this left-to-right, and so we see ‚Äòbaz bar foo‚Äô. But this isn‚Äôt the order that the functions would get called in, that‚Äôs inside-out: ‚Äòfoo bar baz‚Äô. Wouldn‚Äôt it be nice if we could do this instead?\n\nfoo.bar().baz();\n\n\nLuckily, as you may have guessed with the leading question, you can! Rust provides the ability to use this ‚Äòmethod call syntax‚Äô via the impl keyword.\n\nMethod calls\n\nHere‚Äôs how it works:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nfn main() {\n    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n    println!(\"{}\", c.area());\n}\n\n\nThis will print 12.566371.\n\nWe‚Äôve made a struct that represents a circle. We then write an impl block, and inside it, define a method, area.\n\nMethods take a special first parameter, of which there are three variants: self, &self, and &mut self. You can think of this first parameter as being the foo in foo.bar(). The three variants correspond to the three kinds of things foo could be: self if it‚Äôs a value on the stack, &self if it‚Äôs a reference, and &mut self if it‚Äôs a mutable reference. Because we took the &self parameter to area, we can use it like any other parameter. Because we know it‚Äôs a Circle, we can access the radius like we would with any other struct.\n\nWe should default to using &self, as you should prefer borrowing over taking ownership, as well as taking immutable references over mutable ones. Here‚Äôs an example of all three variants:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn reference(&self) {\n       println!(\"taking self by reference!\");\n    }\n\n    fn mutable_reference(&mut self) {\n       println!(\"taking self by mutable reference!\");\n    }\n\n    fn takes_ownership(self) {\n       println!(\"taking ownership of self!\");\n    }\n}\n\nYou can use as many impl blocks as you‚Äôd like. The previous example could have also been written like this:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn reference(&self) {\n       println!(\"taking self by reference!\");\n    }\n}\n\nimpl Circle {\n    fn mutable_reference(&mut self) {\n       println!(\"taking self by mutable reference!\");\n    }\n}\n\nimpl Circle {\n    fn takes_ownership(self) {\n       println!(\"taking ownership of self!\");\n    }\n}\nChaining method calls\n\nSo, now we know how to call a method, such as foo.bar(). But what about our original example, foo.bar().baz()? This is called ‚Äòmethod chaining‚Äô. Let‚Äôs look at an example:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n\n    fn grow(&self, increment: f64) -> Circle {\n        Circle { x: self.x, y: self.y, radius: self.radius + increment }\n    }\n}\n\nfn main() {\n    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n    println!(\"{}\", c.area());\n\n    let d = c.grow(2.0).area();\n    println!(\"{}\", d);\n}\n\n\nCheck the return type:\n\n\nfn grow(&self, increment: f64) -> Circle {\n\nWe say we‚Äôre returning a Circle. With this method, we can grow a new Circle to any arbitrary size.\n\nAssociated functions\n\nYou can also define associated functions that do not take a self parameter. Here‚Äôs a pattern that‚Äôs very common in Rust code:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn new(x: f64, y: f64, radius: f64) -> Circle {\n        Circle {\n            x: x,\n            y: y,\n            radius: radius,\n        }\n    }\n}\n\nfn main() {\n    let c = Circle::new(0.0, 0.0, 2.0);\n}\n\n\nThis ‚Äòassociated function‚Äô builds a new Circle for us. Note that associated functions are called with the Struct::function() syntax, rather than the ref.method() syntax. Some other languages call associated functions ‚Äòstatic methods‚Äô.\n\nBuilder Pattern\n\nLet‚Äôs say that we want our users to be able to create Circles, but we will allow them to only set the properties they care about. Otherwise, the x and y attributes will be 0.0, and the radius will be 1.0. Rust doesn‚Äôt have method overloading, named arguments, or variable arguments. We employ the builder pattern instead. It looks like this:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nstruct CircleBuilder {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl CircleBuilder {\n    fn new() -> CircleBuilder {\n        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }\n    }\n\n    fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {\n        self.x = coordinate;\n        self\n    }\n\n    fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {\n        self.y = coordinate;\n        self\n    }\n\n    fn radius(&mut self, radius: f64) -> &mut CircleBuilder {\n        self.radius = radius;\n        self\n    }\n\n    fn finalize(&self) -> Circle {\n        Circle { x: self.x, y: self.y, radius: self.radius }\n    }\n}\n\nfn main() {\n    let c = CircleBuilder::new()\n                .x(1.0)\n                .y(2.0)\n                .radius(2.0)\n                .finalize();\n\n    println!(\"area: {}\", c.area());\n    println!(\"x: {}\", c.x);\n    println!(\"y: {}\", c.y);\n}\n\n\nWhat we‚Äôve done here is make another struct, CircleBuilder. We‚Äôve defined our builder methods on it. We‚Äôve also defined our area() method on Circle. We also made one more method on CircleBuilder: finalize(). This method creates our final Circle from the builder. Now, we‚Äôve used the type system to enforce our concerns: we can use the methods on CircleBuilder to constrain making Circles in any way we choose.\n\nStrings\n\nStrings are an important concept for any programmer to master. Rust‚Äôs string handling system is a bit different from other languages, due to its systems focus. Any time you have a data structure of variable size, things can get tricky, and strings are a re-sizable data structure. That being said, Rust‚Äôs strings also work differently than in some other systems languages, such as C.\n\nLet‚Äôs dig into the details. A ‚Äòstring‚Äô is a sequence of Unicode scalar values encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid encoding of UTF-8 sequences. Additionally, unlike some systems languages, strings are not NUL-terminated and can contain NUL bytes.\n\nRust has two main types of strings: &str and String. Let‚Äôs talk about &str first. These are called ‚Äòstring slices‚Äô. A string slice has a fixed size, and cannot be mutated. It is a reference to a sequence of UTF-8 bytes.\n\n\nlet greeting = \"Hello there.\"; // greeting: &'static str\n\n\"Hello there.\" is a string literal and its type is &'static str. A string literal is a string slice that is statically allocated, meaning that it‚Äôs saved inside our compiled program, and exists for the entire duration it runs. The greeting binding is a reference to this statically allocated string. Any function expecting a string slice will also accept a string literal.\n\nString literals can span multiple lines. There are two forms. The first will include the newline and the leading spaces:\n\n\nlet s = \"foo\n    bar\";\n\nassert_eq!(\"foo\\n    bar\", s);\n\nThe second, with a \\, trims the spaces and the newline:\n\n\nlet s = \"foo\\\n    bar\";\n\nassert_eq!(\"foobar\", s);\n\nNote that you normally cannot access a str directly, but only through a &str reference. This is because str is an unsized type which requires additional runtime information to be usable. For more information see the chapter on unsized types.\n\nRust has more than only &strs though. A String is a heap-allocated string. This string is growable, and is also guaranteed to be UTF-8. Strings are commonly created by converting from a string slice using the to_string method.\n\n\nlet mut s = \"Hello\".to_string(); // mut s: String\nprintln!(\"{}\", s);\n\ns.push_str(\", world.\");\nprintln!(\"{}\", s);\n\nStrings will coerce into &str with an &:\n\nfn takes_slice(slice: &str) {\n    println!(\"Got: {}\", slice);\n}\n\nfn main() {\n    let s = \"Hello\".to_string();\n    takes_slice(&s);\n}\n\n\nThis coercion does not happen for functions that accept one of &str‚Äôs traits instead of &str. For example, TcpStream::connect has a parameter of type ToSocketAddrs. A &str is okay but a String must be explicitly converted using &*.\n\n\nuse std::net::TcpStream;\n\nTcpStream::connect(\"192.168.0.1:3000\"); // Parameter is of type &str.\n\nlet addr_string = \"192.168.0.1:3000\".to_string();\nTcpStream::connect(&*addr_string); // Convert `addr_string` to &str.\n\nViewing a String as a &str is cheap, but converting the &str to a String involves allocating memory. No reason to do that unless you have to!\n\nIndexing\n\nBecause strings are valid UTF-8, they do not support indexing:\n\nlet s = \"hello\";\n\nprintln!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n\n\nUsually, access to a vector with [] is very fast. But, because each character in a UTF-8 encoded string can be multiple bytes, you have to walk over the string to find the n·µó ∞ letter of a string. This is a significantly more expensive operation, and we don‚Äôt want to be misleading. Furthermore, ‚Äòletter‚Äô isn‚Äôt something defined in Unicode, exactly. We can choose to look at a string as individual bytes, or as codepoints:\n\n\nlet hachiko = \"Âø†Áä¨„Éè„ÉÅÂÖ¨\";\n\nfor b in hachiko.as_bytes() {\n    print!(\"{}, \", b);\n}\n\nprintln!(\"\");\n\nfor c in hachiko.chars() {\n    print!(\"{}, \", c);\n}\n\nprintln!(\"\");\n\nThis prints:\n\n229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,\nÂø†, Áä¨, „Éè, „ÉÅ, ÂÖ¨,\n\n\nAs you can see, there are more bytes than chars.\n\nYou can get something similar to an index like this:\n\n\nlet dog = hachiko.chars().nth(1); // Kinda like `hachiko[1]`.\n\nThis emphasizes that we have to walk from the beginning of the list of chars.\n\nSlicing\n\nYou can get a slice of a string with the slicing syntax:\n\n\nlet dog = \"hachiko\";\nlet hachi = &dog[0..5];\n\nBut note that these are byte offsets, not character offsets. So this will fail at runtime:\n\n\nlet dog = \"Âø†Áä¨„Éè„ÉÅÂÖ¨\";\nlet hachi = &dog[0..2];\n\nwith this error:\n\nthread 'main' panicked at 'byte index 2 is not a char boundary; it is inside 'Âø†'\n(bytes 0..3) of `Âø†Áä¨„Éè„ÉÅÂÖ¨`'\n\nConcatenation\n\nIf you have a String, you can concatenate a &str to the end of it:\n\n\nlet hello = \"Hello \".to_string();\nlet world = \"world!\";\n\nlet hello_world = hello + world;\n\nBut if you have two Strings, you need an &:\n\n\nlet hello = \"Hello \".to_string();\nlet world = \"world!\".to_string();\n\nlet hello_world = hello + &world;\n\nThis is because &String can automatically coerce to a &str. This is a feature called ‚ÄòDeref coercions‚Äô.\n\nGenerics\n\nSometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics. Generics are called ‚Äòparametric polymorphism‚Äô in type theory, which means that they are types or functions that have multiple forms (‚Äòpoly‚Äô is multiple, ‚Äòmorph‚Äô is form) over a given parameter (‚Äòparametric‚Äô).\n\nAnyway, enough type theory, let‚Äôs check out some generic code. Rust‚Äôs standard library provides a type, Option<T>, that‚Äôs generic:\n\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nThe <T> part, which you‚Äôve seen a few times before, indicates that this is a generic data type. Inside the declaration of our enum, wherever we see a T, we substitute that type for the same type used in the generic. Here‚Äôs an example of using Option<T>, with some extra type annotations:\n\n\nlet x: Option<i32> = Some(5);\n\nIn the type declaration, we say Option<i32>. Note how similar this looks to Option<T>. So, in this particular Option, T has the value of i32. On the right-hand side of the binding, we make a Some(T), where T is 5. Since that‚Äôs an i32, the two sides match, and Rust is happy. If they didn‚Äôt match, we‚Äôd get an error:\n\nlet x: Option<f64> = Some(5);\n// error: mismatched types: expected `core::option::Option<f64>`,\n// found `core::option::Option<_>` (expected f64 but found integral variable)\n\n\nThat doesn‚Äôt mean we can‚Äôt make Option<T>s that hold an f64! They have to match up:\n\n\nlet x: Option<i32> = Some(5);\nlet y: Option<f64> = Some(5.0f64);\n\nThis is just fine. One definition, multiple uses.\n\nGenerics don‚Äôt have to only be generic over one type. Consider another type from Rust‚Äôs standard library that‚Äôs similar, Result<T, E>:\n\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nThis type is generic over two types: T and E. By the way, the capital letters can be any letter you‚Äôd like. We could define Result<T, E> as:\n\n\nenum Result<A, Z> {\n    Ok(A),\n    Err(Z),\n}\n\nif we wanted to. Convention says that the first generic parameter should be T, for ‚Äòtype‚Äô, and that we use E for ‚Äòerror‚Äô. Rust doesn‚Äôt care, however.\n\nThe Result<T, E> type is intended to be used to return the result of a computation, and to have the ability to return an error if it didn‚Äôt work out.\n\nGeneric functions\n\nWe can write functions that take generic types with a similar syntax:\n\n\nfn takes_anything<T>(x: T) {\n    // Do something with `x`.\n}\n\nThe syntax has two parts: the <T> says ‚Äúthis function is generic over one type, T‚Äù, and the x: T says ‚Äúx has the type T.‚Äù\n\nMultiple arguments can have the same generic type:\n\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) {\n    // ...\n}\n\nWe could write a version that takes multiple types:\n\n\nfn takes_two_things<T, U>(x: T, y: U) {\n    // ...\n}\nGeneric structs\n\nYou can store a generic type in a struct as well:\n\n\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nlet int_origin = Point { x: 0, y: 0 };\nlet float_origin = Point { x: 0.0, y: 0.0 };\n\nSimilar to functions, the <T> is where we declare the generic parameters, and we then use x: T in the type declaration, too.\n\nWhen you want to add an implementation for the generic struct, you declare the type parameter after the impl:\n\n\nimpl<T> Point<T> {\n    fn swap(&mut self) {\n        std::mem::swap(&mut self.x, &mut self.y);\n    }\n}\n\nSo far you‚Äôve seen generics that take absolutely any type. These are useful in many cases: you‚Äôve already seen Option<T>, and later you‚Äôll meet universal container types like Vec<T>. On the other hand, often you want to trade that flexibility for increased expressive power. Read about trait bounds to see why and how.\n\nResolving ambiguities\n\nMost of the time when generics are involved, the compiler can infer the generic parameters automatically:\n\n\n// v must be a Vec<T> but we don't know what T is yet\nlet mut v = Vec::new();\n// v just got a bool value, so T must be bool!\nv.push(true);\n// Debug-print v\nprintln!(\"{:?}\", v);\n\nSometimes though, the compiler needs a little help. For example, had we omitted the last line, we would get a compile error:\n\nlet v = Vec::new();\n//      ^^^^^^^^ cannot infer type for `T`\n//\n// note: type annotations or generic parameter binding required\nprintln!(\"{:?}\", v);\n\n\nWe can solve this using either a type annotation:\n\n\nlet v: Vec<bool> = Vec::new();\nprintln!(\"{:?}\", v);\n\nor by binding the generic parameter T via the so-called ‚Äòturbofish‚Äô ::<> syntax:\n\n\nlet v = Vec::<bool>::new();\nprintln!(\"{:?}\", v);\n\nThe second approach is useful in situations where we don‚Äôt want to bind the result to a variable. It can also be used to bind generic parameters in functions or methods. See Iterators ¬ß Consumers for an example.\n\nTraits\n\nA trait is a language feature that tells the Rust compiler about functionality a type must provide.\n\nRecall the impl keyword, used to call a function with method syntax:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nTraits are similar, except that we first define a trait with a method signature, then implement the trait for a type. In this example, we implement the trait HasArea for Circle:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\ntrait HasArea {\n    fn area(&self) -> f64;\n}\n\nimpl HasArea for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nAs you can see, the trait block looks very similar to the impl block, but we don‚Äôt define a body, only a type signature. When we impl a trait, we use impl Trait for Item, rather than only impl Item.\n\nSelf may be used in a type annotation to refer to an instance of the type implementing this trait passed as a parameter. Self, &Self or &mut Self may be used depending on the level of ownership required.\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\ntrait HasArea {\n    fn area(&self) -> f64;\n\n    fn is_larger(&self, &Self) -> bool;\n}\n\nimpl HasArea for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n\n    fn is_larger(&self, other: &Self) -> bool {\n        self.area() > other.area()\n    }\n}\nTrait bounds on generic functions\n\nTraits are useful because they allow a type to make certain promises about its behavior. Generic functions can exploit this to constrain, or bound, the types they accept. Consider this function, which does not compile:\n\nfn print_area<T>(shape: T) {\n    println!(\"This shape has an area of {}\", shape.area());\n}\n\n\nRust complains:\n\nerror: no method named `area` found for type `T` in the current scope\n\n\nBecause T can be any type, we can‚Äôt be sure that it implements the area method. But we can add a trait bound to our generic T, ensuring that it does:\n\n\nfn print_area<T: HasArea>(shape: T) {\n    println!(\"This shape has an area of {}\", shape.area());\n}\n\nThe syntax <T: HasArea> means ‚Äúany type that implements the HasArea trait.‚Äù Because traits define function type signatures, we can be sure that any type which implements HasArea will have an .area() method.\n\nHere‚Äôs an extended example of how this works:\n\ntrait HasArea {\n    fn area(&self) -> f64;\n}\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl HasArea for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nstruct Square {\n    x: f64,\n    y: f64,\n    side: f64,\n}\n\nimpl HasArea for Square {\n    fn area(&self) -> f64 {\n        self.side * self.side\n    }\n}\n\nfn print_area<T: HasArea>(shape: T) {\n    println!(\"This shape has an area of {}\", shape.area());\n}\n\nfn main() {\n    let c = Circle {\n        x: 0.0f64,\n        y: 0.0f64,\n        radius: 1.0f64,\n    };\n\n    let s = Square {\n        x: 0.0f64,\n        y: 0.0f64,\n        side: 1.0f64,\n    };\n\n    print_area(c);\n    print_area(s);\n}\n\n\nThis program outputs:\n\nThis shape has an area of 3.141593\nThis shape has an area of 1\n\n\nAs you can see, print_area is now generic, but also ensures that we have passed in the correct types. If we pass in an incorrect type:\n\nprint_area(5);\n\n\nWe get a compile-time error:\n\nerror: the trait bound `_ : HasArea` is not satisfied [E0277]\n\nTrait bounds on generic structs\n\nYour generic structs can also benefit from trait bounds. All you need to do is append the bound when you declare type parameters. Here is a new type Rectangle<T> and its operation is_square():\n\nstruct Rectangle<T> {\n    x: T,\n    y: T,\n    width: T,\n    height: T,\n}\n\nimpl<T: PartialEq> Rectangle<T> {\n    fn is_square(&self) -> bool {\n        self.width == self.height\n    }\n}\n\nfn main() {\n    let mut r = Rectangle {\n        x: 0,\n        y: 0,\n        width: 47,\n        height: 47,\n    };\n\n    assert!(r.is_square());\n\n    r.height = 42;\n    assert!(!r.is_square());\n}\n\n\nis_square() needs to check that the sides are equal, so the sides must be of a type that implements the core::cmp::PartialEq trait:\n\nimpl<T: PartialEq> Rectangle<T> { ... }\n\n\nNow, a rectangle can be defined in terms of any type that can be compared for equality.\n\nHere we defined a new struct Rectangle that accepts numbers of any precision‚Äîreally, objects of pretty much any type‚Äîas long as they can be compared for equality. Could we do the same for our HasArea structs, Square and Circle? Yes, but they need multiplication, and to work with that we need to know more about operator traits.\n\nRules for implementing traits\n\nSo far, we‚Äôve only added trait implementations to structs, but you can implement a trait for any type such as f32:\n\n\ntrait ApproxEqual {\n    fn approx_equal(&self, other: &Self) -> bool;\n}\nimpl ApproxEqual for f32 {\n    fn approx_equal(&self, other: &Self) -> bool {\n        // Appropriate for `self` and `other` being close to 1.0.\n        (self - other).abs() <= ::std::f32::EPSILON\n    }\n}\n\nprintln!(\"{}\", 1.0.approx_equal(&1.00000001));\n\nThis may seem like the Wild West, but there are two restrictions around implementing traits that prevent this from getting out of hand. The first is that if the trait isn‚Äôt defined in your scope, it doesn‚Äôt apply. Here‚Äôs an example: the standard library provides a Write trait which adds extra functionality to Files, for doing file I/O. By default, a File won‚Äôt have its methods:\n\nlet mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn‚Äôt create foo.txt\");\nlet buf = b\"whatever\"; // buf: &[u8; 8], a byte string literal.\nlet result = f.write(buf);\n\n\nHere‚Äôs the error:\n\nerror: type `std::fs::File` does not implement any method in scope named `write`\nlet result = f.write(buf);\n               ^~~~~~~~~~\n\n\nWe need to use the Write trait first:\n\n\nuse std::io::Write;\n\nlet mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn‚Äôt create foo.txt\");\nlet buf = b\"whatever\";\nlet result = f.write(buf);\n\nThis will compile without error.\n\nThis means that even if someone does something bad like add methods to i32, it won‚Äôt affect you, unless you use that trait.\n\nThere‚Äôs one more restriction on implementing traits: either the trait or the type you‚Äôre implementing it for must be defined by you. Or more precisely, one of them must be defined in the same crate as the impl you're writing. For more on Rust's module and package system, see the chapter on crates and modules.\n\nSo, we could implement the HasArea type for i32, because we defined HasArea in our code. But if we tried to implement ToString, a trait provided by Rust, for i32, we could not, because neither the trait nor the type are defined in our crate.\n\nOne last thing about traits: generic functions with a trait bound use ‚Äòmonomorphization‚Äô (mono: one, morph: form), so they are statically dispatched. What‚Äôs that mean? Check out the chapter on trait objects for more details.\n\nMultiple trait bounds\n\nYou‚Äôve seen that you can bound a generic type parameter with a trait:\n\n\nfn foo<T: Clone>(x: T) {\n    x.clone();\n}\n\nIf you need more than one bound, you can use +:\n\n\nuse std::fmt::Debug;\n\nfn foo<T: Clone + Debug>(x: T) {\n    x.clone();\n    println!(\"{:?}\", x);\n}\n\nT now needs to be both Clone as well as Debug.\n\nWhere clause\n\nWriting functions with only a few generic types and a small number of trait bounds isn‚Äôt too bad, but as the number increases, the syntax gets increasingly awkward:\n\n\nuse std::fmt::Debug;\n\nfn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nThe name of the function is on the far left, and the parameter list is on the far right. The bounds are getting in the way.\n\nRust has a solution, and it‚Äôs called a ‚Äòwhere clause‚Äô:\n\nuse std::fmt::Debug;\n\nfn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nfn bar<T, K>(x: T, y: K) where T: Clone, K: Clone + Debug {\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nfn main() {\n    foo(\"Hello\", \"world\");\n    bar(\"Hello\", \"world\");\n}\n\n\nfoo() uses the syntax we showed earlier, and bar() uses a where clause. All you need to do is leave off the bounds when defining your type parameters, and then add where after the parameter list. For longer lists, whitespace can be added:\n\n\nuse std::fmt::Debug;\n\nfn bar<T, K>(x: T, y: K)\n    where T: Clone,\n          K: Clone + Debug {\n\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nThis flexibility can add clarity in complex situations.\n\nwhere is also more powerful than the simpler syntax. For example:\n\n\ntrait ConvertTo<Output> {\n    fn convert(&self) -> Output;\n}\n\nimpl ConvertTo<i64> for i32 {\n    fn convert(&self) -> i64 { *self as i64 }\n}\n\n// Can be called with T == i32.\nfn convert_t_to_i64<T: ConvertTo<i64>>(x: T) -> i64 {\n    x.convert()\n}\n\n// Can be called with T == i64.\nfn convert_i32_to_t<T>(x: i32) -> T\n        // This is using ConvertTo as if it were \"ConvertTo<i64>\".\n        where i32: ConvertTo<T> {\n    x.convert()\n}\n\nThis shows off the additional feature of where clauses: they allow bounds on the left-hand side not only of type parameters T, but also of types (i32 in this case). In this example, i32 must implement ConvertTo<T>. Rather than defining what i32 is (since that's obvious), the where clause here constrains T.\n\nDefault methods\n\nA default method can be added to a trait definition if it is already known how a typical implementor will define a method. For example, is_invalid() is defined as the opposite of is_valid():\n\n\ntrait Foo {\n    fn is_valid(&self) -> bool;\n\n    fn is_invalid(&self) -> bool { !self.is_valid() }\n}\n\nImplementors of the Foo trait need to implement is_valid() but not is_invalid() due to the added default behavior. This default behavior can still be overridden as in:\n\n\nstruct UseDefault;\n\nimpl Foo for UseDefault {\n    fn is_valid(&self) -> bool {\n        println!(\"Called UseDefault.is_valid.\");\n        true\n    }\n}\n\nstruct OverrideDefault;\n\nimpl Foo for OverrideDefault {\n    fn is_valid(&self) -> bool {\n        println!(\"Called OverrideDefault.is_valid.\");\n        true\n    }\n\n    fn is_invalid(&self) -> bool {\n        println!(\"Called OverrideDefault.is_invalid!\");\n        true // Overrides the expected value of `is_invalid()`.\n    }\n}\n\nlet default = UseDefault;\nassert!(!default.is_invalid()); // Prints \"Called UseDefault.is_valid.\"\n\nlet over = OverrideDefault;\nassert!(over.is_invalid()); // Prints \"Called OverrideDefault.is_invalid!\"\nInheritance\n\nSometimes, implementing a trait requires implementing another trait:\n\n\ntrait Foo {\n    fn foo(&self);\n}\n\ntrait FooBar : Foo {\n    fn foobar(&self);\n}\n\nImplementors of FooBar must also implement Foo, like this:\n\n\nstruct Baz;\n\nimpl Foo for Baz {\n    fn foo(&self) { println!(\"foo\"); }\n}\n\nimpl FooBar for Baz {\n    fn foobar(&self) { println!(\"foobar\"); }\n}\n\nIf we forget to implement Foo, Rust will tell us:\n\nerror: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]\n\nDeriving\n\nImplementing traits like Debug and Default repeatedly can become quite tedious. For that reason, Rust provides an attribute that allows you to let Rust automatically implement traits for you:\n\n#[derive(Debug)]\nstruct Foo;\n\nfn main() {\n    println!(\"{:?}\", Foo);\n}\n\n\nHowever, deriving is limited to a certain set of traits:\n\nClone\nCopy\nDebug\nDefault\nEq\nHash\nOrd\nPartialEq\nPartialOrd\nDrop\n\nNow that we‚Äôve discussed traits, let‚Äôs talk about a particular trait provided by the Rust standard library, Drop. The Drop trait provides a way to run some code when a value goes out of scope. For example:\n\nstruct HasDrop;\n\nimpl Drop for HasDrop {\n    fn drop(&mut self) {\n        println!(\"Dropping!\");\n    }\n}\n\nfn main() {\n    let x = HasDrop;\n\n    // Do stuff.\n\n} // `x` goes out of scope here.\n\n\nWhen x goes out of scope at the end of main(), the code for Drop will run. Drop has one method, which is also called drop(). It takes a mutable reference to self.\n\nThat‚Äôs it! The mechanics of Drop are very simple, but there are some subtleties. For example, values are dropped in the opposite order they are declared. Here‚Äôs another example:\n\nstruct Firework {\n    strength: i32,\n}\n\nimpl Drop for Firework {\n    fn drop(&mut self) {\n        println!(\"BOOM times {}!!!\", self.strength);\n    }\n}\n\nfn main() {\n    let firecracker = Firework { strength: 1 };\n    let tnt = Firework { strength: 100 };\n}\n\n\nThis will output:\n\nBOOM times 100!!!\nBOOM times 1!!!\n\n\nThe tnt goes off before the firecracker does, because it was declared afterwards. Last in, first out.\n\nSo what is Drop good for? Generally, Drop is used to clean up any resources associated with a struct. For example, the Arc<T> type is a reference-counted type. When Drop is called, it will decrement the reference count, and if the total number of references is zero, will clean up the underlying value.\n\nif let\n\nif let permits patterns matching within the condition of an if statement. This allows us to reduce the overhead of certain kinds of pattern matches and express them in a more convenient way.\n\nFor example, let‚Äôs say we have some sort of Option<T>. We want to call a function on it if it‚Äôs Some<T>, but do nothing if it‚Äôs None. That looks like this:\n\n\nmatch option {\n    Some(x) => { foo(x) },\n    None => {},\n}\n\nWe don‚Äôt have to use match here, for example, we could use if:\n\n\nif option.is_some() {\n    let x = option.unwrap();\n    foo(x);\n}\n\nNeither of these options is particularly appealing. We can use if let to do the same thing in a nicer way:\n\n\nif let Some(x) = option {\n    foo(x);\n}\n\nIf a pattern matches successfully, it binds any appropriate parts of the value to the identifiers in the pattern, then evaluates the expression. If the pattern doesn‚Äôt match, nothing happens.\n\nIf you want to do something else when the pattern does not match, you can use else:\n\n\nif let Some(x) = option {\n    foo(x);\n} else {\n    bar();\n}\nwhile let\n\nIn a similar fashion, while let can be used when you want to conditionally loop as long as a value matches a certain pattern. It turns code like this:\n\n\nlet mut v = vec![1, 3, 5, 7, 11];\nloop {\n    match v.pop() {\n        Some(x) =>  println!(\"{}\", x),\n        None => break,\n    }\n}\n\nInto code like this:\n\n\nlet mut v = vec![1, 3, 5, 7, 11];\nwhile let Some(x) = v.pop() {\n    println!(\"{}\", x);\n}\nTrait Objects\n\nWhen code involves polymorphism, there needs to be a mechanism to determine which specific version is actually run. This is called ‚Äòdispatch‚Äô. There are two major forms of dispatch: static dispatch and dynamic dispatch. While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects‚Äô.\n\nBackground\n\nFor the rest of this chapter, we‚Äôll need a trait and some implementations. Let‚Äôs make a simple one, Foo. It has one method that is expected to return a String.\n\n\ntrait Foo {\n    fn method(&self) -> String;\n}\n\nWe‚Äôll also implement this trait for u8 and String:\n\n\nimpl Foo for u8 {\n    fn method(&self) -> String { format!(\"u8: {}\", *self) }\n}\n\nimpl Foo for String {\n    fn method(&self) -> String { format!(\"string: {}\", *self) }\n}\nStatic dispatch\n\nWe can use this trait to perform static dispatch with trait bounds:\n\nfn do_something<T: Foo>(x: T) {\n    x.method();\n}\n\nfn main() {\n    let x = 5u8;\n    let y = \"Hello\".to_string();\n\n    do_something(x);\n    do_something(y);\n}\n\n\nRust uses ‚Äòmonomorphization‚Äô to perform static dispatch here. This means that Rust will create a special version of do_something() for both u8 and String, and then replace the call sites with calls to these specialized functions. In other words, Rust generates something like this:\n\nfn do_something_u8(x: u8) {\n    x.method();\n}\n\nfn do_something_string(x: String) {\n    x.method();\n}\n\nfn main() {\n    let x = 5u8;\n    let y = \"Hello\".to_string();\n\n    do_something_u8(x);\n    do_something_string(y);\n}\n\n\nThis has a great upside: static dispatch allows function calls to be inlined because the callee is known at compile time, and inlining is the key to good optimization. Static dispatch is fast, but it comes at a tradeoff: ‚Äòcode bloat‚Äô, due to many copies of the same function existing in the binary, one for each type.\n\nFurthermore, compilers aren‚Äôt perfect and may ‚Äúoptimize‚Äù code to become slower. For example, functions inlined too eagerly will bloat the instruction cache (cache rules everything around us). This is part of the reason that #[inline] and #[inline(always)] should be used carefully, and one reason why using a dynamic dispatch is sometimes more efficient.\n\nHowever, the common case is that it is more efficient to use static dispatch, and one can always have a thin statically-dispatched wrapper function that does a dynamic dispatch, but not vice versa, meaning static calls are more flexible. The standard library tries to be statically dispatched where possible for this reason.\n\nDynamic dispatch\n\nRust provides dynamic dispatch through a feature called ‚Äòtrait objects‚Äô. Trait objects, like &Foo or Box<Foo>, are normal values that store a value of any type that implements the given trait, where the precise type can only be known at runtime.\n\nA trait object can be obtained from a pointer to a concrete type that implements the trait by casting it (e.g. &x as &Foo) or coercing it (e.g. using &x as an argument to a function that takes &Foo).\n\nThese trait object coercions and casts also work for pointers like &mut T to &mut Foo and Box<T> to Box<Foo>, but that‚Äôs all at the moment. Coercions and casts are identical.\n\nThis operation can be seen as ‚Äòerasing‚Äô the compiler‚Äôs knowledge about the specific type of the pointer, and hence trait objects are sometimes referred to as ‚Äòtype erasure‚Äô.\n\nComing back to the example above, we can use the same trait to perform dynamic dispatch with trait objects by casting:\n\nfn do_something(x: &Foo) {\n    x.method();\n}\n\nfn main() {\n    let x = 5u8;\n    do_something(&x as &Foo);\n}\n\n\nor by coercing:\n\nfn do_something(x: &Foo) {\n    x.method();\n}\n\nfn main() {\n    let x = \"Hello\".to_string();\n    do_something(&x);\n}\n\n\nA function that takes a trait object is not specialized to each of the types that implements Foo: only one copy is generated, often (but not always) resulting in less code bloat. However, this comes at the cost of requiring slower virtual function calls, and effectively inhibiting any chance of inlining and related optimizations from occurring.\n\nWhy pointers?\n\nRust does not put things behind a pointer by default, unlike many managed languages, so types can have different sizes. Knowing the size of the value at compile time is important for things like passing it as an argument to a function, moving it about on the stack and allocating (and deallocating) space on the heap to store it.\n\nFor Foo, we would need to have a value that could be at least either a String (24 bytes) or a u8 (1 byte), as well as any other type for which dependent crates may implement Foo (any number of bytes at all). There‚Äôs no way to guarantee that this last point can work if the values are stored without a pointer, because those other types can be arbitrarily large.\n\nPutting the value behind a pointer means the size of the value is not relevant when we are tossing a trait object around, only the size of the pointer itself.\n\nRepresentation\n\nThe methods of the trait can be called on a trait object via a special record of function pointers traditionally called a ‚Äòvtable‚Äô (created and managed by the compiler).\n\nTrait objects are both simple and complicated: their core representation and layout is quite straight-forward, but there are some curly error messages and surprising behaviors to discover.\n\nLet‚Äôs start simple, with the runtime representation of a trait object. The std::raw module contains structs with layouts that are the same as the complicated built-in types, including trait objects:\n\n\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n\nThat is, a trait object like &Foo consists of a ‚Äòdata‚Äô pointer and a ‚Äòvtable‚Äô pointer.\n\nThe data pointer addresses the data (of some unknown type T) that the trait object is storing, and the vtable pointer points to the vtable (‚Äòvirtual method table‚Äô) corresponding to the implementation of Foo for T.\n\nA vtable is essentially a struct of function pointers, pointing to the concrete piece of machine code for each method in the implementation. A method call like trait_object.method() will retrieve the correct pointer out of the vtable and then do a dynamic call of it. For example:\n\nstruct FooVtable {\n    destructor: fn(*mut ()),\n    size: usize,\n    align: usize,\n    method: fn(*const ()) -> String,\n}\n\n// u8:\n\nfn call_method_on_u8(x: *const ()) -> String {\n    // The compiler guarantees that this function is only called\n    // with `x` pointing to a u8.\n    let byte: &u8 = unsafe { &*(x as *const u8) };\n\n    byte.method()\n}\n\nstatic Foo_for_u8_vtable: FooVtable = FooVtable {\n    destructor: /* compiler magic */,\n    size: 1,\n    align: 1,\n\n    // Cast to a function pointer:\n    method: call_method_on_u8 as fn(*const ()) -> String,\n};\n\n\n// String:\n\nfn call_method_on_String(x: *const ()) -> String {\n    // The compiler guarantees that this function is only called\n    // with `x` pointing to a String.\n    let string: &String = unsafe { &*(x as *const String) };\n\n    string.method()\n}\n\nstatic Foo_for_String_vtable: FooVtable = FooVtable {\n    destructor: /* compiler magic */,\n    // Values for a 64-bit computer, halve them for 32-bit ones.\n    size: 24,\n    align: 8,\n\n    method: call_method_on_String as fn(*const ()) -> String,\n};\n\n\nThe destructor field in each vtable points to a function that will clean up any resources of the vtable‚Äôs type: for u8 it is trivial, but for String it will free the memory. This is necessary for owning trait objects like Box<Foo>, which need to clean-up both the Box allocation as well as the internal type when they go out of scope. The size and align fields store the size of the erased type, and its alignment requirements.\n\nSuppose we‚Äôve got some values that implement Foo. The explicit form of construction and use of Foo trait objects might look a bit like (ignoring the type mismatches: they‚Äôre all pointers anyway):\n\nlet a: String = \"foo\".to_string();\nlet x: u8 = 1;\n\n// let b: &Foo = &a;\nlet b = TraitObject {\n    // Store the data:\n    data: &a,\n    // Store the methods:\n    vtable: &Foo_for_String_vtable\n};\n\n// let y: &Foo = x;\nlet y = TraitObject {\n    // Store the data:\n    data: &x,\n    // Store the methods:\n    vtable: &Foo_for_u8_vtable\n};\n\n// b.method();\n(b.vtable.method)(b.data);\n\n// y.method();\n(y.vtable.method)(y.data);\n\nObject Safety\n\nNot every trait can be used to make a trait object. For example, vectors implement Clone, but if we try to make a trait object:\n\nlet v = vec![1, 2, 3];\nlet o = &v as &Clone;\n\n\nWe get an error:\n\nerror: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]\nlet o = &v as &Clone;\n        ^~\nnote: the trait cannot require that `Self : Sized`\nlet o = &v as &Clone;\n        ^~\n\n\nThe error says that Clone is not ‚Äòobject-safe‚Äô. Only traits that are object-safe can be made into trait objects. A trait is object-safe if both of these are true:\n\nthe trait does not require that Self: Sized\nall of its methods are object-safe\n\nSo what makes a method object-safe? Each method must require that Self: Sized or all of the following:\n\nmust not have any type parameters\nmust not use Self\n\nWhew! As we can see, almost all of these rules talk about Self. A good intuition is ‚Äúexcept in special circumstances, if your trait‚Äôs method uses Self, it is not object-safe.‚Äù\n\nClosures\n\nSometimes it is useful to wrap up a function and free variables for better clarity and reuse. The free variables that can be used come from the enclosing scope and are ‚Äòclosed over‚Äô when used in the function. From this, we get the name ‚Äòclosures‚Äô and Rust provides a really great implementation of them, as we‚Äôll see.\n\nSyntax\n\nClosures look like this:\n\n\nlet plus_one = |x: i32| x + 1;\n\nassert_eq!(2, plus_one(1));\n\nWe create a binding, plus_one, and assign it to a closure. The closure‚Äôs arguments go between the pipes (|), and the body is an expression, in this case, x + 1. Remember that { } is an expression, so we can have multi-line closures too:\n\n\nlet plus_two = |x| {\n    let mut result: i32 = x;\n\n    result += 1;\n    result += 1;\n\n    result\n};\n\nassert_eq!(4, plus_two(2));\n\nYou‚Äôll notice a few things about closures that are a bit different from regular named functions defined with fn. The first is that we did not need to annotate the types of arguments the closure takes or the values it returns. We can:\n\n\nlet plus_one = |x: i32| -> i32 { x + 1 };\n\nassert_eq!(2, plus_one(1));\n\nBut we don‚Äôt have to. Why is this? Basically, it was chosen for ergonomic reasons. While specifying the full type for named functions is helpful with things like documentation and type inference, the full type signatures of closures are rarely documented since they‚Äôre anonymous, and they don‚Äôt cause the kinds of error-at-a-distance problems that inferring named function types can.\n\nThe second is that the syntax is similar, but a bit different. I‚Äôve added spaces here for easier comparison:\n\n\nfn  plus_one_v1   (x: i32) -> i32 { x + 1 }\nlet plus_one_v2 = |x: i32| -> i32 { x + 1 };\nlet plus_one_v3 = |x: i32|          x + 1  ;\n\nSmall differences, but they‚Äôre similar.\n\nClosures and their environment\n\nThe environment for a closure can include bindings from its enclosing scope in addition to parameters and local bindings. It looks like this:\n\n\nlet num = 5;\nlet plus_num = |x: i32| x + num;\n\nassert_eq!(10, plus_num(5));\n\nThis closure, plus_num, refers to a let binding in its scope: num. More specifically, it borrows the binding. If we do something that would conflict with that binding, we get an error. Like this one:\n\nlet mut num = 5;\nlet plus_num = |x: i32| x + num;\n\nlet y = &mut num;\n\n\nWhich errors with:\n\nerror: cannot borrow `num` as mutable because it is also borrowed as immutable\n    let y = &mut num;\n                 ^~~\nnote: previous borrow of `num` occurs here due to use in closure; the immutable\n  borrow prevents subsequent moves or mutable borrows of `num` until the borrow\n  ends\n    let plus_num = |x| x + num;\n                   ^~~~~~~~~~~\nnote: previous borrow ends here\nfn main() {\n    let mut num = 5;\n    let plus_num = |x| x + num;\n\n    let y = &mut num;\n}\n^\n\n\nA verbose yet helpful error message! As it says, we can‚Äôt take a mutable borrow on num because the closure is already borrowing it. If we let the closure go out of scope, we can:\n\n\nlet mut num = 5;\n{\n    let plus_num = |x: i32| x + num;\n\n} // `plus_num` goes out of scope; borrow of `num` ends.\n\nlet y = &mut num;\n\nIf your closure requires it, however, Rust will take ownership and move the environment instead. This doesn‚Äôt work:\n\nlet nums = vec![1, 2, 3];\n\nlet takes_nums = || nums;\n\nprintln!(\"{:?}\", nums);\n\n\nWe get this error:\n\nnote: `nums` moved into closure environment here because it has type\n  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable\nlet takes_nums = || nums;\n                 ^~~~~~~\n\n\nVec<T> has ownership over its contents, and therefore, when we refer to it in our closure, we have to take ownership of nums. It‚Äôs the same as if we‚Äôd passed nums to a function that took ownership of it.\n\nmove closures\n\nWe can force our closure to take ownership of its environment with the move keyword:\n\n\nlet num = 5;\n\nlet owns_num = move |x: i32| x + num;\n\nNow, even though the keyword is move, the variables follow normal move semantics. In this case, 5 implements Copy, and so owns_num takes ownership of a copy of num. So what‚Äôs the difference?\n\n\nlet mut num = 5;\n\n{\n    let mut add_num = |x: i32| num += x;\n\n    add_num(5);\n}\n\nassert_eq!(10, num);\n\nSo in this case, our closure took a mutable reference to num, and then when we called add_num, it mutated the underlying value, as we‚Äôd expect. We also needed to declare add_num as mut too, because we‚Äôre mutating its environment.\n\nIf we change to a move closure, it‚Äôs different:\n\n\nlet mut num = 5;\n\n{\n    let mut add_num = move |x: i32| num += x;\n\n    add_num(5);\n}\n\nassert_eq!(5, num);\n\nWe only get 5. Rather than taking a mutable borrow out on our num, we took ownership of a copy.\n\nAnother way to think about move closures: they give a closure its own stack frame. Without move, a closure may be tied to the stack frame that created it, while a move closure is self-contained. This means that you cannot generally return a non-move closure from a function, for example.\n\nBut before we talk about taking and returning closures, we should talk some more about the way that closures are implemented. As a systems language, Rust gives you tons of control over what your code does, and closures are no different.\n\nClosure implementation\n\nRust‚Äôs implementation of closures is a bit different than other languages. They are effectively syntax sugar for traits. You‚Äôll want to make sure to have read the traits section before this one, as well as the section on trait objects.\n\nGot all that? Good.\n\nThe key to understanding how closures work under the hood is something a bit strange: Using () to call a function, like foo(), is an overloadable operator. From this, everything else clicks into place. In Rust, we use the trait system to overload operators. Calling functions is no different. We have three separate traits to overload with:\n\nFn\nFnMut\nFnOnce\n\nThere are a few differences between these traits, but a big one is self: Fn takes &self, FnMut takes &mut self, and FnOnce takes self. This covers all three kinds of self via the usual method call syntax. But we‚Äôve split them up into three traits, rather than having a single one. This gives us a large amount of control over what kind of closures we can take.\n\nThe || {} syntax for closures is sugar for these three traits. Rust will generate a struct for the environment, impl the appropriate trait, and then use it.\n\nTaking closures as arguments\n\nNow that we know that closures are traits, we already know how to accept and return closures: the same as any other trait!\n\nThis also means that we can choose static vs dynamic dispatch as well. First, let‚Äôs write a function which takes something callable, calls it, and returns the result:\n\n\nfn call_with_one<F>(some_closure: F) -> i32\n    where F: Fn(i32) -> i32 {\n\n    some_closure(1)\n}\n\nlet answer = call_with_one(|x| x + 2);\n\nassert_eq!(3, answer);\n\nWe pass our closure, |x| x + 2, to call_with_one. It does what it suggests: it calls the closure, giving it 1 as an argument.\n\nLet‚Äôs examine the signature of call_with_one in more depth:\n\n\nfn call_with_one<F>(some_closure: F) -> i32\n\nWe take one parameter, and it has the type F. We also return an i32. This part isn‚Äôt interesting. The next part is:\n\n\n    where F: Fn(i32) -> i32 {\n\nBecause Fn is a trait, we can use it as a bound for our generic type. In this case, our closure takes an i32 as an argument and returns an i32, and so the generic bound we use is Fn(i32) -> i32.\n\nThere‚Äôs one other key point here: because we‚Äôre bounding a generic with a trait, this will get monomorphized, and therefore, we‚Äôll be doing static dispatch into the closure. That‚Äôs pretty neat. In many languages, closures are inherently heap allocated, and will always involve dynamic dispatch. In Rust, we can stack allocate our closure environment, and statically dispatch the call. This happens quite often with iterators and their adapters, which often take closures as arguments.\n\nOf course, if we want dynamic dispatch, we can get that too. A trait object handles this case, as usual:\n\n\nfn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n    some_closure(1)\n}\n\nlet answer = call_with_one(&|x| x + 2);\n\nassert_eq!(3, answer);\n\nNow we take a trait object, a &Fn. And we have to make a reference to our closure when we pass it to call_with_one, so we use &||.\n\nA quick note about closures that use explicit lifetimes. Sometimes you might have a closure that takes a reference like so:\n\n\nfn call_with_ref<F>(some_closure:F) -> i32\n    where F: Fn(&i32) -> i32 {\n\n    let value = 0;\n    some_closure(&value)\n}\n\nNormally you can specify the lifetime of the parameter to our closure. We could annotate it on the function declaration:\n\nfn call_with_ref<'a, F>(some_closure:F) -> i32\n    where F: Fn(&'a i32) -> i32 {\n\n\nHowever, this presents a problem in our case. When a function has an explicit lifetime parameter, that lifetime must be at least as long as the entire call to that function. The borrow checker will complain that value doesn't live long enough, because it is only in scope after its declaration inside the function body.\n\nWhat we need is a closure that can borrow its argument only for its own invocation scope, not for the outer function's scope. In order to say that, we can use Higher-Ranked Trait Bounds with the for<...> syntax:\n\nfn call_with_ref<F>(some_closure:F) -> i32\n    where F: for<'a> Fn(&'a i32) -> i32 {\n\n\nThis lets the Rust compiler find the minimum lifetime to invoke our closure and satisfy the borrow checker's rules. Our function then compiles and executes as we expect.\n\n\nfn call_with_ref<F>(some_closure:F) -> i32\n    where F: for<'a> Fn(&'a i32) -> i32 {\n\n    let value = 0;\n    some_closure(&value)\n}\nFunction pointers and closures\n\nA function pointer is kind of like a closure that has no environment. As such, you can pass a function pointer to any function expecting a closure argument, and it will work:\n\n\nfn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n    some_closure(1)\n}\n\nfn add_one(i: i32) -> i32 {\n    i + 1\n}\n\nlet f = add_one;\n\nlet answer = call_with_one(&f);\n\nassert_eq!(2, answer);\n\nIn this example, we don‚Äôt strictly need the intermediate variable f, the name of the function works just fine too:\n\nlet answer = call_with_one(&add_one);\n\nReturning closures\n\nIt‚Äôs very common for functional-style code to return closures in various situations. If you try to return a closure, you may run into an error. At first, it may seem strange, but we‚Äôll figure it out. Here‚Äôs how you‚Äôd probably try to return a closure from a function:\n\nfn factory() -> (Fn(i32) -> i32) {\n    let num = 5;\n\n    |x| x + num\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nThis gives us these long, related errors:\n\nerror: the trait bound `core::ops::Fn(i32) -> i32 : core::marker::Sized` is not satisfied [E0277]\nfn factory() -> (Fn(i32) -> i32) {\n                ^~~~~~~~~~~~~~~~\nnote: `core::ops::Fn(i32) -> i32` does not have a constant size known at compile-time\nfn factory() -> (Fn(i32) -> i32) {\n                ^~~~~~~~~~~~~~~~\nerror: the trait bound `core::ops::Fn(i32) -> i32 : core::marker::Sized` is not satisfied [E0277]\nlet f = factory();\n    ^\nnote: `core::ops::Fn(i32) -> i32` does not have a constant size known at compile-time\nlet f = factory();\n    ^\n\n\nIn order to return something from a function, Rust needs to know what size the return type is. But since Fn is a trait, it could be various things of various sizes: many different types can implement Fn. An easy way to give something a size is to take a reference to it, as references have a known size. So we‚Äôd write this:\n\nfn factory() -> &(Fn(i32) -> i32) {\n    let num = 5;\n\n    |x| x + num\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nBut we get another error:\n\nerror: missing lifetime specifier [E0106]\nfn factory() -> &(Fn(i32) -> i32) {\n                ^~~~~~~~~~~~~~~~~\n\n\nRight. Because we have a reference, we need to give it a lifetime. But our factory() function takes no arguments, so elision doesn‚Äôt kick in here. Then what choices do we have? Try 'static:\n\nfn factory() -> &'static (Fn(i32) -> i32) {\n    let num = 5;\n\n    |x| x + num\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nBut we get another error:\n\nerror: mismatched types:\n expected `&'static core::ops::Fn(i32) -> i32`,\n    found `[closure@<anon>:7:9: 7:20]`\n(expected &-ptr,\n    found closure) [E0308]\n         |x| x + num\n         ^~~~~~~~~~~\n\n\n\nThis error is letting us know that we don‚Äôt have a &'static Fn(i32) -> i32, we have a [closure@<anon>:7:9: 7:20]. Wait, what?\n\nBecause each closure generates its own environment struct and implementation of Fn and friends, these types are anonymous. They exist solely for this closure. So Rust shows them as closure@<anon>, rather than some autogenerated name.\n\nThe error also points out that the return type is expected to be a reference, but what we are trying to return is not. Further, we cannot directly assign a 'static lifetime to an object. So we'll take a different approach and return a ‚Äòtrait object‚Äô by Boxing up the Fn. This almost works:\n\nfn factory() -> Box<Fn(i32) -> i32> {\n    let num = 5;\n\n    Box::new(|x| x + num)\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nThere‚Äôs just one last problem:\n\nerror: closure may outlive the current function, but it borrows `num`,\nwhich is owned by the current function [E0373]\nBox::new(|x| x + num)\n         ^~~~~~~~~~~\n\n\nWell, as we discussed before, closures borrow their environment. And in this case, our environment is based on a stack-allocated 5, the num variable binding. So the borrow has a lifetime of the stack frame. So if we returned this closure, the function call would be over, the stack frame would go away, and our closure is capturing an environment of garbage memory! With one last fix, we can make this work:\n\n\nfn factory() -> Box<Fn(i32) -> i32> {\n    let num = 5;\n\n    Box::new(move |x| x + num)\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\nBy making the inner closure a move Fn, we create a new stack frame for our closure. By Boxing it up, we‚Äôve given it a known size, allowing it to escape our stack frame.\n\nUniversal Function Call Syntax\n\nSometimes, functions can have the same names. Consider this code:\n\n\ntrait Foo {\n    fn f(&self);\n}\n\ntrait Bar {\n    fn f(&self);\n}\n\nstruct Baz;\n\nimpl Foo for Baz {\n    fn f(&self) { println!(\"Baz‚Äôs impl of Foo\"); }\n}\n\nimpl Bar for Baz {\n    fn f(&self) { println!(\"Baz‚Äôs impl of Bar\"); }\n}\n\nlet b = Baz;\n\nIf we were to try to call b.f(), we‚Äôd get an error:\n\nerror: multiple applicable methods in scope [E0034]\nb.f();\n  ^~~\nnote: candidate #1 is defined in an impl of the trait `main::Foo` for the type\n`main::Baz`\n    fn f(&self) { println!(\"Baz‚Äôs impl of Foo\"); }\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: candidate #2 is defined in an impl of the trait `main::Bar` for the type\n`main::Baz`\n    fn f(&self) { println!(\"Baz‚Äôs impl of Bar\"); }\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\nWe need a way to disambiguate which method we need. This feature is called ‚Äòuniversal function call syntax‚Äô, and it looks like this:\n\n\nFoo::f(&b);\nBar::f(&b);\n\nLet‚Äôs break it down.\n\nFoo::\nBar::\n\n\nThese halves of the invocation are the types of the two traits: Foo and Bar. This is what ends up actually doing the disambiguation between the two: Rust calls the one from the trait name you use.\n\nf(&b)\n\n\nWhen we call a method like b.f() using method syntax, Rust will automatically borrow b if f() takes &self. In this case, Rust will not, and so we need to pass an explicit &b.\n\nAngle-bracket Form\n\nThe form of UFCS we just talked about:\n\nTrait::method(args);\n\n\nIs a short-hand. There‚Äôs an expanded form of this that‚Äôs needed in some situations:\n\n<Type as Trait>::method(args);\n\n\nThe <>:: syntax is a means of providing a type hint. The type goes inside the <>s. In this case, the type is Type as Trait, indicating that we want Trait‚Äôs version of method to be called here. The as Trait part is optional if it‚Äôs not ambiguous. Same with the angle brackets, hence the shorter form.\n\nHere‚Äôs an example of using the longer form.\n\ntrait Foo {\n    fn foo() -> i32;\n}\n\nstruct Bar;\n\nimpl Bar {\n    fn foo() -> i32 {\n        20\n    }\n}\n\nimpl Foo for Bar {\n    fn foo() -> i32 {\n        10\n    }\n}\n\nfn main() {\n    assert_eq!(10, <Bar as Foo>::foo());\n    assert_eq!(20, Bar::foo());\n}\n\n\nUsing the angle bracket syntax lets you call the trait method instead of the inherent one.\n\nCrates and Modules\n\nWhen a project starts getting large, it‚Äôs considered good software engineering practice to split it up into a bunch of smaller pieces, and then fit them together. It is also important to have a well-defined interface, so that some of your functionality is private, and some is public. To facilitate these kinds of things, Rust has a module system.\n\nBasic terminology: Crates and Modules\n\nRust has two distinct terms that relate to the module system: ‚Äòcrate‚Äô and ‚Äòmodule‚Äô. A crate is synonymous with a ‚Äòlibrary‚Äô or ‚Äòpackage‚Äô in other languages. Hence ‚ÄúCargo‚Äù as the name of Rust‚Äôs package management tool: you ship your crates to others with Cargo. Crates can produce an executable or a library, depending on the project.\n\nEach crate has an implicit root module that contains the code for that crate. You can then define a tree of sub-modules under that root module. Modules allow you to partition your code within the crate itself.\n\nAs an example, let‚Äôs make a phrases crate, which will give us various phrases in different languages. To keep things simple, we‚Äôll stick to ‚Äògreetings‚Äô and ‚Äòfarewells‚Äô as two kinds of phrases, and use English and Japanese (Êó•Êú¨Ë™û) as two languages for those phrases to be in. We‚Äôll use this module layout:\n\n                                    +-----------+\n                                +---| greetings |\n                  +---------+   |   +-----------+\n              +---| english |---+\n              |   +---------+   |   +-----------+\n              |                 +---| farewells |\n+---------+   |                     +-----------+\n| phrases |---+\n+---------+   |                     +-----------+\n              |                 +---| greetings |\n              |   +----------+  |   +-----------+\n              +---| japanese |--+\n                  +----------+  |   +-----------+\n                                +---| farewells |\n                                    +-----------+\n\n\nIn this example, phrases is the name of our crate. All of the rest are modules. You can see that they form a tree, branching out from the crate root, which is the root of the tree: phrases itself.\n\nNow that we have a plan, let‚Äôs define these modules in code. To start, generate a new crate with Cargo:\n\n$ cargo new phrases\n$ cd phrases\n\n\nIf you remember, this generates a simple project for us:\n\n$ tree .\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n\n1 directory, 2 files\n\n\nsrc/lib.rs is our crate root, corresponding to the phrases in our diagram above.\n\nDefining Modules\n\nTo define each of our modules, we use the mod keyword. Let‚Äôs make our src/lib.rs look like this:\n\n\nmod english {\n    mod greetings {\n    }\n\n    mod farewells {\n    }\n}\n\nmod japanese {\n    mod greetings {\n    }\n\n    mod farewells {\n    }\n}\n\nAfter the mod keyword, you give the name of the module. Module names follow the conventions for other Rust identifiers: lower_snake_case. The contents of each module are within curly braces ({}).\n\nWithin a given mod, you can declare sub-mods. We can refer to sub-modules with double-colon (::) notation: our four nested modules are english::greetings, english::farewells, japanese::greetings, and japanese::farewells. Because these sub-modules are namespaced under their parent module, the names don‚Äôt conflict: english::greetings and japanese::greetings are distinct, even though their names are both greetings.\n\nBecause this crate does not have a main() function, and is called lib.rs, Cargo will build this crate as a library:\n\n$ cargo build\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n$ ls target/debug\nbuild  deps  examples  libphrases-a7448e02a0468eaa.rlib  native\n\n\nlibphrases-<hash>.rlib is the compiled crate. Before we see how to use this crate from another crate, let‚Äôs break it up into multiple files.\n\nMultiple File Crates\n\nIf each crate were just one file, these files would get very large. It‚Äôs often easier to split up crates into multiple files, and Rust supports this in two ways.\n\nInstead of declaring a module like this:\n\nmod english {\n    // Contents of our module go here.\n}\n\n\nWe can instead declare our module like this:\n\nmod english;\n\n\nIf we do that, Rust will expect to find either a english.rs file, or a english/mod.rs file with the contents of our module.\n\nNote that in these files, you don‚Äôt need to re-declare the module: that‚Äôs already been done with the initial mod declaration.\n\nUsing these two techniques, we can break up our crate into two directories and seven files:\n\n$ tree .\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ english\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ farewells.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ greetings.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ japanese\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ farewells.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ greetings.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs\n‚îî‚îÄ‚îÄ target\n    ‚îî‚îÄ‚îÄ debug\n        ‚îú‚îÄ‚îÄ build\n        ‚îú‚îÄ‚îÄ deps\n        ‚îú‚îÄ‚îÄ examples\n        ‚îú‚îÄ‚îÄ libphrases-a7448e02a0468eaa.rlib\n        ‚îî‚îÄ‚îÄ native\n\n\nsrc/lib.rs is our crate root, and looks like this:\n\nmod english;\nmod japanese;\n\n\nThese two declarations tell Rust to look for\n\neither src/english.rs or src/english/mod.rs, and\neither src/japanese.rs or src/japanese/mod.rs,\n\ndepending on our preference. In this case, because our modules have sub-modules, we‚Äôve chosen the mod.rs approach. Both src/english/mod.rs and src/japanese/mod.rs look like this:\n\nmod greetings;\nmod farewells;\n\n\nAgain, these declarations tell Rust to look for\n\nsrc/english/greetings.rs or src/english/greetings/mod.rs,\nsrc/english/farewells.rs or src/english/farewells/mod.rs,\nsrc/japanese/greetings.rs or src/japanese/greetings/mod.rs,\nand src/japanese/farewells.rs or src/japanese/farewells/mod.rs.\n\nBecause these sub-modules don‚Äôt have their own sub-modules, we‚Äôve chosen to make them src/english/greetings.rs, src/english/farewells.rs, src/japanese/greetings.rs and src/japanese/farewells.rs. Whew!\n\nThe contents of src/english/greetings.rs, src/english/farewells.rs, src/japanese/greetings.rs and src/japanese/farewells.rs are all empty at the moment. Let‚Äôs add some functions.\n\nPut this in src/english/greetings.rs:\n\n\nfn hello() -> String {\n    \"Hello!\".to_string()\n}\n\nPut this in src/english/farewells.rs:\n\n\nfn goodbye() -> String {\n    \"Goodbye.\".to_string()\n}\n\nPut this in src/japanese/greetings.rs:\n\n\nfn hello() -> String {\n    \"„Åì„Çì„Å´„Å°„ÅØ\".to_string()\n}\n\nOf course, you can copy and paste this from this web page, or type something else. It‚Äôs not important that you actually put ‚Äòkonnichiwa‚Äô to learn about the module system.\n\nPut this in src/japanese/farewells.rs:\n\n\nfn goodbye() -> String {\n    \"„Åï„Çà„ÅÜ„Å™„Çâ\".to_string()\n}\n\n(This is ‚ÄòSay≈çnara‚Äô, if you‚Äôre curious.)\n\nNow that we have some functionality in our crate, let‚Äôs try to use it from another crate.\n\nImporting External Crates\n\nWe have a library crate. Let‚Äôs make an executable crate that imports and uses our library.\n\nMake a src/main.rs and put this in it (it won‚Äôt quite compile yet):\n\nextern crate phrases;\n\nfn main() {\n    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n\n    println!(\"Hello in Japanese: {}\", phrases::japanese::greetings::hello());\n    println!(\"Goodbye in Japanese: {}\", phrases::japanese::farewells::goodbye());\n}\n\n\nThe extern crate declaration tells Rust that we need to compile and link to the phrases crate. We can then use phrases‚Äô modules in this one. As we mentioned earlier, you can use double colons to refer to sub-modules and the functions inside of them.\n\n(Note: when importing a crate that has dashes in its name \"like-this\", which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write extern crate like_this;.)\n\nAlso, Cargo assumes that src/main.rs is the crate root of a binary crate, rather than a library crate. Our package now has two crates: src/lib.rs and src/main.rs. This pattern is quite common for executable crates: most functionality is in a library crate, and the executable crate uses that library. This way, other programs can also use the library crate, and it‚Äôs also a nice separation of concerns.\n\nThis doesn‚Äôt quite work yet, though. We get four errors that look similar to this:\n\n$ cargo build\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\nsrc/main.rs:4:38: 4:72 error: function `hello` is private\nsrc/main.rs:4     println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: in expansion of format_args!\n<std macros>:2:25: 2:58 note: expansion site\n<std macros>:1:1: 2:62 note: in expansion of print!\n<std macros>:3:1: 3:54 note: expansion site\n<std macros>:1:1: 3:58 note: in expansion of println!\nphrases/src/main.rs:4:5: 4:76 note: expansion site\n\n\nBy default, everything is private in Rust. Let‚Äôs talk about this in some more depth.\n\nExporting a Public Interface\n\nRust allows you to precisely control which aspects of your interface are public, and so private is the default. To make things public, you use the pub keyword. Let‚Äôs focus on the english module first, so let‚Äôs reduce our src/main.rs to only this:\n\nextern crate phrases;\n\nfn main() {\n    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n}\n\n\nIn our src/lib.rs, let‚Äôs add pub to the english module declaration:\n\npub mod english;\nmod japanese;\n\n\nAnd in our src/english/mod.rs, let‚Äôs make both pub:\n\npub mod greetings;\npub mod farewells;\n\n\nIn our src/english/greetings.rs, let‚Äôs add pub to our fn declaration:\n\npub fn hello() -> String {\n    \"Hello!\".to_string()\n}\n\n\nAnd also in src/english/farewells.rs:\n\npub fn goodbye() -> String {\n    \"Goodbye.\".to_string()\n}\n\n\nNow, our crate compiles, albeit with warnings about not using the japanese functions:\n\n$ cargo run\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\nsrc/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default\nsrc/japanese/greetings.rs:1 fn hello() -> String {\nsrc/japanese/greetings.rs:2     \"„Åì„Çì„Å´„Å°„ÅØ\".to_string()\nsrc/japanese/greetings.rs:3 }\nsrc/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default\nsrc/japanese/farewells.rs:1 fn goodbye() -> String {\nsrc/japanese/farewells.rs:2     \"„Åï„Çà„ÅÜ„Å™„Çâ\".to_string()\nsrc/japanese/farewells.rs:3 }\n     Running `target/debug/phrases`\nHello in English: Hello!\nGoodbye in English: Goodbye.\n\n\npub also applies to structs and their member fields. In keeping with Rust‚Äôs tendency toward safety, simply making a struct public won't automatically make its members public: you must mark the fields individually with pub.\n\nNow that our functions are public, we can use them. Great! However, typing out phrases::english::greetings::hello() is very long and repetitive. Rust has another keyword for importing names into the current scope, so that you can refer to them with shorter names. Let‚Äôs talk about use.\n\nImporting Modules with use\n\nRust has a use keyword, which allows us to import names into our local scope. Let‚Äôs change our src/main.rs to look like this:\n\nextern crate phrases;\n\nuse phrases::english::greetings;\nuse phrases::english::farewells;\n\nfn main() {\n    println!(\"Hello in English: {}\", greetings::hello());\n    println!(\"Goodbye in English: {}\", farewells::goodbye());\n}\n\n\nThe two use lines import each module into the local scope, so we can refer to the functions by a much shorter name. By convention, when importing functions, it‚Äôs considered best practice to import the module, rather than the function directly. In other words, you can do this:\n\nextern crate phrases;\n\nuse phrases::english::greetings::hello;\nuse phrases::english::farewells::goodbye;\n\nfn main() {\n    println!(\"Hello in English: {}\", hello());\n    println!(\"Goodbye in English: {}\", goodbye());\n}\n\n\nBut it is not idiomatic. This is significantly more likely to introduce a naming conflict. In our short program, it‚Äôs not a big deal, but as it grows, it becomes a problem. If we have conflicting names, Rust will give a compilation error. For example, if we made the japanese functions public, and tried to do this:\n\nextern crate phrases;\n\nuse phrases::english::greetings::hello;\nuse phrases::japanese::greetings::hello;\n\nfn main() {\n    println!(\"Hello in English: {}\", hello());\n    println!(\"Hello in Japanese: {}\", hello());\n}\n\n\nRust will give us a compile-time error:\n\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\nsrc/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]\nsrc/main.rs:4 use phrases::japanese::greetings::hello;\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\nCould not compile `phrases`.\n\n\nIf we‚Äôre importing multiple names from the same module, we don‚Äôt have to type it out twice. Instead of this:\n\nuse phrases::english::greetings;\nuse phrases::english::farewells;\n\n\nWe can use this shortcut:\n\nuse phrases::english::{greetings, farewells};\n\nRe-exporting with pub use\n\nYou don‚Äôt only use use to shorten identifiers. You can also use it inside of your crate to re-export a function inside another module. This allows you to present an external interface that may not directly map to your internal code organization.\n\nLet‚Äôs look at an example. Modify your src/main.rs to read like this:\n\nextern crate phrases;\n\nuse phrases::english::{greetings,farewells};\nuse phrases::japanese;\n\nfn main() {\n    println!(\"Hello in English: {}\", greetings::hello());\n    println!(\"Goodbye in English: {}\", farewells::goodbye());\n\n    println!(\"Hello in Japanese: {}\", japanese::hello());\n    println!(\"Goodbye in Japanese: {}\", japanese::goodbye());\n}\n\n\nThen, modify your src/lib.rs to make the japanese mod public:\n\npub mod english;\npub mod japanese;\n\n\nNext, make the two functions public, first in src/japanese/greetings.rs:\n\npub fn hello() -> String {\n    \"„Åì„Çì„Å´„Å°„ÅØ\".to_string()\n}\n\n\nAnd then in src/japanese/farewells.rs:\n\npub fn goodbye() -> String {\n    \"„Åï„Çà„ÅÜ„Å™„Çâ\".to_string()\n}\n\n\nFinally, modify your src/japanese/mod.rs to read like this:\n\npub use self::greetings::hello;\npub use self::farewells::goodbye;\n\nmod greetings;\nmod farewells;\n\n\nThe pub use declaration brings the function into scope at this part of our module hierarchy. Because we‚Äôve pub used this inside of our japanese module, we now have a phrases::japanese::hello() function and a phrases::japanese::goodbye() function, even though the code for them lives in phrases::japanese::greetings::hello() and phrases::japanese::farewells::goodbye(). Our internal organization doesn‚Äôt define our external interface.\n\nHere we have a pub use for each function we want to bring into the japanese scope. We could alternatively use the wildcard syntax to include everything from greetings into the current scope: pub use self::greetings::*.\n\nWhat about the self? Well, by default, use declarations are absolute paths, starting from your crate root. self makes that path relative to your current place in the hierarchy instead. There‚Äôs one more special form of use: you can use super:: to reach one level up the tree from your current location. Some people like to think of self as . and super as .., from many shells‚Äô display for the current directory and the parent directory.\n\nOutside of use, paths are relative: foo::bar() refers to a function inside of foo relative to where we are. If that‚Äôs prefixed with ::, as in ::foo::bar(), it refers to a different foo, an absolute path from your crate root.\n\nThis will build and run:\n\n$ cargo run\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n     Running `target/debug/phrases`\nHello in English: Hello!\nGoodbye in English: Goodbye.\nHello in Japanese: „Åì„Çì„Å´„Å°„ÅØ\nGoodbye in Japanese: „Åï„Çà„ÅÜ„Å™„Çâ\n\nComplex imports\n\nRust offers several advanced options that can add compactness and convenience to your extern crate and use statements. Here is an example:\n\nextern crate phrases as sayings;\n\nuse sayings::japanese::greetings as ja_greetings;\nuse sayings::japanese::farewells::*;\nuse sayings::english::{self, greetings as en_greetings, farewells as en_farewells};\n\nfn main() {\n    println!(\"Hello in English; {}\", en_greetings::hello());\n    println!(\"And in Japanese: {}\", ja_greetings::hello());\n    println!(\"Goodbye in English: {}\", english::farewells::goodbye());\n    println!(\"Again: {}\", en_farewells::goodbye());\n    println!(\"And in Japanese: {}\", goodbye());\n}\n\n\nWhat's going on here?\n\nFirst, both extern crate and use allow renaming the thing that is being imported. So the crate is still called \"phrases\", but here we will refer to it as \"sayings\". Similarly, the first use statement pulls in the japanese::greetings module from the crate, but makes it available as ja_greetings as opposed to simply greetings. This can help to avoid ambiguity when importing similarly-named items from different places.\n\nThe second use statement uses a star glob to bring in all public symbols from the sayings::japanese::farewells module. As you can see we can later refer to the Japanese goodbye function with no module qualifiers. This kind of glob should be used sparingly. It‚Äôs worth noting that it only imports the public symbols, even if the code doing the globbing is in the same module.\n\nThe third use statement bears more explanation. It's using \"brace expansion\" globbing to compress three use statements into one (this sort of syntax may be familiar if you've written Linux shell scripts before). The uncompressed form of this statement would be:\n\nuse sayings::english;\nuse sayings::english::greetings as en_greetings;\nuse sayings::english::farewells as en_farewells;\n\n\nAs you can see, the curly brackets compress use statements for several items under the same path, and in this context self refers back to that path. Note: The curly brackets cannot be nested or mixed with star globbing.\n\nconst and static\n\nRust has a way of defining constants with the const keyword:\n\n\nconst N: i32 = 5;\n\nUnlike let bindings, you must annotate the type of a const.\n\nConstants live for the entire lifetime of a program. More specifically, constants in Rust have no fixed address in memory. This is because they‚Äôre effectively inlined to each place that they‚Äôre used. References to the same constant are not necessarily guaranteed to refer to the same memory address for this reason.\n\nstatic\n\nRust provides a ‚Äòglobal variable‚Äô sort of facility in static items. They‚Äôre similar to constants, but static items aren‚Äôt inlined upon use. This means that there is only one instance for each value, and it‚Äôs at a fixed location in memory.\n\nHere‚Äôs an example:\n\n\nstatic N: i32 = 5;\n\nUnlike let bindings, you must annotate the type of a static.\n\nStatics live for the entire lifetime of a program, and therefore any reference stored in a static has a 'static lifetime:\n\n\nstatic NAME: &'static str = \"Steve\";\n\nThe type of a static value must be Sync unless the static value is mutable.\n\nMutability\n\nYou can introduce mutability with the mut keyword:\n\n\nstatic mut N: i32 = 5;\n\nBecause this is mutable, one thread could be updating N while another is reading it, causing memory unsafety. As such both accessing and mutating a static mut is unsafe, and so must be done in an unsafe block:\n\n\n\nunsafe {\n    N += 1;\n\n    println!(\"N: {}\", N);\n}\nInitializing\n\nBoth const and static have requirements for giving them a value. They must be given a value that‚Äôs a constant expression. In other words, you cannot use the result of a function call or anything similarly complex or at runtime.\n\nDropping\n\nTypes implementing Drop are allowed in const and static definitions. Constants are inlined where they are used and are dropped accordingly. static values are not dropped.\n\nWhich construct should I use?\n\nAlmost always, if you can choose between the two, choose const. It‚Äôs pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but downstream crates.\n\nAttributes\n\nDeclarations can be annotated with ‚Äòattributes‚Äô in Rust. They look like this:\n\n\n#[test]\n\nor like this:\n\n\n#![test]\n\nThe difference between the two is the !, which changes what the attribute applies to:\n\n#[foo]\nstruct Foo;\n\nmod bar {\n    #![bar]\n}\n\n\nThe #[foo] attribute applies to the next item, which is the struct declaration. The #![bar] attribute applies to the item enclosing it, which is the mod declaration. Otherwise, they‚Äôre the same. Both change the meaning of the item they‚Äôre attached to somehow.\n\nFor example, consider a function like this:\n\n\n#[test]\nfn check() {\n    assert_eq!(2, 1 + 1);\n}\n\nIt is marked with #[test]. This means it‚Äôs special: when you run tests, this function will execute. When you compile as usual, it won‚Äôt even be included. This function is now a test function.\n\nAttributes may also have additional data:\n\n\n#[inline(always)]\nfn super_fast_fn() {\n\nOr even keys and values:\n\n\n#[cfg(target_os = \"macos\")]\nmod macos_only {\n\nRust attributes are used for a number of different things. There is a full list of attributes in the reference. Currently, you are not allowed to create your own attributes, the Rust compiler defines them.\n\nType Aliases\n\nThe type keyword lets you declare an alias of another type:\n\n\ntype Name = String;\n\nYou can then use this type as if it were a real type:\n\n\ntype Name = String;\n\nlet x: Name = \"Hello\".to_string();\n\nNote, however, that this is an alias, not a new type entirely. In other words, because Rust is strongly typed, you‚Äôd expect a comparison between two different types to fail:\n\nlet x: i32 = 5;\nlet y: i64 = 5;\n\nif x == y {\n   // ...\n}\n\n\nthis gives\n\nerror: mismatched types:\n expected `i32`,\n    found `i64`\n(expected i32,\n    found i64) [E0308]\n     if x == y {\n             ^\n\n\nBut, if we had an alias:\n\n\ntype Num = i32;\n\nlet x: i32 = 5;\nlet y: Num = 5;\n\nif x == y {\n   // ...\n}\n\nThis compiles without error. Values of a Num type are the same as a value of type i32, in every way. You can use tuple struct to really get a new type.\n\nYou can also use type aliases with generics:\n\n\nuse std::result;\n\nenum ConcreteError {\n    Foo,\n    Bar,\n}\n\ntype Result<T> = result::Result<T, ConcreteError>;\n\nThis creates a specialized version of the Result type, which always has a ConcreteError for the E part of Result<T, E>. This is commonly used in the standard library to create custom errors for each subsection. For example, io::Result.\n\nCasting Between Types\n\nRust, with its focus on safety, provides two different ways of casting different types between each other. The first, as, is for safe casts. In contrast, transmute allows for arbitrary casting, and is one of the most dangerous features of Rust!\n\nCoercion\n\nCoercion between types is implicit and has no syntax of its own, but can be spelled out with as.\n\nCoercion occurs in let, const, and static statements; in function call arguments; in field values in struct initialization; and in a function result.\n\nThe most common case of coercion is removing mutability from a reference:\n\n&mut T to &T\n\nAn analogous conversion is to remove mutability from a raw pointer:\n\n*mut T to *const T\n\nReferences can also be coerced to raw pointers:\n\n&T to *const T\n\n&mut T to *mut T\n\nCustom coercions may be defined using Deref.\n\nCoercion is transitive.\n\nas\n\nThe as keyword does safe casting:\n\n\nlet x: i32 = 5;\n\nlet y = x as i64;\n\nThere are three major categories of safe cast: explicit coercions, casts between numeric types, and pointer casts.\n\nCasting is not transitive: even if e as U1 as U2 is a valid expression, e as U2 is not necessarily so (in fact it will only be valid if U1 coerces to U2).\n\nExplicit coercions\n\nA cast e as U is valid if e has type T and T coerces to U.\n\nNumeric casts\n\nA cast e as U is also valid in any of the following cases:\n\ne has type T and T and U are any numeric types; numeric-cast\ne is an enum with no data attached to the variants (a \"field-less enumeration\"), and U is an integer type; enum-cast\ne has type bool or char and U is an integer type; prim-int-cast\ne has type u8 and U is char; u8-char-cast\n\nFor example\n\n\nlet one = true as u8;\nlet at_sign = 64 as char;\nlet two_hundred = -56i8 as u8;\n\nThe semantics of numeric casts are:\n\nCasting between two integers of the same size (e.g. i32 -> u32) is a no-op\nCasting from a larger integer to a smaller integer (e.g. u32 -> u8) will truncate\nCasting from a smaller integer to a larger integer (e.g. u8 -> u32) will\nzero-extend if the source is unsigned\nsign-extend if the source is signed\nCasting from a float to an integer will round the float towards zero\nNOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes Inf and NaN. This is a bug and will be fixed.\nCasting from an integer to float will produce the floating point representation of the integer, rounded if necessary (rounding strategy unspecified)\nCasting from an f32 to an f64 is perfect and lossless\nCasting from an f64 to an f32 will produce the closest possible value (rounding strategy unspecified)\nNOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32. This is a bug and will be fixed.\nPointer casts\n\nPerhaps surprisingly, it is safe to cast raw pointers to and from integers, and to cast between pointers to different types subject to some constraints. It is only unsafe to dereference the pointer:\n\n\nlet a = 300 as *const char; // `a` is a pointer to location 300.\nlet b = a as u32;\n\ne as U is a valid pointer cast in any of the following cases:\n\ne has type *T, U has type *U_0, and either U_0: Sized or unsize_kind(T) == unsize_kind(U_0); a ptr-ptr-cast\n\ne has type *T and U is a numeric type, while T: Sized; ptr-addr-cast\n\ne is an integer and U is *U_0, while U_0: Sized; addr-ptr-cast\n\ne has type &[T; n] and U is *const T; array-ptr-cast\n\ne is a function pointer type and U has type *T, while T: Sized; fptr-ptr-cast\n\ne is a function pointer type and U is an integer; fptr-addr-cast\n\ntransmute\n\nas only allows safe casting, and will for example reject an attempt to cast four bytes into a u32:\n\nlet a = [0u8, 0u8, 0u8, 0u8];\n\nlet b = a as u32; // Four u8s makes a u32.\n\n\nThis errors with:\n\nerror: non-scalar cast: `[u8; 4]` as `u32`\nlet b = a as u32; // Four u8s makes a u32.\n        ^~~~~~~~\n\n\nThis is a ‚Äònon-scalar cast‚Äô because we have multiple values here: the four elements of the array. These kinds of casts are very dangerous, because they make assumptions about the way that multiple underlying structures are implemented. For this, we need something more dangerous.\n\nThe transmute function is very simple, but very scary. It tells Rust to treat a value of one type as though it were another type. It does this regardless of the typechecking system, and completely trusts you.\n\nIn our previous example, we know that an array of four u8s represents a u32 properly, and so we want to do the cast. Using transmute instead of as, Rust lets us:\n\nuse std::mem;\n\nfn main() {\n    unsafe {\n        let a = [0u8, 1u8, 0u8, 0u8];\n        let b = mem::transmute::<[u8; 4], u32>(a);\n        println!(\"{}\", b); // 256\n        // Or, more concisely:\n        let c: u32 = mem::transmute(a);\n        println!(\"{}\", c); // 256\n    }\n}\n\n\nWe have to wrap the operation in an unsafe block for this to compile successfully. Technically, only the mem::transmute call itself needs to be in the block, but it's nice in this case to enclose everything related, so you know where to look. In this case, the details about a are also important, and so they're in the block. You'll see code in either style, sometimes the context is too far away, and wrapping all of the code in unsafe isn't a great idea.\n\nWhile transmute does very little checking, it will at least make sure that the types are the same size. This errors:\n\nuse std::mem;\n\nunsafe {\n    let a = [0u8, 0u8, 0u8, 0u8];\n\n    let b = mem::transmute::<[u8; 4], u64>(a);\n}\n\n\nwith:\n\nerror: transmute called with differently sized types: [u8; 4] (32 bits) to u64\n(64 bits)\n\n\nOther than that, you're on your own!\n\nAssociated Types\n\nAssociated types are a powerful part of Rust‚Äôs type system. They‚Äôre related to the idea of a ‚Äòtype family‚Äô, in other words, grouping multiple types together. That description is a bit abstract, so let‚Äôs dive right into an example. If you want to write a Graph trait, you have two types to be generic over: the node type and the edge type. So you might write a trait, Graph<N, E>, that looks like this:\n\n\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    fn edges(&self, &N) -> Vec<E>;\n    // Etc.\n}\n\nWhile this sort of works, it ends up being awkward. For example, any function that wants to take a Graph as a parameter now also needs to be generic over the Node and Edge types too:\n\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n\n\nOur distance calculation works regardless of our Edge type, so the E stuff in this signature is a distraction.\n\nWhat we really want to say is that a certain Edge and Node type come together to form each kind of Graph. We can do that with associated types:\n\n\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n    // Etc.\n}\n\nNow, our clients can be abstract over a given Graph:\n\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> u32 { ... }\n\n\nNo need to deal with the Edge type here!\n\nLet‚Äôs go over all this in more detail.\n\nDefining associated types\n\nLet‚Äôs build that Graph trait. Here‚Äôs the definition:\n\n\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n\nSimple enough. Associated types use the type keyword, and go inside the body of the trait, with the functions.\n\nThese type declarations work the same way as those for functions. For example, if we wanted our N type to implement Display, so we can print the nodes out, we could do this:\n\n\nuse std::fmt;\n\ntrait Graph {\n    type N: fmt::Display;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\nImplementing associated types\n\nJust like any trait, traits that use associated types use the impl keyword to provide implementations. Here‚Äôs a simple implementation of Graph:\n\n\nstruct Node;\n\nstruct Edge;\n\nstruct MyGraph;\n\nimpl Graph for MyGraph {\n    type N = Node;\n    type E = Edge;\n\n    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n        true\n    }\n\n    fn edges(&self, n: &Node) -> Vec<Edge> {\n        Vec::new()\n    }\n}\n\nThis silly implementation always returns true and an empty Vec<Edge>, but it gives you an idea of how to implement this kind of thing. We first need three structs, one for the graph, one for the node, and one for the edge. If it made more sense to use a different type, that would work as well, we‚Äôre going to use structs for all three here.\n\nNext is the impl line, which is an implementation like any other trait.\n\nFrom here, we use = to define our associated types. The name the trait uses goes on the left of the =, and the concrete type we‚Äôre implementing this for goes on the right. Finally, we use the concrete types in our function declarations.\n\nTrait objects with associated types\n\nThere‚Äôs one more bit of syntax we should talk about: trait objects. If you try to create a trait object from a trait with an associated type, like this:\n\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph>;\n\n\nYou‚Äôll get two errors:\n\nerror: the value of the associated type `E` (from the trait `main::Graph`) must\nbe specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24:44 error: the value of the associated type `N` (from the trait\n`main::Graph`) must be specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nWe can‚Äôt create a trait object like this, because we don‚Äôt know the associated types. Instead, we can write this:\n\n\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n\nThe N=Node syntax allows us to provide a concrete type, Node, for the N type parameter. Same with E=Edge. If we didn‚Äôt provide this constraint, we couldn‚Äôt be sure which impl to match this trait object to.\n\nUnsized Types\n\nMost types have a particular size, in bytes, that is knowable at compile time. For example, an i32 is thirty-two bits big, or four bytes. However, there are some types which are useful to express, but do not have a defined size. These are called ‚Äòunsized‚Äô or ‚Äòdynamically sized‚Äô types. One example is [T]. This type represents a certain number of T in sequence. But we don‚Äôt know how many there are, so the size is not known.\n\nRust understands a few of these types, but they have some restrictions. There are three:\n\nWe can only manipulate an instance of an unsized type via a pointer. An &[T] works fine, but a [T] does not.\nVariables and arguments cannot have dynamically sized types.\nOnly the last field in a struct may have a dynamically sized type; the other fields must not. Enum variants must not have dynamically sized types as data.\n\nSo why bother? Well, because [T] can only be used behind a pointer, if we didn‚Äôt have language support for unsized types, it would be impossible to write this:\n\nimpl Foo for str {\n\n\nor\n\nimpl<T> Foo for [T] {\n\n\nInstead, you would have to write:\n\nimpl Foo for &str {\n\n\nMeaning, this implementation would only work for references, and not other types of pointers. With the impl for str, all pointers, including (at some point, there are some bugs to fix first) user-defined custom smart pointers, can use this impl.\n\n?Sized\n\nIf you want to write a function that accepts a dynamically sized type, you can use the special bound syntax, ?Sized:\n\n\nstruct Foo<T: ?Sized> {\n    f: T,\n}\n\nThis ?Sized, read as ‚ÄúT may or may not be Sized‚Äù, which allows us to match both sized and unsized types. All generic type parameters implicitly have the Sized bound, so the ?Sized can be used to opt-out of the implicit bound.\n\nOperators and Overloading\n\nRust allows for a limited form of operator overloading. There are certain operators that are able to be overloaded. To support a particular operator between types, there‚Äôs a specific trait that you can implement, which then overloads the operator.\n\nFor example, the + operator can be overloaded with the Add trait:\n\nuse std::ops::Add;\n\n#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point { x: self.x + other.x, y: self.y + other.y }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 0 };\n    let p2 = Point { x: 2, y: 3 };\n\n    let p3 = p1 + p2;\n\n    println!(\"{:?}\", p3);\n}\n\n\nIn main, we can use + on our two Points, since we‚Äôve implemented Add<Output=Point> for Point.\n\nThere are a number of operators that can be overloaded this way, and all of their associated traits live in the std::ops module. Check out its documentation for the full list.\n\nImplementing these traits follows a pattern. Let‚Äôs look at Add in more detail:\n\n\npub trait Add<RHS = Self> {\n    type Output;\n\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\nThere‚Äôs three types in total involved here: the type you impl Add for, RHS, which defaults to Self, and Output. For an expression let z = x + y, x is the Self type, y is the RHS, and z is the Self::Output type.\n\n\nimpl Add<i32> for Point {\n    type Output = f64;\n\n    fn add(self, rhs: i32) -> f64 {\n        // Add an i32 to a Point and get an f64.\n    }\n}\n\nwill let you do this:\n\nlet p: Point = // ...\nlet x: f64 = p + 2i32;\n\nUsing operator traits in generic structs\n\nNow that we know how operator traits are defined, we can define our HasArea trait and Square struct from the traits chapter more generically:\n\nuse std::ops::Mul;\n\ntrait HasArea<T> {\n    fn area(&self) -> T;\n}\n\nstruct Square<T> {\n    x: T,\n    y: T,\n    side: T,\n}\n\nimpl<T> HasArea<T> for Square<T>\n        where T: Mul<Output=T> + Copy {\n    fn area(&self) -> T {\n        self.side * self.side\n    }\n}\n\nfn main() {\n    let s = Square {\n        x: 0.0f64,\n        y: 0.0f64,\n        side: 12.0f64,\n    };\n\n    println!(\"Area of s: {}\", s.area());\n}\n\n\nFor HasArea and Square, we declare a type parameter T and replace f64 with it. The impl needs more involved modifications:\n\nimpl<T> HasArea<T> for Square<T>\n        where T: Mul<Output=T> + Copy { ... }\n\n\nThe area method requires that we can multiply the sides, so we declare that type T must implement std::ops::Mul. Like Add, mentioned above, Mul itself takes an Output parameter: since we know that numbers don't change type when multiplied, we also set it to T. T must also support copying, so Rust doesn't try to move self.side into the return value.\n\nDeref coercions\n\nThe standard library provides a special trait, Deref. It‚Äôs normally used to overload *, the dereference operator:\n\nuse std::ops::Deref;\n\nstruct DerefExample<T> {\n    value: T,\n}\n\nimpl<T> Deref for DerefExample<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.value\n    }\n}\n\nfn main() {\n    let x = DerefExample { value: 'a' };\n    assert_eq!('a', *x);\n}\n\n\nThis is useful for writing custom pointer types. However, there‚Äôs a language feature related to Deref: ‚Äòderef coercions‚Äô. Here‚Äôs the rule: If you have a type U, and it implements Deref<Target=T>, values of &U will automatically coerce to a &T. Here‚Äôs an example:\n\n\nfn foo(s: &str) {\n    // Borrow a string for a second.\n}\n\n// String implements Deref<Target=str>.\nlet owned = \"Hello\".to_string();\n\n// Therefore, this works:\nfoo(&owned);\n\nUsing an ampersand in front of a value takes a reference to it. So owned is a String, &owned is an &String, and since impl Deref<Target=str> for String, &String will deref to &str, which foo() takes.\n\nThat‚Äôs it. This rule is one of the only places in which Rust does an automatic conversion for you, but it adds a lot of flexibility. For example, the Rc<T> type implements Deref<Target=T>, so this works:\n\n\nuse std::rc::Rc;\n\nfn foo(s: &str) {\n    // Borrow a string for a second.\n}\n\n// String implements Deref<Target=str>.\nlet owned = \"Hello\".to_string();\nlet counted = Rc::new(owned);\n\n// Therefore, this works:\nfoo(&counted);\n\nAll we‚Äôve done is wrap our String in an Rc<T>. But we can now pass the Rc<String> around anywhere we‚Äôd have a String. The signature of foo didn‚Äôt change, but works just as well with either type. This example has two conversions: &Rc<String> to &String and then &String to &str. Rust will do this as many times as possible until the types match.\n\nAnother very common implementation provided by the standard library is:\n\n\nfn foo(s: &[i32]) {\n    // Borrow a slice for a second.\n}\n\n// Vec<T> implements Deref<Target=[T]>.\nlet owned = vec![1, 2, 3];\n\nfoo(&owned);\n\nVectors can Deref to a slice.\n\nDeref and method calls\n\nDeref will also kick in when calling a method. Consider the following example.\n\n\nstruct Foo;\n\nimpl Foo {\n    fn foo(&self) { println!(\"Foo\"); }\n}\n\nlet f = &&Foo;\n\nf.foo();\n\nEven though f is a &&Foo and foo takes &self, this works. That‚Äôs because these things are the same:\n\nf.foo();\n(&f).foo();\n(&&f).foo();\n(&&&&&&&&f).foo();\n\n\nA value of type &&&&&&&&&&&&&&&&Foo can still have methods defined on Foo called, because the compiler will insert as many * operations as necessary to get it right. And since it‚Äôs inserting *s, that uses Deref.\n\nMacros\n\nBy now you‚Äôve learned about many of the tools Rust provides for abstracting and reusing code. These units of code reuse have a rich semantic structure. For example, functions have a type signature, type parameters have trait bounds, and overloaded functions must belong to a particular trait.\n\nThis structure means that Rust‚Äôs core abstractions have powerful compile-time correctness checking. But this comes at the price of reduced flexibility. If you visually identify a pattern of repeated code, you may find it‚Äôs difficult or cumbersome to express that pattern as a generic function, a trait, or anything else within Rust‚Äôs semantics.\n\nMacros allow us to abstract at a syntactic level. A macro invocation is shorthand for an \"expanded\" syntactic form. This expansion happens early in compilation, before any static checking. As a result, macros can capture many patterns of code reuse that Rust‚Äôs core abstractions cannot.\n\nThe drawback is that macro-based code can be harder to understand, because fewer of the built-in rules apply. Like an ordinary function, a well-behaved macro can be used without understanding its implementation. However, it can be difficult to design a well-behaved macro! Additionally, compiler errors in macro code are harder to interpret, because they describe problems in the expanded code, not the source-level form that developers use.\n\nThese drawbacks make macros something of a \"feature of last resort\". That‚Äôs not to say that macros are bad; they are part of Rust because sometimes they‚Äôre needed for truly concise, well-abstracted code. Just keep this tradeoff in mind.\n\nDefining a macro\n\nYou may have seen the vec! macro, used to initialize a vector with any number of elements.\n\n\nlet x: Vec<u32> = vec![1, 2, 3];\n\nThis can‚Äôt be an ordinary function, because it takes any number of arguments. But we can imagine it as syntactic shorthand for\n\n\nlet x: Vec<u32> = {\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n};\n\nWe can implement this shorthand, using a macro: 1\n\n1\n\nThe actual definition of vec! in libcollections differs from the one presented here, for reasons of efficiency and reusability.\n\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n\n\nWhoa, that‚Äôs a lot of new syntax! Let‚Äôs break it down.\n\nmacro_rules! vec { ... }\n\n\nThis says we‚Äôre defining a macro named vec, much as fn vec would define a function named vec. In prose, we informally write a macro‚Äôs name with an exclamation point, e.g. vec!. The exclamation point is part of the invocation syntax and serves to distinguish a macro from an ordinary function.\n\nMatching\n\nThe macro is defined through a series of rules, which are pattern-matching cases. Above, we had\n\n( $( $x:expr ),* ) => { ... };\n\n\nThis is like a match expression arm, but the matching happens on Rust syntax trees, at compile time. The semicolon is optional on the last (here, only) case. The \"pattern\" on the left-hand side of => is known as a ‚Äòmatcher‚Äô. These have their own little grammar within the language.\n\nThe matcher $x:expr will match any Rust expression, binding that syntax tree to the ‚Äòmetavariable‚Äô $x. The identifier expr is a ‚Äòfragment specifier‚Äô; the full possibilities are enumerated later in this chapter. Surrounding the matcher with $(...),* will match zero or more expressions, separated by commas.\n\nAside from the special matcher syntax, any Rust tokens that appear in a matcher must match exactly. For example,\n\nmacro_rules! foo {\n    (x => $e:expr) => (println!(\"mode X: {}\", $e));\n    (y => $e:expr) => (println!(\"mode Y: {}\", $e));\n}\n\nfn main() {\n    foo!(y => 3);\n}\n\n\nwill print\n\nmode Y: 3\n\n\nWith\n\nfoo!(z => 3);\n\n\nwe get the compiler error\n\nerror: no rules expected the token `z`\n\nExpansion\n\nThe right-hand side of a macro rule is ordinary Rust syntax, for the most part. But we can splice in bits of syntax captured by the matcher. From the original example:\n\n$(\n    temp_vec.push($x);\n)*\n\n\nEach matched expression $x will produce a single push statement in the macro expansion. The repetition in the expansion proceeds in \"lockstep\" with repetition in the matcher (more on this in a moment).\n\nBecause $x was already declared as matching an expression, we don‚Äôt repeat :expr on the right-hand side. Also, we don‚Äôt include a separating comma as part of the repetition operator. Instead, we have a terminating semicolon within the repeated block.\n\nAnother detail: the vec! macro has two pairs of braces on the right-hand side. They are often combined like so:\n\nmacro_rules! foo {\n    () => {{\n        ...\n    }}\n}\n\n\nThe outer braces are part of the syntax of macro_rules!. In fact, you can use () or [] instead. They simply delimit the right-hand side as a whole.\n\nThe inner braces are part of the expanded syntax. Remember, the vec! macro is used in an expression context. To write an expression with multiple statements, including let-bindings, we use a block. If your macro expands to a single expression, you don‚Äôt need this extra layer of braces.\n\nNote that we never declared that the macro produces an expression. In fact, this is not determined until we use the macro as an expression. With care, you can write a macro whose expansion works in several contexts. For example, shorthand for a data type could be valid as either an expression or a pattern.\n\nRepetition\n\nThe repetition operator follows two principal rules:\n\n$(...)* walks through one \"layer\" of repetitions, for all of the $names it contains, in lockstep, and\neach $name must be under at least as many $(...)*s as it was matched against. If it is under more, it‚Äôll be duplicated, as appropriate.\n\nThis baroque macro illustrates the duplication of variables from outer repetition levels.\n\nmacro_rules! o_O {\n    (\n        $(\n            $x:expr; [ $( $y:expr ),* ]\n        );*\n    ) => {\n        &[ $($( $x + $y ),*),* ]\n    }\n}\n\nfn main() {\n    let a: &[i32]\n        = o_O!(10; [1, 2, 3];\n               20; [4, 5, 6]);\n\n    assert_eq!(a, [11, 12, 13, 24, 25, 26]);\n}\n\n\nThat‚Äôs most of the matcher syntax. These examples use $(...)*, which is a \"zero or more\" match. Alternatively you can write $(...)+ for a \"one or more\" match. Both forms optionally include a separator, which can be any token except + or *.\n\nThis system is based on \"Macro-by-Example\" (PDF link).\n\nHygiene\n\nSome languages implement macros using simple text substitution, which leads to various problems. For example, this C program prints 13 instead of the expected 25.\n\n#define FIVE_TIMES(x) 5 * x\n\nint main() {\n    printf(\"%d\\n\", FIVE_TIMES(2 + 3));\n    return 0;\n}\n\n\nAfter expansion we have 5 * 2 + 3, and multiplication has greater precedence than addition. If you‚Äôve used C macros a lot, you probably know the standard idioms for avoiding this problem, as well as five or six others. In Rust, we don‚Äôt have to worry about it.\n\nmacro_rules! five_times {\n    ($x:expr) => (5 * $x);\n}\n\nfn main() {\n    assert_eq!(25, five_times!(2 + 3));\n}\n\n\nThe metavariable $x is parsed as a single expression node, and keeps its place in the syntax tree even after substitution.\n\nAnother common problem in macro systems is ‚Äòvariable capture‚Äô. Here‚Äôs a C macro using a block with multiple statements.\n\n#define LOG(msg) do { \\\n    int state = get_log_state(); \\\n    if (state > 0) { \\\n        printf(\"log(%d): %s\\n\", state, msg); \\\n    } \\\n} while (0)\n\n\nHere‚Äôs a simple use case that goes terribly wrong:\n\nconst char *state = \"reticulating splines\";\nLOG(state);\n\n\nThis expands to\n\nconst char *state = \"reticulating splines\";\ndo {\n    int state = get_log_state();\n    if (state > 0) {\n        printf(\"log(%d): %s\\n\", state, state);\n    }\n} while (0);\n\n\nThe second variable named state shadows the first one. This is a problem because the print statement should refer to both of them.\n\nThe equivalent Rust macro has the desired behavior.\n\nmacro_rules! log {\n    ($msg:expr) => {{\n        let state: i32 = get_log_state();\n        if state > 0 {\n            println!(\"log({}): {}\", state, $msg);\n        }\n    }};\n}\n\nfn main() {\n    let state: &str = \"reticulating splines\";\n    log!(state);\n}\n\n\nThis works because Rust has a hygienic macro system. Each macro expansion happens in a distinct ‚Äòsyntax context‚Äô, and each variable is tagged with the syntax context where it was introduced. It‚Äôs as though the variable state inside main is painted a different \"color\" from the variable state inside the macro, and therefore they don‚Äôt conflict.\n\nThis also restricts the ability of macros to introduce new bindings at the invocation site. Code such as the following will not work:\n\nmacro_rules! foo {\n    () => (let x = 3;);\n}\n\nfn main() {\n    foo!();\n    println!(\"{}\", x);\n}\n\n\nInstead you need to pass the variable name into the invocation, so that it‚Äôs tagged with the right syntax context.\n\nmacro_rules! foo {\n    ($v:ident) => (let $v = 3;);\n}\n\nfn main() {\n    foo!(x);\n    println!(\"{}\", x);\n}\n\n\nThis holds for let bindings and loop labels, but not for items. So the following code does compile:\n\nmacro_rules! foo {\n    () => (fn x() { });\n}\n\nfn main() {\n    foo!();\n    x();\n}\n\nRecursive macros\n\nA macro‚Äôs expansion can include more macro invocations, including invocations of the very same macro being expanded. These recursive macros are useful for processing tree-structured input, as illustrated by this (simplistic) HTML shorthand:\n\nmacro_rules! write_html {\n    ($w:expr, ) => (());\n\n    ($w:expr, $e:tt) => (write!($w, \"{}\", $e));\n\n    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{\n        write!($w, \"<{}>\", stringify!($tag));\n        write_html!($w, $($inner)*);\n        write!($w, \"</{}>\", stringify!($tag));\n        write_html!($w, $($rest)*);\n    }};\n}\n\nfn main() {\n    use std::fmt::Write;\n    let mut out = String::new();\n\n    write_html!(&mut out,\n        html[\n            head[title[\"Macros guide\"]]\n            body[h1[\"Macros are the best!\"]]\n        ]);\n\n    assert_eq!(out,\n        \"<html><head><title>Macros guide</title></head>\\\n         <body><h1>Macros are the best!</h1></body></html>\");\n}\n\nDebugging macro code\n\nTo see the results of expanding macros, run rustc --pretty expanded. The output represents a whole crate, so you can also feed it back in to rustc, which will sometimes produce better error messages than the original compilation. Note that the --pretty expanded output may have a different meaning if multiple variables of the same name (but different syntax contexts) are in play in the same scope. In this case --pretty expanded,hygiene will tell you about the syntax contexts.\n\nrustc provides two syntax extensions that help with macro debugging. For now, they are unstable and require feature gates.\n\nlog_syntax!(...) will print its arguments to standard output, at compile time, and \"expand\" to nothing.\n\ntrace_macros!(true) will enable a compiler message every time a macro is expanded. Use trace_macros!(false) later in expansion to turn it off.\n\nSyntactic requirements\n\nEven when Rust code contains un-expanded macros, it can be parsed as a full syntax tree. This property can be very useful for editors and other tools that process code. It also has a few consequences for the design of Rust‚Äôs macro system.\n\nOne consequence is that Rust must determine, when it parses a macro invocation, whether the macro stands in for\n\nzero or more items,\nzero or more methods,\nan expression,\na statement, or\na pattern.\n\nA macro invocation within a block could stand for some items, or for an expression / statement. Rust uses a simple rule to resolve this ambiguity. A macro invocation that stands for items must be either\n\ndelimited by curly braces, e.g. foo! { ... }, or\nterminated by a semicolon, e.g. foo!(...);\n\nAnother consequence of pre-expansion parsing is that the macro invocation must consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces must be balanced within a macro invocation. For example, foo!([) is forbidden. This allows Rust to know where the macro invocation ends.\n\nMore formally, the macro invocation body must be a sequence of ‚Äòtoken trees‚Äô. A token tree is defined recursively as either\n\na sequence of token trees surrounded by matching (), [], or {}, or\nany other single token.\n\nWithin a matcher, each metavariable has a ‚Äòfragment specifier‚Äô, identifying which syntactic form it matches.\n\nident: an identifier. Examples: x; foo.\npath: a qualified name. Example: T::SpecialA.\nexpr: an expression. Examples: 2 + 2; if true { 1 } else { 2 }; f(42).\nty: a type. Examples: i32; Vec<(char, String)>; &T.\npat: a pattern. Examples: Some(t); (17, 'a'); _.\nstmt: a single statement. Example: let x = 3.\nblock: a brace-delimited sequence of statements and optionally an expression. Example: { log(error, \"hi\"); return 12; }.\nitem: an item. Examples: fn foo() { }; struct Bar;.\nmeta: a \"meta item\", as found in attributes. Example: cfg(target_os = \"windows\").\ntt: a single token tree.\n\nThere are additional rules regarding the next token after a metavariable:\n\nexpr and stmt variables may only be followed by one of: => , ;\nty and path variables may only be followed by one of: => , = | ; : > [ { as where\npat variables may only be followed by one of: => , = | if in\nOther variables may be followed by any token.\n\nThese rules provide some flexibility for Rust‚Äôs syntax to evolve without breaking existing macros.\n\nThe macro system does not deal with parse ambiguity at all. For example, the grammar $($i:ident)* $e:expr will always fail to parse, because the parser would be forced to choose between parsing $i and parsing $e. Changing the invocation syntax to put a distinctive token in front can solve the problem. In this case, you can write $(I $i:ident)* E $e:expr.\n\nScoping and macro import/export\n\nMacros are expanded at an early stage in compilation, before name resolution. One downside is that scoping works differently for macros, compared to other constructs in the language.\n\nDefinition and expansion of macros both happen in a single depth-first, lexical-order traversal of a crate‚Äôs source. So a macro defined at module scope is visible to any subsequent code in the same module, which includes the body of any subsequent child mod items. If you want to use your macro, which is defined in a different module, you need to use macro_use attribute before using the macro. Let's say our macros are defined in module macros and we would like to use them inside module client. This is the required module definition order:\n\n\n#[macro_use]\nmod macros;\nmod client;\n\nThe opposite order would result in a compilation failure:\n\n\nmod client;\n#[macro_use]\nmod macros;\nerror: cannot find macro `my_macro!` in this scope\n\n\nA macro defined within the body of a single fn, or anywhere else not at module scope, is visible only within that item.\n\nIf a module has the macro_use attribute, its macros are also visible in its parent module after the child‚Äôs mod item. If the parent also has macro_use then the macros will be visible in the grandparent after the parent‚Äôs mod item, and so forth.\n\nThe macro_use attribute can also appear on extern crate. In this context it controls which macros are loaded from the external crate, e.g.\n\n#[macro_use(foo, bar)]\nextern crate baz;\n\n\nIf the attribute is given simply as #[macro_use], all macros are loaded. If there is no #[macro_use] attribute then no macros are loaded. Only macros defined with the #[macro_export] attribute may be loaded.\n\nTo load a crate‚Äôs macros without linking it into the output, use #[no_link] as well.\n\nAn example:\n\nmacro_rules! m1 { () => (()) }\n\n// Visible here: `m1`.\n\nmod foo {\n    // Visible here: `m1`.\n\n    #[macro_export]\n    macro_rules! m2 { () => (()) }\n\n    // Visible here: `m1`, `m2`.\n}\n\n// Visible here: `m1`.\n\nmacro_rules! m3 { () => (()) }\n\n// Visible here: `m1`, `m3`.\n\n#[macro_use]\nmod bar {\n    // Visible here: `m1`, `m3`.\n\n    macro_rules! m4 { () => (()) }\n\n    // Visible here: `m1`, `m3`, `m4`.\n}\n\n// Visible here: `m1`, `m3`, `m4`.\n\n\nWhen this library is loaded with #[macro_use] extern crate, only m2 will be imported.\n\nThe Rust Reference has a listing of macro-related attributes.\n\nThe variable $crate\n\nA further difficulty occurs when a macro is used in multiple crates. Say that mylib defines\n\npub fn increment(x: u32) -> u32 {\n    x + 1\n}\n\n#[macro_export]\nmacro_rules! inc_a {\n    ($x:expr) => ( ::increment($x) )\n}\n\n#[macro_export]\nmacro_rules! inc_b {\n    ($x:expr) => ( ::mylib::increment($x) )\n}\n\n\ninc_a only works within mylib, while inc_b only works outside the library. Furthermore, inc_b will break if the user imports mylib under another name.\n\nRust does not (yet) have a hygiene system for crate references, but it does provide a simple workaround for this problem. Within a macro imported from a crate named foo, the special macro variable $crate will expand to ::foo. By contrast, when a macro is defined and then used in the same crate, $crate will expand to nothing. This means we can write\n\n#[macro_export]\nmacro_rules! inc {\n    ($x:expr) => ( $crate::increment($x) )\n}\n\n\nto define a single macro that works both inside and outside our library. The function name will expand to either ::increment or ::mylib::increment.\n\nTo keep this system simple and correct, #[macro_use] extern crate ... may only appear at the root of your crate, not inside mod.\n\nThe deep end\n\nThe introductory chapter mentioned recursive macros, but it did not give the full story. Recursive macros are useful for another reason: Each recursive invocation gives you another opportunity to pattern-match the macro‚Äôs arguments.\n\nAs an extreme example, it is possible, though hardly advisable, to implement the Bitwise Cyclic Tag automaton within Rust‚Äôs macro system.\n\n\nmacro_rules! bct {\n    // cmd 0:  d ... => ...\n    (0, $($ps:tt),* ; $_d:tt)\n        => (bct!($($ps),*, 0 ; ));\n    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n        => (bct!($($ps),*, 0 ; $($ds),*));\n\n    // cmd 1p:  1 ... => 1 ... p\n    (1, $p:tt, $($ps:tt),* ; 1)\n        => (bct!($($ps),*, 1, $p ; 1, $p));\n    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n\n    // cmd 1p:  0 ... => 0 ...\n    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n        => (bct!($($ps),*, 1, $p ; $($ds),*));\n\n    // Halt on empty data string:\n    ( $($ps:tt),* ; )\n        => (());\n}\n\nExercise: use macros to reduce duplication in the above definition of the bct! macro.\n\nCommon macros\n\nHere are some common macros you‚Äôll see in Rust code.\n\npanic!\n\nThis macro causes the current thread to panic. You can give it a message to panic with:\n\n\npanic!(\"oh no!\");\nvec!\n\nThe vec! macro is used throughout the book, so you‚Äôve probably seen it already. It creates Vec<T>s with ease:\n\n\nlet v = vec![1, 2, 3, 4, 5];\n\nIt also lets you make vectors with repeating values. For example, a hundred zeroes:\n\n\nlet v = vec![0; 100];\nassert! and assert_eq!\n\nThese two macros are used in tests. assert! takes a boolean. assert_eq! takes two values and checks them for equality. true passes, false panic!s. Like this:\n\n\n// A-ok!\n\nassert!(true);\nassert_eq!(5, 3 + 2);\n\n// Nope :(\n\nassert!(5 < 3);\nassert_eq!(5, 3);\ntry!\n\ntry! is used for error handling. It takes something that can return a Result<T, E>, and gives T if it‚Äôs a Ok<T>, and returns with the Err(E) if it‚Äôs that. Like this:\n\n\nuse std::fs::File;\n\nfn foo() -> std::io::Result<()> {\n    let f = try!(File::create(\"foo.txt\"));\n\n    Ok(())\n}\n\nThis is cleaner than doing this:\n\n\nuse std::fs::File;\n\nfn foo() -> std::io::Result<()> {\n    let f = File::create(\"foo.txt\");\n\n    let f = match f {\n        Ok(t) => t,\n        Err(e) => return Err(e),\n    };\n\n    Ok(())\n}\nunreachable!\n\nThis macro is used when you think some code should never execute:\n\n\nif false {\n    unreachable!();\n}\n\nSometimes, the compiler may make you have a different branch that you know will never, ever run. In these cases, use this macro, so that if you end up wrong, you‚Äôll get a panic! about it.\n\n\nlet x: Option<i32> = None;\n\nmatch x {\n    Some(_) => unreachable!(),\n    None => println!(\"I know x is None!\"),\n}\nunimplemented!\n\nThe unimplemented! macro can be used when you‚Äôre trying to get your functions to typecheck, and don‚Äôt want to worry about writing out the body of the function. One example of this situation is implementing a trait with multiple required methods, where you want to tackle one at a time. Define the others as unimplemented! until you‚Äôre ready to write them.\n\nRaw Pointers\n\nRust has a number of different smart pointer types in its standard library, but there are two types that are extra-special. Much of Rust‚Äôs safety comes from compile-time checks, but raw pointers don‚Äôt have such guarantees, and are unsafe to use.\n\n*const T and *mut T are called ‚Äòraw pointers‚Äô in Rust. Sometimes, when writing certain kinds of libraries, you‚Äôll need to get around Rust‚Äôs safety guarantees for some reason. In this case, you can use raw pointers to implement your library, while exposing a safe interface for your users. For example, * pointers are allowed to alias, allowing them to be used to write shared-ownership types, and even thread-safe shared memory types (the Rc<T> and Arc<T> types are both implemented entirely in Rust).\n\nHere are some things to remember about raw pointers that are different than other pointer types. They:\n\nare not guaranteed to point to valid memory and are not even guaranteed to be non-NULL (unlike both Box and &);\ndo not have any automatic clean-up, unlike Box, and so require manual resource management;\nare plain-old-data, that is, they don't move ownership, again unlike Box, hence the Rust compiler cannot protect against bugs like use-after-free;\nlack any form of lifetimes, unlike &, and so the compiler cannot reason about dangling pointers; and\nhave no guarantees about aliasing or mutability other than mutation not being allowed directly through a *const T.\nBasics\n\nCreating a raw pointer is perfectly safe:\n\n\nlet x = 5;\nlet raw = &x as *const i32;\n\nlet mut y = 10;\nlet raw_mut = &mut y as *mut i32;\n\nHowever, dereferencing one is not. This won‚Äôt work:\n\nlet x = 5;\nlet raw = &x as *const i32;\n\nprintln!(\"raw points at {}\", *raw);\n\n\nIt gives this error:\n\nerror: dereference of raw pointer requires unsafe function or block [E0133]\n     println!(\"raw points at {}\", *raw);\n                                  ^~~~\n\n\nWhen you dereference a raw pointer, you‚Äôre taking responsibility that it‚Äôs not pointing somewhere that would be incorrect. As such, you need unsafe:\n\n\nlet x = 5;\nlet raw = &x as *const i32;\n\nlet points_at = unsafe { *raw };\n\nprintln!(\"raw points at {}\", points_at);\n\nFor more operations on raw pointers, see their API documentation.\n\nFFI\n\nRaw pointers are useful for FFI: Rust‚Äôs *const T and *mut T are similar to C‚Äôs const T* and T*, respectively. For more about this use, consult the FFI chapter.\n\nReferences and raw pointers\n\nAt runtime, a raw pointer * and a reference pointing to the same piece of data have an identical representation. In fact, an &T reference will implicitly coerce to an *const T raw pointer in safe code and similarly for the mut variants (both coercions can be performed explicitly with, respectively, value as *const T and value as *mut T).\n\nGoing the opposite direction, from *const to a reference &, is not safe. A &T is always valid, and so, at a minimum, the raw pointer *const T has to point to a valid instance of type T. Furthermore, the resulting pointer must satisfy the aliasing and mutability laws of references. The compiler assumes these properties are true for any references, no matter how they are created, and so any conversion from raw pointers is asserting that they hold. The programmer must guarantee this.\n\nThe recommended method for the conversion is:\n\n\n// Explicit cast:\nlet i: u32 = 1;\nlet p_imm: *const u32 = &i as *const u32;\n\n// Implicit coercion:\nlet mut m: u32 = 2;\nlet p_mut: *mut u32 = &mut m;\n\nunsafe {\n    let ref_imm: &u32 = &*p_imm;\n    let ref_mut: &mut u32 = &mut *p_mut;\n}\n\nThe &*x dereferencing style is preferred to using a transmute. The latter is far more powerful than necessary, and the more restricted operation is harder to use incorrectly; for example, it requires that x is a pointer (unlike transmute).\n\nUnsafe\n\nRust‚Äôs main draw is its powerful static guarantees about behavior. But safety checks are conservative by nature: there are some programs that are actually safe, but the compiler is not able to verify this is true. To write these kinds of programs, we need to tell the compiler to relax its restrictions a bit. For this, Rust has a keyword, unsafe. Code using unsafe has fewer restrictions than normal code does.\n\nLet‚Äôs go over the syntax, and then we‚Äôll talk semantics. unsafe is used in four contexts. The first one is to mark a function as unsafe:\n\n\nunsafe fn danger_will_robinson() {\n    // Scary stuff...\n}\n\nAll functions called from FFI must be marked as unsafe, for example. The second use of unsafe is an unsafe block:\n\n\nunsafe {\n    // Scary stuff...\n}\n\nThe third is for unsafe traits:\n\n\nunsafe trait Scary { }\n\nAnd the fourth is for implementing one of those traits:\n\n\nunsafe impl Scary for i32 {}\n\nIt‚Äôs important to be able to explicitly delineate code that may have bugs that cause big problems. If a Rust program segfaults, you can be sure the cause is related to something marked unsafe.\n\nWhat does ‚Äòsafe‚Äô mean?\n\nSafe, in the context of Rust, means ‚Äòdoesn‚Äôt do anything unsafe‚Äô. It‚Äôs also important to know that there are certain behaviors that are probably not desirable in your code, but are expressly not unsafe:\n\nDeadlocks\nLeaks of memory or other resources\nExiting without calling destructors\nInteger overflow\n\nRust cannot prevent all kinds of software problems. Buggy code can and will be written in Rust. These things aren‚Äôt great, but they don‚Äôt qualify as unsafe specifically.\n\nIn addition, the following are all undefined behaviors in Rust, and must be avoided, even when writing unsafe code:\n\nData races\nDereferencing a NULL/dangling raw pointer\nReads of undef (uninitialized) memory\nBreaking the pointer aliasing rules with raw pointers.\n&mut T and &T follow LLVM‚Äôs scoped noalias model, except if the &T contains an UnsafeCell<U>. Unsafe code must not violate these aliasing guarantees.\nMutating an immutable value/reference without UnsafeCell<U>\nInvoking undefined behavior via compiler intrinsics:\nIndexing outside of the bounds of an object with std::ptr::offset (offset intrinsic), with the exception of one byte past the end which is permitted.\nUsing std::ptr::copy_nonoverlapping_memory (memcpy32/memcpy64 intrinsics) on overlapping buffers\nInvalid values in primitive types, even in private fields/locals:\nNULL/dangling references or boxes\nA value other than false (0) or true (1) in a bool\nA discriminant in an enum not included in its type definition\nA value in a char which is a surrogate or above char::MAX\nNon-UTF-8 byte sequences in a str\nUnwinding into Rust from foreign code or unwinding from Rust into foreign code.\nUnsafe Superpowers\n\nIn both unsafe functions and unsafe blocks, Rust will let you do three things that you normally can not do. Just three. Here they are:\n\nAccess or update a static mutable variable.\nDereference a raw pointer.\nCall unsafe functions. This is the most powerful ability.\n\nThat‚Äôs it. It‚Äôs important that unsafe does not, for example, ‚Äòturn off the borrow checker‚Äô. Adding unsafe to some random Rust code doesn‚Äôt change its semantics, it won‚Äôt start accepting anything. But it will let you write things that do break some of the rules.\n\nYou will also encounter the unsafe keyword when writing bindings to foreign (non-Rust) interfaces. You're encouraged to write a safe, native Rust interface around the methods provided by the library.\n\nLet‚Äôs go over the basic three abilities listed, in order.\n\nAccess or update a static mut\n\nRust has a feature called ‚Äòstatic mut‚Äô which allows for mutable global state. Doing so can cause a data race, and as such is inherently not safe. For more details, see the static section of the book.\n\nDereference a raw pointer\n\nRaw pointers let you do arbitrary pointer arithmetic, and can cause a number of different memory safety and security issues. In some senses, the ability to dereference an arbitrary pointer is one of the most dangerous things you can do. For more on raw pointers, see their section of the book.\n\nCall unsafe functions\n\nThis last ability works with both aspects of unsafe: you can only call functions marked unsafe from inside an unsafe block.\n\nThis ability is powerful and varied. Rust exposes some compiler intrinsics as unsafe functions, and some unsafe functions bypass safety checks, trading safety for speed.\n\nI‚Äôll repeat again: even though you can do arbitrary things in unsafe blocks and functions doesn‚Äôt mean you should. The compiler will act as though you‚Äôre upholding its invariants, so be careful!\n\nEffective Rust\n\nSo you‚Äôve learned how to write some Rust code. But there‚Äôs a difference between writing any Rust code and writing good Rust code.\n\nThis chapter consists of relatively independent tutorials which show you how to take your Rust to the next level. Common patterns and standard library features will be introduced. Read these sections in any order of your choosing.\n\nThe Stack and the Heap\n\nAs a systems language, Rust operates at a low level. If you‚Äôre coming from a high-level language, there are some aspects of systems programming that you may not be familiar with. The most important one is how memory works, with a stack and a heap. If you‚Äôre familiar with how C-like languages use stack allocation, this chapter will be a refresher. If you‚Äôre not, you‚Äôll learn about this more general concept, but with a Rust-y focus.\n\nAs with most things, when learning about them, we‚Äôll use a simplified model to start. This lets you get a handle on the basics, without getting bogged down with details which are, for now, irrelevant. The examples we‚Äôll use aren‚Äôt 100% accurate, but are representative for the level we‚Äôre trying to learn at right now. Once you have the basics down, learning more about how allocators are implemented, virtual memory, and other advanced topics will reveal the leaks in this particular abstraction.\n\nMemory management\n\nThese two terms are about memory management. The stack and the heap are abstractions that help you determine when to allocate and deallocate memory.\n\nHere‚Äôs a high-level comparison:\n\nThe stack is very fast, and is where memory is allocated in Rust by default. But the allocation is local to a function call, and is limited in size. The heap, on the other hand, is slower, and is explicitly allocated by your program. But it‚Äôs effectively unlimited in size, and is globally accessible. Note this meaning of heap, which allocates arbitrary-sized blocks of memory in arbitrary order, is quite different from the heap data structure.\n\nThe Stack\n\nLet‚Äôs talk about this Rust program:\n\nfn main() {\n    let x = 42;\n}\n\n\nThis program has one variable binding, x. This memory needs to be allocated from somewhere. Rust ‚Äòstack allocates‚Äô by default, which means that basic values ‚Äògo on the stack‚Äô. What does that mean?\n\nWell, when a function gets called, some memory gets allocated for all of its local variables and some other information. This is called a ‚Äòstack frame‚Äô, and for the purpose of this tutorial, we‚Äôre going to ignore the extra information and only consider the local variables we‚Äôre allocating. So in this case, when main() is run, we‚Äôll allocate a single 32-bit integer for our stack frame. This is automatically handled for you, as you can see; we didn‚Äôt have to write any special Rust code or anything.\n\nWhen the function exits, its stack frame gets deallocated. This happens automatically as well.\n\nThat‚Äôs all there is for this simple program. The key thing to understand here is that stack allocation is very, very fast. Since we know all the local variables we have ahead of time, we can grab the memory all at once. And since we‚Äôll throw them all away at the same time as well, we can get rid of it very fast too.\n\nThe downside is that we can‚Äôt keep values around if we need them for longer than a single function. We also haven‚Äôt talked about what the word, ‚Äòstack‚Äô, means. To do that, we need a slightly more complicated example:\n\nfn foo() {\n    let y = 5;\n    let z = 100;\n}\n\nfn main() {\n    let x = 42;\n\n    foo();\n}\n\n\nThis program has three variables total: two in foo(), one in main(). Just as before, when main() is called, a single integer is allocated for its stack frame. But before we can show what happens when foo() is called, we need to visualize what‚Äôs going on with memory. Your operating system presents a view of memory to your program that‚Äôs pretty simple: a huge list of addresses, from 0 to a large number, representing how much RAM your computer has. For example, if you have a gigabyte of RAM, your addresses go from 0 to 1,073,741,823. That number comes from 230, the number of bytes in a gigabyte. 1\n\n1\n\n‚ÄòGigabyte‚Äô can mean two things: 109, or 230. The IEC standard resolved this by stating that ‚Äògigabyte‚Äô is 109, and ‚Äògibibyte‚Äô is 230. However, very few people use this terminology, and rely on context to differentiate. We follow in that tradition here.\n\nThis memory is kind of like a giant array: addresses start at zero and go up to the final number. So here‚Äôs a diagram of our first stack frame:\n\nAddress\tName\tValue\n0\tx\t42\n\nWe‚Äôve got x located at address 0, with the value 42.\n\nWhen foo() is called, a new stack frame is allocated:\n\nAddress\tName\tValue\n2\tz\t100\n1\ty\t5\n0\tx\t42\n\nBecause 0 was taken by the first frame, 1 and 2 are used for foo()‚Äôs stack frame. It grows upward, the more functions we call. Notice that we are not taking into account the size of each variable (for example, a 32 bit variable would use the memory addresses from 0 to 3, or 4 bytes).\n\nThere are some important things we have to take note of here. The numbers 0, 1, and 2 are all solely for illustrative purposes, and bear no relationship to the address values the computer will use in reality. In particular, the series of addresses are in reality going to be separated by some number of bytes that separate each address, and that separation may even exceed the size of the value being stored.\n\nAfter foo() is over, its frame is deallocated:\n\nAddress\tName\tValue\n0\tx\t42\n\nAnd then, after main(), even this last value goes away. Easy!\n\nIt‚Äôs called a ‚Äòstack‚Äô because it works like a stack of dinner plates: the first plate you put down is the last plate to pick back up. Stacks are sometimes called ‚Äòlast in, first out queues‚Äô for this reason, as the last value you put on the stack is the first one you retrieve from it.\n\nLet‚Äôs try a three-deep example:\n\nfn italic() {\n    let i = 6;\n}\n\nfn bold() {\n    let a = 5;\n    let b = 100;\n    let c = 1;\n\n    italic();\n}\n\nfn main() {\n    let x = 42;\n\n    bold();\n}\n\n\nWe have some kooky function names to make the diagrams clearer.\n\nOkay, first, we call main():\n\nAddress\tName\tValue\n0\tx\t42\n\nNext up, main() calls bold():\n\nAddress\tName\tValue\n3\tc\t1\n2\tb\t100\n1\ta\t5\n0\tx\t42\n\nAnd then bold() calls italic():\n\nAddress\tName\tValue\n4\ti\t6\n3\tc\t1\n2\tb\t100\n1\ta\t5\n0\tx\t42\n\nWhew! Our stack is growing tall.\n\nAfter italic() is over, its frame is deallocated, leaving only bold() and main():\n\nAddress\tName\tValue\n3\tc\t1\n2\tb\t100\n1\ta\t5\n0\tx\t42\n\nAnd then bold() ends, leaving only main():\n\nAddress\tName\tValue\n0\tx\t42\n\nAnd then we‚Äôre done. Getting the hang of it? It‚Äôs like piling up dishes: you add to the top, you take away from the top.\n\nThe Heap\n\nNow, this works pretty well, but not everything can work like this. Sometimes, you need to pass some memory between different functions, or keep it alive for longer than a single function‚Äôs execution. For this, we can use the heap.\n\nIn Rust, you can allocate memory on the heap with the Box<T> type. Here‚Äôs an example:\n\nfn main() {\n    let x = Box::new(5);\n    let y = 42;\n}\n\n\nHere‚Äôs what happens in memory when main() is called:\n\nAddress\tName\tValue\n1\ty\t42\n0\tx\t??????\n\nWe allocate space for two variables on the stack. y is 42, as it always has been, but what about x? Well, x is a Box<i32>, and boxes allocate memory on the heap. The actual value of the box is a structure which has a pointer to ‚Äòthe heap‚Äô. When we start executing the function, and Box::new() is called, it allocates some memory for the heap, and puts 5 there. The memory now looks like this:\n\nAddress\tName\tValue\n(230) - 1\t\t5\n...\t...\t...\n1\ty\t42\n0\tx\t‚Üí (230) - 1\n\nWe have (230) addresses in our hypothetical computer with 1GB of RAM. And since our stack grows from zero, the easiest place to allocate memory is from the other end. So our first value is at the highest place in memory. And the value of the struct at x has a raw pointer to the place we‚Äôve allocated on the heap, so the value of x is (230) - 1, the memory location we‚Äôve asked for.\n\nWe haven‚Äôt really talked too much about what it actually means to allocate and deallocate memory in these contexts. Getting into very deep detail is out of the scope of this tutorial, but what‚Äôs important to point out here is that the heap isn‚Äôt a stack that grows from the opposite end. We‚Äôll have an example of this later in the book, but because the heap can be allocated and freed in any order, it can end up with ‚Äòholes‚Äô. Here‚Äôs a diagram of the memory layout of a program which has been running for a while now:\n\nAddress\tName\tValue\n(230) - 1\t\t5\n(230) - 2\t\t\n(230) - 3\t\t\n(230) - 4\t\t42\n...\t...\t...\n2\tz\t‚Üí (230) - 4\n1\ty\t42\n0\tx\t‚Üí (230) - 1\n\nIn this case, we‚Äôve allocated four things on the heap, but deallocated two of them. There‚Äôs a gap between (230) - 1 and (230) - 4 which isn‚Äôt currently being used. The specific details of how and why this happens depends on what kind of strategy you use to manage the heap. Different programs can use different ‚Äòmemory allocators‚Äô, which are libraries that manage this for you. Rust programs use jemalloc for this purpose.\n\nAnyway, back to our example. Since this memory is on the heap, it can stay alive longer than the function which allocates the box. In this case, however, it doesn‚Äôt.2 When the function is over, we need to free the stack frame for main(). Box<T>, though, has a trick up its sleeve: Drop. The implementation of Drop for Box deallocates the memory that was allocated when it was created. Great! So when x goes away, it first frees the memory allocated on the heap:\n\nAddress\tName\tValue\n1\ty\t42\n0\tx\t??????\n2\n\nWe can make the memory live longer by transferring ownership, sometimes called ‚Äòmoving out of the box‚Äô. More complex examples will be covered later.\n\nAnd then the stack frame goes away, freeing all of our memory.\n\nArguments and borrowing\n\nWe‚Äôve got some basic examples with the stack and the heap going, but what about function arguments and borrowing? Here‚Äôs a small Rust program:\n\nfn foo(i: &i32) {\n    let z = 42;\n}\n\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    foo(y);\n}\n\n\nWhen we enter main(), memory looks like this:\n\nAddress\tName\tValue\n1\ty\t‚Üí 0\n0\tx\t5\n\nx is a plain old 5, and y is a reference to x. So its value is the memory location that x lives at, which in this case is 0.\n\nWhat about when we call foo(), passing y as an argument?\n\nAddress\tName\tValue\n3\tz\t42\n2\ti\t‚Üí 0\n1\ty\t‚Üí 0\n0\tx\t5\n\nStack frames aren‚Äôt only for local bindings, they‚Äôre for arguments too. So in this case, we need to have both i, our argument, and z, our local variable binding. i is a copy of the argument, y. Since y‚Äôs value is 0, so is i‚Äôs.\n\nThis is one reason why borrowing a variable doesn‚Äôt deallocate any memory: the value of a reference is a pointer to a memory location. If we got rid of the underlying memory, things wouldn‚Äôt work very well.\n\nA complex example\n\nOkay, let‚Äôs go through this complex program step-by-step:\n\nfn foo(x: &i32) {\n    let y = 10;\n    let z = &y;\n\n    baz(z);\n    bar(x, z);\n}\n\nfn bar(a: &i32, b: &i32) {\n    let c = 5;\n    let d = Box::new(5);\n    let e = &d;\n\n    baz(e);\n}\n\nfn baz(f: &i32) {\n    let g = 100;\n}\n\nfn main() {\n    let h = 3;\n    let i = Box::new(20);\n    let j = &h;\n\n    foo(j);\n}\n\n\nFirst, we call main():\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWe allocate memory for j, i, and h. i is on the heap, and so has a value pointing there.\n\nNext, at the end of main(), foo() gets called:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nSpace gets allocated for x, y, and z. The argument x has the same value as j, since that‚Äôs what we passed it in. It‚Äôs a pointer to the 0 address, since j points at h.\n\nNext, foo() calls baz(), passing z:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n7\tg\t100\n6\tf\t‚Üí 4\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWe‚Äôve allocated memory for f and g. baz() is very short, so when it‚Äôs over, we get rid of its stack frame:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nNext, foo() calls bar() with x and z:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n(230) - 2\t\t5\n...\t...\t...\n10\te\t‚Üí 9\n9\td\t‚Üí (230) - 2\n8\tc\t5\n7\tb\t‚Üí 4\n6\ta\t‚Üí 0\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWe end up allocating another value on the heap, and so we have to subtract one from (230) - 1. It‚Äôs easier to write that than 1,073,741,822. In any case, we set up the variables as usual.\n\nAt the end of bar(), it calls baz():\n\nAddress\tName\tValue\n(230) - 1\t\t20\n(230) - 2\t\t5\n...\t...\t...\n12\tg\t100\n11\tf\t‚Üí (230) - 2\n10\te\t‚Üí 9\n9\td\t‚Üí (230) - 2\n8\tc\t5\n7\tb\t‚Üí 4\n6\ta\t‚Üí 0\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWith this, we‚Äôre at our deepest point! Whew! Congrats for following along this far.\n\nAfter baz() is over, we get rid of f and g:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n(230) - 2\t\t5\n...\t...\t...\n10\te\t‚Üí 9\n9\td\t‚Üí (230) - 2\n8\tc\t5\n7\tb\t‚Üí 4\n6\ta\t‚Üí 0\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nNext, we return from bar(). d in this case is a Box<T>, so it also frees what it points to: (230) - 2.\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nAnd after that, foo() returns:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nAnd then, finally, main(), which cleans the rest up. When i is Dropped, it will clean up the last of the heap too.\n\nWhat do other languages do?\n\nMost languages with a garbage collector heap-allocate by default. This means that every value is boxed. There are a number of reasons why this is done, but they‚Äôre out of scope for this tutorial. There are some possible optimizations that don‚Äôt make it true 100% of the time, too. Rather than relying on the stack and Drop to clean up memory, the garbage collector deals with the heap instead.\n\nWhich to use?\n\nSo if the stack is faster and easier to manage, why do we need the heap? A big reason is that Stack-allocation alone means you only have 'Last In First Out (LIFO)' semantics for reclaiming storage. Heap-allocation is strictly more general, allowing storage to be taken from and returned to the pool in arbitrary order, but at a complexity cost.\n\nGenerally, you should prefer stack allocation, and so, Rust stack-allocates by default. The LIFO model of the stack is simpler, at a fundamental level. This has two big impacts: runtime efficiency and semantic impact.\n\nRuntime Efficiency\n\nManaging the memory for the stack is trivial: The machine increments or decrements a single value, the so-called ‚Äústack pointer‚Äù. Managing memory for the heap is non-trivial: heap-allocated memory is freed at arbitrary points, and each block of heap-allocated memory can be of arbitrary size, so the memory manager must generally work much harder to identify memory for reuse.\n\nIf you‚Äôd like to dive into this topic in greater detail, this paper is a great introduction.\n\nSemantic impact\n\nStack-allocation impacts the Rust language itself, and thus the developer‚Äôs mental model. The LIFO semantics is what drives how the Rust language handles automatic memory management. Even the deallocation of a uniquely-owned heap-allocated box can be driven by the stack-based LIFO semantics, as discussed throughout this chapter. The flexibility (i.e. expressiveness) of non LIFO-semantics means that in general the compiler cannot automatically infer at compile-time where memory should be freed; it has to rely on dynamic protocols, potentially from outside the language itself, to drive deallocation (reference counting, as used by Rc<T> and Arc<T>, is one example of this).\n\nWhen taken to the extreme, the increased expressive power of heap allocation comes at the cost of either significant runtime support (e.g. in the form of a garbage collector) or significant programmer effort (in the form of explicit memory management calls that require verification not provided by the Rust compiler).\n\nTesting\n\nProgram testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.\n\nEdsger W. Dijkstra, \"The Humble Programmer\" (1972)\n\nLet's talk about how to test Rust code. What we will not be talking about is the right way to test Rust code. There are many schools of thought regarding the right and wrong way to write tests. All of these approaches use the same basic tools, and so we'll show you the syntax for using them.\n\nThe test attribute\n\nAt its simplest, a test in Rust is a function that's annotated with the test attribute. Let's make a new project with Cargo called adder:\n\n$ cargo new adder\n$ cd adder\n\n\nCargo will automatically generate a simple test when you make a new project. Here's the contents of src/lib.rs:\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n    }\n}\n\n\nFor now, let's remove the mod bit, and focus on just the function:\n\n#[test]\nfn it_works() {\n}\n\n\nNote the #[test]. This attribute indicates that this is a test function. It currently has no body. That's good enough to pass! We can run the tests with cargo test:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.15 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nCargo compiled and ran our tests. There are two sets of output here: one for the test we wrote, and another for documentation tests. We'll talk about those later. For now, see this line:\n\ntest it_works ... ok\n\n\nNote the it_works. This comes from the name of our function:\n\nfn it_works() {\n}\n\n\nWe also get a summary line:\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n\nSo why does our do-nothing test pass? Any test which doesn't panic! passes, and any test that does panic! fails. Let's make our test fail:\n\n#[test]\nfn it_works() {\n    assert!(false);\n}\n\n\nassert! is a macro provided by Rust which takes one argument: if the argument is true, nothing happens. If the argument is false, it will panic!. Let's run our tests again:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... FAILED\n\nfailures:\n\n---- it_works stdout ----\n        thread 'it_works' panicked at 'assertion failed: false', src/lib.rs:5\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\n\nfailures:\n    it_works\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n\nerror: test failed\n\n\nRust indicates that our test failed:\n\ntest it_works ... FAILED\n\n\nAnd that's reflected in the summary line:\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n\n\nWe also get a non-zero status code. We can use $? on macOS and Linux:\n\n$ echo $?\n101\n\n\nOn Windows, if you‚Äôre using cmd:\n\n> echo %ERRORLEVEL%\n\n\nAnd if you‚Äôre using PowerShell:\n\n> echo $LASTEXITCODE # the code itself\n> echo $? # a boolean, fail or succeed\n\n\nThis is useful if you want to integrate cargo test into other tooling.\n\nWe can invert our test's failure with another attribute: should_panic:\n\n#[test]\n#[should_panic]\nfn it_works() {\n    assert!(false);\n}\n\n\nThis test will now succeed if we panic! and fail if we complete. Let's try it:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nRust provides another macro, assert_eq!, that compares two arguments for equality:\n\n#[test]\n#[should_panic]\nfn it_works() {\n    assert_eq!(\"Hello\", \"world\");\n}\n\n\nDoes this test pass or fail? Because of the should_panic attribute, it passes:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.21 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nshould_panic tests can be fragile, as it's hard to guarantee that the test didn't fail for an unexpected reason. To help with this, an optional expected parameter can be added to the should_panic attribute. The test harness will make sure that the failure message contains the provided text. A safer version of the example above would be:\n\n#[test]\n#[should_panic(expected = \"assertion failed\")]\nfn it_works() {\n    assert_eq!(\"Hello\", \"world\");\n}\n\n\nThat's all there is to the basics! Let's write one 'real' test:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[test]\nfn it_works() {\n    assert_eq!(4, add_two(2));\n}\n\n\nThis is a very common use of assert_eq!: call some function with some known arguments and compare it to the expected output.\n\nThe ignore attribute\n\nSometimes a few specific tests can be very time-consuming to execute. These can be disabled by default by using the ignore attribute:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[test]\nfn it_works() {\n    assert_eq!(4, add_two(2));\n}\n\n#[test]\n#[ignore]\nfn expensive_test() {\n    // Code that takes an hour to run...\n}\n\n\nNow we run our tests and see that it_works is run, but expensive_test is not:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.20 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 2 tests\ntest expensive_test ... ignored\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nThe expensive tests can be run explicitly using cargo test -- --ignored:\n\n$ cargo test -- --ignored\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest expensive_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nThe --ignored argument is an argument to the test binary, and not to Cargo, which is why the command is cargo test -- --ignored.\n\nThe tests module\n\nThere is one way in which our existing example is not idiomatic: it's missing the tests module. You might have noticed this test module was present in the code that was initially generated with cargo new but was missing from our last example. Let's explain what this does.\n\nThe idiomatic way of writing our example looks like this:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::add_two;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\n\nThere's a few changes here. The first is the introduction of a mod tests with a cfg attribute. The module allows us to group all of our tests together, and to also define helper functions if needed, that don't become a part of the rest of our crate. The cfg attribute only compiles our test code if we're currently trying to run the tests. This can save compile time, and also ensures that our tests are entirely left out of a normal build.\n\nThe second change is the use declaration. Because we're in an inner module, we need to bring the tested function into scope. This can be annoying if you have a large module, and so this is a common use of globs. Let's change our src/lib.rs to make use of it:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\n\nNote the different use line. Now we run our tests:\n\n$ cargo test\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n     Running target/debug/deps/adder-91b3e234d4ed382a\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nIt works!\n\nThe current convention is to use the tests module to hold your \"unit-style\" tests. Anything that tests one small bit of functionality makes sense to go here. But what about \"integration-style\" tests instead? For that, we have the tests directory.\n\nThe tests directory\n\nEach file in tests/*.rs directory is treated as an individual crate. To write an integration test, let's make a tests directory and put a tests/integration_test.rs file inside with this as its contents:\n\nextern crate adder;\n\n#[test]\nfn it_works() {\n    assert_eq!(4, adder::add_two(2));\n}\n\n\nThis looks similar to our previous tests, but slightly different. We now have an extern crate adder at the top. This is because each test in the tests directory is an entirely separate crate, and so we need to import our library. This is also why tests is a suitable place to write integration-style tests: they use the library like any other consumer of it would.\n\nLet's run them:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n     Running target/debug/deps/adder-91b3e234d4ed382a\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n     Running target/debug/integration_test-68064b69521c828a\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nNow we have three sections: our previous test is also run, as well as our new one.\n\nCargo will ignore files in subdirectories of the tests/ directory. Therefore shared modules in integrations tests are possible. For example tests/common/mod.rs is not separately compiled by cargo but can be imported in every test with mod common;\n\nThat's all there is to the tests directory. The tests module isn't needed here, since the whole thing is focused on tests.\n\nNote, when building integration tests, cargo will not pass the test attribute to the compiler. It means that all parts in cfg(test) won't be included in the build used in your integration tests.\n\nLet's finally check out that third section: documentation tests.\n\nDocumentation tests\n\nNothing is better than documentation with examples. Nothing is worse than examples that don't actually work, because the code has changed since the documentation has been written. To this end, Rust supports automatically running examples in your documentation (note: this only works in library crates, not binary crates). Here's a fleshed-out src/lib.rs with examples:\n\n//! The `adder` crate provides functions that add numbers to other numbers.\n//!\n//! # Examples\n//!\n//! ```\n//! assert_eq!(4, adder::add_two(2));\n//! ```\n\n/// This function adds two to its argument.\n///\n/// # Examples\n///\n/// ```\n/// use adder::add_two;\n///\n/// assert_eq!(4, add_two(2));\n/// ```\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\n\nNote the module-level documentation with //! and the function-level documentation with ///. Rust's documentation supports Markdown in comments, and so triple graves mark code blocks. It is conventional to include the # Examples section, exactly like that, with examples following.\n\nLet's run the tests again:\n\n$ cargo test\n   Compiling adder v0.1.0. (file:///home/you/projects/adder)\n     Running target/debug/deps/adder-91b3e234d4ed382a\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n     Running target/debug/integration_test-68064b69521c828a\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 2 tests\ntest add_two_0 ... ok\ntest _0 ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured\n\n\nNow we have all three kinds of tests running! Note the names of the documentation tests: the _0 is generated for the module test, and add_two_0 for the function test. These will auto increment with names like add_two_1 as you add more examples.\n\nWe haven‚Äôt covered all of the details with writing documentation tests. For more, please see the Documentation chapter.\n\nTesting and concurrency\n\nIt is important to note that tests are run concurrently using threads. For this reason, care should be taken to ensure your tests do not depend on each-other, or on any shared state. \"Shared state\" can also include the environment, such as the current working directory, or environment variables.\n\nIf this is an issue it is possible to control this concurrency, either by setting the environment variable RUST_TEST_THREADS, or by passing the argument --test-threads to the tests:\n\n$ RUST_TEST_THREADS=1 cargo test   # Run tests with no concurrency\n...\n$ cargo test -- --test-threads=1   # Same as above\n...\n\nTest output\n\nBy default Rust's test library captures and discards output to standard out/error, e.g. output from println!(). This too can be controlled using the environment or a switch:\n\n$ RUST_TEST_NOCAPTURE=1 cargo test   # Preserve stdout/stderr\n...\n$ cargo test -- --nocapture          # Same as above\n...\n\n\nHowever a better method avoiding capture is to use logging rather than raw output. Rust has a standard logging API, which provides a frontend to multiple logging implementations. This can be used in conjunction with the default env_logger to output any debugging information in a manner that can be controlled at runtime.\n\nConditional Compilation\n\nRust has a special attribute, #[cfg], which allows you to compile code based on a flag passed to the compiler. It has two forms:\n\n\n#[cfg(foo)]\n\n#[cfg(bar = \"baz\")]\n\nThey also have some helpers:\n\n\n#[cfg(any(unix, windows))]\n\n#[cfg(all(unix, target_pointer_width = \"32\"))]\n\n#[cfg(not(foo))]\n\nThese can nest arbitrarily:\n\n\n#[cfg(any(not(unix), all(target_os=\"macos\", target_arch = \"powerpc\")))]\n\nAs for how to enable or disable these switches, if you‚Äôre using Cargo, they get set in the [features] section of your Cargo.toml:\n\n[features]\n# no features by default\ndefault = []\n\n# Add feature \"foo\" here, then you can use it. \n# Our \"foo\" feature depends on nothing else.\nfoo = []\n\n\nWhen you do this, Cargo passes along a flag to rustc:\n\n--cfg feature=\"${feature_name}\"\n\n\nThe sum of these cfg flags will determine which ones get activated, and therefore, which code gets compiled. Let‚Äôs take this code:\n\n\n#[cfg(feature = \"foo\")]\nmod foo {\n}\n\nIf we compile it with cargo build --features \"foo\", it will send the --cfg feature=\"foo\" flag to rustc, and the output will have the mod foo in it. If we compile it with a regular cargo build, no extra flags get passed on, and so, no foo module will exist.\n\ncfg_attr\n\nYou can also set another attribute based on a cfg variable with cfg_attr:\n\n\n#[cfg_attr(a, b)]\n\nWill be the same as #[b] if a is set by cfg attribute, and nothing otherwise.\n\ncfg!\n\nThe cfg! macro lets you use these kinds of flags elsewhere in your code, too:\n\n\nif cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n    println!(\"Think Different!\");\n}\n\nThese will be replaced by a true or false at compile-time, depending on the configuration settings.\n\nDocumentation\n\nDocumentation is an important part of any software project, and it's first-class in Rust. Let's talk about the tooling Rust gives you to document your project.\n\nAbout rustdoc\n\nThe Rust distribution includes a tool, rustdoc, that generates documentation. rustdoc is also used by Cargo through cargo doc.\n\nDocumentation can be generated in two ways: from source code, and from standalone Markdown files.\n\nDocumenting source code\n\nThe primary way of documenting a Rust project is through annotating the source code. You can use documentation comments for this purpose:\n\n/// Constructs a new `Rc<T>`.\n///\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\npub fn new(value: T) -> Rc<T> {\n    // Implementation goes here.\n}\n\n\nThis code generates documentation that looks like this. I've left the implementation out, with a regular comment in its place.\n\nThe first thing to notice about this annotation is that it uses /// instead of //. The triple slash indicates a documentation comment.\n\nDocumentation comments are written in Markdown.\n\nRust keeps track of these comments, and uses them when generating documentation. This is important when documenting things like enums:\n\n\n/// The `Option` type. See [the module level documentation](index.html) for more.\nenum Option<T> {\n    /// No value\n    None,\n    /// Some value `T`\n    Some(T),\n}\n\nThe above works, but this does not:\n\n/// The `Option` type. See [the module level documentation](index.html) for more.\nenum Option<T> {\n    None, /// No value\n    Some(T), /// Some value `T`\n}\n\n\nYou'll get an error:\n\nhello.rs:4:1: 4:2 error: expected ident, found `}`\nhello.rs:4 }\n           ^\n\n\nThis unfortunate error is correct; documentation comments apply to the thing after them, and there's nothing after that last comment.\n\nWriting documentation comments\n\nAnyway, let's cover each part of this comment in detail:\n\n\n/// Constructs a new `Rc<T>`.\n\nThe first line of a documentation comment should be a short summary of its functionality. One sentence. Just the basics. High level.\n\n\n///\n/// Other details about constructing `Rc<T>`s, maybe describing complicated\n/// semantics, maybe additional options, all kinds of stuff.\n///\n\nOur original example had just a summary line, but if we had more things to say, we could have added more explanation in a new paragraph.\n\nSpecial sections\n\nNext, are special sections. These are indicated with a header, #. There are four kinds of headers that are commonly used. They aren't special syntax, just convention, for now.\n\n\n/// # Panics\n\nUnrecoverable misuses of a function (i.e. programming errors) in Rust are usually indicated by panics, which kill the whole current thread at the very least. If your function has a non-trivial contract like this, that is detected/enforced by panics, documenting it is very important.\n\n\n/// # Errors\n\nIf your function or method returns a Result<T, E>, then describing the conditions under which it returns Err(E) is a nice thing to do. This is slightly less important than Panics, because failure is encoded into the type system, but it's still a good thing to do.\n\n\n/// # Safety\n\nIf your function is unsafe, you should explain which invariants the caller is responsible for upholding.\n\n\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\n\nFourth, Examples. Include one or more examples of using your function or method, and your users will love you for it. These examples go inside of code block annotations, which we'll talk about in a moment, and can have more than one section:\n\n\n/// # Examples\n///\n/// Simple `&str` patterns:\n///\n/// ```\n/// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n/// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n/// ```\n///\n/// More complex patterns with a lambda:\n///\n/// ```\n/// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n/// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n/// ```\nCode block annotations\n\nTo write some Rust code in a comment, use the triple graves:\n\n\n/// ```\n/// println!(\"Hello, world\");\n/// ```\n\nThis will add code highlighting. If you are only showing plain text, put text instead of rust after the triple graves (see below).\n\nDocumentation as tests\n\nLet's discuss our sample example documentation:\n\n\n/// ```\n/// println!(\"Hello, world\");\n/// ```\n\nYou'll notice that you don't need a fn main() or anything here. rustdoc will automatically add a main() wrapper around your code, using heuristics to attempt to put it in the right place. For example:\n\n\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\n\nThis will end up testing:\n\nfn main() {\n    use std::rc::Rc;\n    let five = Rc::new(5);\n}\n\n\nHere's the full algorithm rustdoc uses to preprocess examples:\n\nAny leading #![foo] attributes are left intact as crate attributes.\nSome common allow attributes are inserted, including unused_variables, unused_assignments, unused_mut, unused_attributes, and dead_code. Small examples often trigger these lints.\nIf the example does not contain extern crate, then extern crate <mycrate>; is inserted (note the lack of #[macro_use]).\nFinally, if the example does not contain fn main, the remainder of the text is wrapped in fn main() { your_code }.\n\nThis generated fn main can be a problem! If you have extern crate or a mod statements in the example code that are referred to by use statements, they will fail to resolve unless you include at least fn main() {} to inhibit step 4. #[macro_use] extern crate also does not work except at the crate root, so when testing macros an explicit main is always required. It doesn't have to clutter up your docs, though -- keep reading!\n\nSometimes this algorithm isn't enough, though. For example, all of these code samples with /// we've been talking about? The raw text:\n\n/// Some documentation.\n# fn foo() {}\n\n\nlooks different than the output:\n\n\n/// Some documentation.\n\nYes, that's right: you can add lines that start with #, and they will be hidden from the output, but will be used when compiling your code. You can use this to your advantage. In this case, documentation comments need to apply to some kind of function, so if I want to show you just a documentation comment, I need to add a little function definition below it. At the same time, it's only there to satisfy the compiler, so hiding it makes the example more clear. You can use this technique to explain longer examples in detail, while still preserving the testability of your documentation.\n\nFor example, imagine that we wanted to document this code:\n\n\nlet x = 5;\nlet y = 6;\nprintln!(\"{}\", x + y);\n\nWe might want the documentation to end up looking like this:\n\nFirst, we set x to five:\n\n\nlet x = 5;\n\nNext, we set y to six:\n\n\nlet y = 6;\n\nFinally, we print the sum of x and y:\n\n\nprintln!(\"{}\", x + y);\n\nTo keep each code block testable, we want the whole program in each block, but we don't want the reader to see every line every time. Here's what we put in our source code:\n\n    First, we set `x` to five:\n\n    ```rust\n    let x = 5;\n    # let y = 6;\n    # println!(\"{}\", x + y);\n    ```\n\n    Next, we set `y` to six:\n\n    ```rust\n    # let x = 5;\n    let y = 6;\n    # println!(\"{}\", x + y);\n    ```\n\n    Finally, we print the sum of `x` and `y`:\n\n    ```rust\n    # let x = 5;\n    # let y = 6;\n    println!(\"{}\", x + y);\n    ```\n\n\nBy repeating all parts of the example, you can ensure that your example still compiles, while only showing the parts that are relevant to that part of your explanation.\n\nDocumenting macros\n\nHere‚Äôs an example of documenting a macro:\n\n/// Panic with a given message unless an expression evaluates to true.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate foo;\n/// # fn main() {\n/// panic_unless!(1 + 1 == 2, ‚ÄúMath is broken.‚Äù);\n/// # }\n/// ```\n///\n/// ```rust,should_panic\n/// # #[macro_use] extern crate foo;\n/// # fn main() {\n/// panic_unless!(true == false, ‚ÄúI‚Äôm broken.‚Äù);\n/// # }\n/// ```\n#[macro_export]\nmacro_rules! panic_unless {\n    ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });\n}\n\n\nYou‚Äôll note three things: we need to add our own extern crate line, so that we can add the #[macro_use] attribute. Second, we‚Äôll need to add our own main() as well (for reasons discussed above). Finally, a judicious use of # to comment out those two things, so they don‚Äôt show up in the output.\n\nAnother case where the use of # is handy is when you want to ignore error handling. Lets say you want the following,\n\n/// use std::io;\n/// let mut input = String::new();\n/// try!(io::stdin().read_line(&mut input));\n\n\nThe problem is that try! returns a Result<T, E> and test functions don't return anything so this will give a mismatched types error.\n\n/// A doc test using try!\n///\n/// ```\n/// use std::io;\n/// # fn foo() -> io::Result<()> {\n/// let mut input = String::new();\n/// try!(io::stdin().read_line(&mut input));\n/// # Ok(())\n/// # }\n/// ```\n\n\nYou can get around this by wrapping the code in a function. This catches and swallows the Result<T, E> when running tests on the docs. This pattern appears regularly in the standard library.\n\nRunning documentation tests\n\nTo run the tests, either:\n\n$ rustdoc --test path/to/my/crate/root.rs\n# or\n$ cargo test\n\n\nThat's right, cargo test tests embedded documentation too. However, cargo test will not test binary crates, only library ones. This is due to the way rustdoc works: it links against the library to be tested, but with a binary, there‚Äôs nothing to link to.\n\nThere are a few more annotations that are useful to help rustdoc do the right thing when testing your code:\n\n\n/// ```rust,ignore\n/// fn foo() {\n/// ```\n\nThe ignore directive tells Rust to ignore your code. This is almost never what you want, as it's the most generic. Instead, consider annotating it with text if it's not code, or using #s to get a working example that only shows the part you care about.\n\n\n/// ```rust,should_panic\n/// assert!(false);\n/// ```\n\nshould_panic tells rustdoc that the code should compile correctly, but not actually pass as a test.\n\n\n/// ```rust,no_run\n/// loop {\n///     println!(\"Hello, world\");\n/// }\n/// ```\n\nThe no_run attribute will compile your code, but not run it. This is important for examples such as \"Here's how to retrieve a web page,\" which you would want to ensure compiles, but might be run in a test environment that has no network access.\n\nDocumenting modules\n\nRust has another kind of doc comment, //!. This comment doesn't document the next item, but the enclosing item. In other words:\n\n\nmod foo {\n    //! This is documentation for the `foo` module.\n    //!\n    //! # Examples\n\n    // ...\n}\n\nThis is where you'll see //! used most often: for module documentation. If you have a module in foo.rs, you'll often open its code and see this:\n\n\n//! A module for using `foo`s.\n//!\n//! The `foo` module contains a lot of useful functionality blah blah blah...\nCrate documentation\n\nCrates can be documented by placing an inner doc comment (//!) at the beginning of the crate root, aka lib.rs:\n\n\n//! This is documentation for the `foo` crate.\n//!\n//! The foo crate is meant to be used for bar.\nDocumentation comment style\n\nCheck out RFC 505 for full conventions around the style and format of documentation.\n\nOther documentation\n\nAll of this behavior works in non-Rust source files too. Because comments are written in Markdown, they're often .md files.\n\nWhen you write documentation in Markdown files, you don't need to prefix the documentation with comments. For example:\n\n\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\n\nis:\n\n# Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n```\n\n\nwhen it's in a Markdown file. There is one wrinkle though: Markdown files need to have a title like this:\n\n% The title\n\nThis is the example documentation.\n\n\nThis % line needs to be the very first line of the file.\n\ndoc attributes\n\nAt a deeper level, documentation comments are syntactic sugar for documentation attributes:\n\n\n/// this\n\n#[doc=\"this\"]\n\nare the same, as are these:\n\n\n//! this\n\n#![doc=\"this\"]\n\nYou won't often see this attribute used for writing documentation, but it can be useful when changing some options, or when writing a macro.\n\nRe-exports\n\nrustdoc will show the documentation for a public re-export in both places:\n\nextern crate foo;\n\npub use foo::bar;\n\n\nThis will create documentation for bar both inside the documentation for the crate foo, as well as the documentation for your crate. It will use the same documentation in both places.\n\nThis behavior can be suppressed with no_inline:\n\nextern crate foo;\n\n#[doc(no_inline)]\npub use foo::bar;\n\nMissing documentation\n\nSometimes you want to make sure that every single public thing in your project is documented, especially when you are working on a library. Rust allows you to to generate warnings or errors, when an item is missing documentation. To generate warnings you use warn:\n\n#![warn(missing_docs)]\n\n\nAnd to generate errors you use deny:\n\n#![deny(missing_docs)]\n\n\nThere are cases where you want to disable these warnings/errors to explicitly leave something undocumented. This is done by using allow:\n\n\n#[allow(missing_docs)]\nstruct Undocumented;\n\nYou might even want to hide items from the documentation completely:\n\n\n#[doc(hidden)]\nstruct Hidden;\nControlling HTML\n\nYou can control a few aspects of the HTML that rustdoc generates through the #![doc] version of the attribute:\n\n#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/\")]\n\n\nThis sets a few different options, with a logo, favicon, and a root URL.\n\nConfiguring documentation tests\n\nYou can also configure the way that rustdoc tests your documentation examples through the #![doc(test(..))] attribute.\n\n\n#![doc(test(attr(allow(unused_variables), deny(warnings))))]\n\nThis allows unused variables within the examples, but will fail the test for any other lint warning thrown.\n\nGeneration options\n\nrustdoc also contains a few other options on the command line, for further customization:\n\n--html-in-header FILE: includes the contents of FILE at the end of the <head>...</head> section.\n--html-before-content FILE: includes the contents of FILE directly after <body>, before the rendered content (including the search bar).\n--html-after-content FILE: includes the contents of FILE after all the rendered content.\nSecurity note\n\nThe Markdown in documentation comments is placed without processing into the final webpage. Be careful with literal HTML:\n\n\n/// <script>alert(document.cookie)</script>\nIterators\n\nLet's talk about loops.\n\nRemember Rust's for loop? Here's an example:\n\n\nfor x in 0..10 {\n    println!(\"{}\", x);\n}\n\nNow that you know more Rust, we can talk in detail about how this works. Ranges (the 0..10) are 'iterators'. An iterator is something that we can call the .next() method on repeatedly, and it gives us a sequence of things.\n\nA range with two dots like 0..10 is inclusive on the left (so it starts at 0) and exclusive on the right (so it ends at 9). A mathematician would write \"[0, 10)\".\n\nLike this:\n\n\nlet mut range = 0..10;\n\nloop {\n    match range.next() {\n        Some(x) => {\n            println!(\"{}\", x);\n        },\n        None => { break }\n    }\n}\n\nWe make a mutable binding to the range, which is our iterator. We then loop, with an inner match. This match is used on the result of range.next(), which gives us a reference to the next value of the iterator. next returns an Option<i32>, in this case, which will be Some(i32) when we have a value and None once we run out. If we get Some(i32), we print it out, and if we get None, we break out of the loop.\n\nThis code sample is basically the same as our for loop version. The for loop is a handy way to write this loop/match/break construct.\n\nfor loops aren't the only thing that uses iterators, however. Writing your own iterator involves implementing the Iterator trait. While doing that is outside of the scope of this guide, Rust provides a number of useful iterators to accomplish various tasks. But first, a few notes about limitations of ranges.\n\nRanges are very primitive, and we often can use better alternatives. Consider the following Rust anti-pattern: using ranges to emulate a C-style for loop. Let‚Äôs suppose you needed to iterate over the contents of a vector. You may be tempted to write this:\n\n\nlet nums = vec![1, 2, 3];\n\nfor i in 0..nums.len() {\n    println!(\"{}\", nums[i]);\n}\n\nThis is strictly worse than using an actual iterator. You can iterate over vectors directly, so write this:\n\n\nlet nums = vec![1, 2, 3];\n\nfor num in &nums {\n    println!(\"{}\", num);\n}\n\nThere are two reasons for this. First, this more directly expresses what we mean. We iterate through the entire vector, rather than iterating through indexes, and then indexing the vector. Second, this version is more efficient: the first version will have extra bounds checking because it used indexing, nums[i]. But since we yield a reference to each element of the vector in turn with the iterator, there's no bounds checking in the second example. This is very common with iterators: we can ignore unnecessary bounds checks, but still know that we're safe.\n\nThere's another detail here that's not 100% clear because of how println! works. num is actually of type &i32. That is, it's a reference to an i32, not an i32 itself. println! handles the dereferencing for us, so we don't see it. This code works fine too:\n\n\nlet nums = vec![1, 2, 3];\n\nfor num in &nums {\n    println!(\"{}\", *num);\n}\n\nNow we're explicitly dereferencing num. Why does &nums give us references? Firstly, because we explicitly asked it to with &. Secondly, if it gave us the data itself, we would have to be its owner, which would involve making a copy of the data and giving us the copy. With references, we're only borrowing a reference to the data, and so it's only passing a reference, without needing to do the move.\n\nSo, now that we've established that ranges are often not what you want, let's talk about what you do want instead.\n\nThere are three broad classes of things that are relevant here: iterators, iterator adaptors, and consumers. Here's some definitions:\n\niterators give you a sequence of values.\niterator adaptors operate on an iterator, producing a new iterator with a different output sequence.\nconsumers operate on an iterator, producing some final set of values.\n\nLet's talk about consumers first, since you've already seen an iterator, ranges.\n\nConsumers\n\nA consumer operates on an iterator, returning some kind of value or values. The most common consumer is collect(). This code doesn't quite compile, but it shows the intention:\n\nlet one_to_one_hundred = (1..101).collect();\n\n\nAs you can see, we call collect() on our iterator. collect() takes as many values as the iterator will give it, and returns a collection of the results. So why won't this compile? Rust can't determine what type of things you want to collect, and so you need to let it know. Here's the version that does compile:\n\n\nlet one_to_one_hundred = (1..101).collect::<Vec<i32>>();\n\nIf you remember, the ::<> syntax allows us to give a type hint that tells the compiler we want a vector of integers. You don't always need to use the whole type, though. Using a _ will let you provide a partial hint:\n\n\nlet one_to_one_hundred = (1..101).collect::<Vec<_>>();\n\nThis says \"Collect into a Vec<T>, please, but infer what the T is for me.\" _ is sometimes called a \"type placeholder\" for this reason.\n\ncollect() is the most common consumer, but there are others too. find() is one:\n\n\nlet greater_than_forty_two = (0..100)\n                             .find(|x| *x > 42);\n\nmatch greater_than_forty_two {\n    Some(_) => println!(\"Found a match!\"),\n    None => println!(\"No match found :(\"),\n}\n\nfind takes a closure, and works on a reference to each element of an iterator. This closure returns true if the element is the element we're looking for, and false otherwise. find returns the first element satisfying the specified predicate. Because we might not find a matching element, find returns an Option rather than the element itself.\n\nAnother important consumer is fold. Here's what it looks like:\n\n\nlet sum = (1..4).fold(0, |sum, x| sum + x);\n\nfold() is a consumer that looks like this: fold(base, |accumulator, element| ...). It takes two arguments: the first is an element called the base. The second is a closure that itself takes two arguments: the first is called the accumulator, and the second is an element. Upon each iteration, the closure is called, and the result is the value of the accumulator on the next iteration. On the first iteration, the base is assigned the value of the accumulator.\n\nOkay, that's a bit confusing. Let's examine the values of all of these things in this iterator:\n\nbase\taccumulator\telement\tclosure result\n0\t0\t1\t1\n0\t1\t2\t3\n0\t3\t3\t6\n\nWe called fold() with these arguments:\n\n\n.fold(0, |sum, x| sum + x);\n\nSo, 0 is our base, sum is our accumulator, and x is our element. On the first iteration, we set sum to 0, and x is the first element of nums, 1. We then add sum and x, which gives us 0 + 1 = 1. On the second iteration, that value becomes our accumulator, sum, and the element is the second element of the array, 2. 1 + 2 = 3, and so that becomes the value of the accumulator for the last iteration. On that iteration, x is the last element, 3, and 3 + 3 = 6, which is our final result for our sum. 1 + 2 + 3 = 6, and that's the result we got.\n\nWhew. fold can be a bit strange the first few times you see it, but once it clicks, you can use it all over the place. Any time you have a list of things, and you want a single result, fold is appropriate.\n\nConsumers are important due to one additional property of iterators we haven't talked about yet: laziness. Let's talk some more about iterators, and you'll see why consumers matter.\n\nIterators\n\nAs we've said before, an iterator is something that we can call the .next() method on repeatedly, and it gives us a sequence of things. Because you need to call the method, this means that iterators can be lazy and not generate all of the values upfront. This code, for example, does not actually generate the numbers 1-99, instead creating a value that merely represents the sequence:\n\n\nlet nums = 1..100;\n\nSince we didn't do anything with the range, it didn't generate the sequence. Let's add the consumer:\n\n\nlet nums = (1..100).collect::<Vec<i32>>();\n\nNow, collect() will require that the range gives it some numbers, and so it will do the work of generating the sequence.\n\nRanges are one of two basic iterators that you'll see. The other is iter(). iter() can turn a vector into a simple iterator that gives you each element in turn:\n\n\nlet nums = vec![1, 2, 3];\n\nfor num in nums.iter() {\n   println!(\"{}\", num);\n}\n\nThese two basic iterators should serve you well. There are some more advanced iterators, including ones that are infinite.\n\nThat's enough about iterators. Iterator adaptors are the last concept we need to talk about with regards to iterators. Let's get to it!\n\nIterator adaptors\n\nIterator adaptors take an iterator and modify it somehow, producing a new iterator. The simplest one is called map:\n\n(1..100).map(|x| x + 1);\n\n\nmap is called upon another iterator, and produces a new iterator where each element reference has the closure it's been given as an argument called on it. So this would give us the numbers from 2-100. Well, almost! If you compile the example, you'll get a warning:\n\nwarning: unused result which must be used: iterator adaptors are lazy and\n         do nothing unless consumed, #[warn(unused_must_use)] on by default\n(1..100).map(|x| x + 1);\n ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nLaziness strikes again! That closure will never execute. This example doesn't print any numbers:\n\n(1..100).map(|x| println!(\"{}\", x));\n\n\nIf you are trying to execute a closure on an iterator for its side effects, use for instead.\n\nThere are tons of interesting iterator adaptors. take(n) will return an iterator over the next n elements of the original iterator. Let's try it out with an infinite iterator:\n\n\nfor i in (1..).take(5) {\n    println!(\"{}\", i);\n}\n\nThis will print\n\n1\n2\n3\n4\n5\n\n\nfilter() is an adapter that takes a closure as an argument. This closure returns true or false. The new iterator filter() produces only the elements that the closure returns true for:\n\n\nfor i in (1..100).filter(|&x| x % 2 == 0) {\n    println!(\"{}\", i);\n}\n\nThis will print all of the even numbers between one and a hundred. (Note that, unlike map, the closure passed to filter is passed a reference to the element instead of the element itself. The filter predicate here uses the &x pattern to extract the integer. The filter closure is passed a reference because it returns true or false instead of the element, so the filter implementation must retain ownership to put the elements into the newly constructed iterator.)\n\nYou can chain all three things together: start with an iterator, adapt it a few times, and then consume the result. Check it out:\n\n\n(1..)\n    .filter(|&x| x % 2 == 0)\n    .filter(|&x| x % 3 == 0)\n    .take(5)\n    .collect::<Vec<i32>>();\n\nThis will give you a vector containing 6, 12, 18, 24, and 30.\n\nThis is just a small taste of what iterators, iterator adaptors, and consumers can help you with. There are a number of really useful iterators, and you can write your own as well. Iterators provide a safe, efficient way to manipulate all kinds of lists. They're a little unusual at first, but if you play with them, you'll get hooked. For a full list of the different iterators and consumers, check out the iterator module documentation.\n\nConcurrency\n\nConcurrency and parallelism are incredibly important topics in computer science, and are also a hot topic in industry today. Computers are gaining more and more cores, yet many programmers aren't prepared to fully utilize them.\n\nRust's memory safety features also apply to its concurrency story. Even concurrent Rust programs must be memory safe, having no data races. Rust's type system is up to the task, and gives you powerful ways to reason about concurrent code at compile time.\n\nBefore we talk about the concurrency features that come with Rust, it's important to understand something: Rust is low-level enough that the vast majority of this is provided by the standard library, not by the language. This means that if you don't like some aspect of the way Rust handles concurrency, you can implement an alternative way of doing things. mio is a real-world example of this principle in action.\n\nBackground: Send and Sync\n\nConcurrency is difficult to reason about. In Rust, we have a strong, static type system to help us reason about our code. As such, Rust gives us two traits to help us make sense of code that can possibly be concurrent.\n\nSend\n\nThe first trait we're going to talk about is Send. When a type T implements Send, it indicates that something of this type is able to have ownership transferred safely between threads.\n\nThis is important to enforce certain restrictions. For example, if we have a channel connecting two threads, we would want to be able to send some data down the channel and to the other thread. Therefore, we'd ensure that Send was implemented for that type.\n\nIn the opposite way, if we were wrapping a library with FFI that isn't thread-safe, we wouldn't want to implement Send, and so the compiler will help us enforce that it can't leave the current thread.\n\nSync\n\nThe second of these traits is called Sync. When a type T implements Sync, it indicates that something of this type has no possibility of introducing memory unsafety when used from multiple threads concurrently through shared references. This implies that types which don't have interior mutability are inherently Sync, which includes simple primitive types (like u8) and aggregate types containing them.\n\nFor sharing references across threads, Rust provides a wrapper type called Arc<T>. Arc<T> implements Send and Sync if and only if T implements both Send and Sync. For example, an object of type Arc<RefCell<U>> cannot be transferred across threads because RefCell does not implement Sync, consequently Arc<RefCell<U>> would not implement Send.\n\nThese two traits allow you to use the type system to make strong guarantees about the properties of your code under concurrency. Before we demonstrate why, we need to learn how to create a concurrent Rust program in the first place!\n\nThreads\n\nRust's standard library provides a library for threads, which allow you to run Rust code in parallel. Here's a basic example of using std::thread:\n\nuse std::thread;\n\nfn main() {\n    thread::spawn(|| {\n        println!(\"Hello from a thread!\");\n    });\n}\n\n\nThe thread::spawn() method accepts a closure, which is executed in a new thread. It returns a handle to the thread, that can be used to wait for the child thread to finish and extract its result:\n\nuse std::thread;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        \"Hello from a thread!\"\n    });\n\n    println!(\"{}\", handle.join().unwrap());\n}\n\n\nAs closures can capture variables from their environment, we can also try to bring some data into the other thread:\n\nuse std::thread;\n\nfn main() {\n    let x = 1;\n    thread::spawn(|| {\n        println!(\"x is {}\", x);\n    });\n}\n\n\nHowever, this gives us an error:\n\n5:19: 7:6 error: closure may outlive the current function, but it\n                 borrows `x`, which is owned by the current function\n...\n5:19: 7:6 help: to force the closure to take ownership of `x` (and any other referenced variables),\n          use the `move` keyword, as shown:\n      thread::spawn(move || {\n          println!(\"x is {}\", x);\n      });\n\n\nThis is because by default closures capture variables by reference, and thus the closure only captures a reference to x. This is a problem, because the thread may outlive the scope of x, leading to a dangling pointer.\n\nTo fix this, we use a move closure as mentioned in the error message. move closures are explained in depth here; basically they move variables from their environment into themselves.\n\nuse std::thread;\n\nfn main() {\n    let x = 1;\n    thread::spawn(move || {\n        println!(\"x is {}\", x);\n    });\n}\n\n\nMany languages have the ability to execute threads, but it's wildly unsafe. There are entire books about how to prevent errors that occur from shared mutable state. Rust helps out with its type system here as well, by preventing data races at compile time. Let's talk about how you actually share things between threads.\n\nSafe Shared Mutable State\n\nDue to Rust's type system, we have a concept that sounds like a lie: \"safe shared mutable state.\" Many programmers agree that shared mutable state is very, very bad.\n\nSomeone once said this:\n\nShared mutable state is the root of all evil. Most languages attempt to deal with this problem through the 'mutable' part, but Rust deals with it by solving the 'shared' part.\n\nThe same ownership system that helps prevent using pointers incorrectly also helps rule out data races, one of the worst kinds of concurrency bugs.\n\nAs an example, here is a Rust program that would have a data race in many languages. It will not compile:\n\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let mut data = vec![1, 2, 3];\n\n    for i in 0..3 {\n        thread::spawn(move || {\n            data[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nThis gives us an error:\n\n8:17 error: capture of moved value: `data`\n        data[0] += i;\n        ^~~~\n\n\nRust knows this wouldn't be safe! If we had a reference to data in each thread, and the thread takes ownership of the reference, we'd have three owners! data gets moved out of main in the first call to spawn(), so subsequent calls in the loop cannot use this variable.\n\nSo, we need some type that lets us have more than one owning reference to a value. Usually, we'd use Rc<T> for this, which is a reference counted type that provides shared ownership. It has some runtime bookkeeping that keeps track of the number of references to it, hence the \"reference count\" part of its name.\n\nCalling clone() on an Rc<T> will return a new owned reference and bump the internal reference count. We create one of these for each thread:\n\nuse std::thread;\nuse std::time::Duration;\nuse std::rc::Rc;\n\nfn main() {\n    let mut data = Rc::new(vec![1, 2, 3]);\n\n    for i in 0..3 {\n        // Create a new owned reference:\n        let data_ref = data.clone();\n\n        // Use it in a thread:\n        thread::spawn(move || {\n            data_ref[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nThis won't work, however, and will give us the error:\n\n13:9: 13:22 error: the trait bound `alloc::rc::Rc<collections::vec::Vec<i32>> : core::marker::Send`\n            is not satisfied\n...\n13:9: 13:22 note: `alloc::rc::Rc<collections::vec::Vec<i32>>`\n            cannot be sent between threads safely\n\n\nAs the error message mentions, Rc cannot be sent between threads safely. This is because the internal reference count is not maintained in a thread-safe manner and can have a data race.\n\nTo solve this, we'll use Arc<T>, Rust's standard atomic reference count type.\n\nThe Atomic part means Arc<T> can safely be accessed from multiple threads. To do this the compiler guarantees that mutations of the internal count use indivisible operations which can't have data races.\n\nIn essence, Arc<T> is a type that lets us share ownership of data across threads.\n\nuse std::thread;\nuse std::sync::Arc;\nuse std::time::Duration;\n\nfn main() {\n    let mut data = Arc::new(vec![1, 2, 3]);\n\n    for i in 0..3 {\n        let data = data.clone();\n        thread::spawn(move || {\n            data[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nSimilarly to last time, we use clone() to create a new owned handle. This handle is then moved into the new thread.\n\nAnd... still gives us an error.\n\n<anon>:11:24 error: cannot borrow immutable borrowed content as mutable\n<anon>:11                    data[0] += i;\n                             ^~~~\n\n\nArc<T> by default has immutable contents. It allows the sharing of data between threads, but shared mutable data is unsafe‚Äîand when threads are involved‚Äîcan cause data races!\n\nUsually when we wish to make something in an immutable position mutable, we use Cell<T> or RefCell<T> which allow safe mutation via runtime checks or otherwise (see also: Choosing Your Guarantees). However, similar to Rc, these are not thread-safe. If we try using these, we will get an error about these types not being Sync, and the code will fail to compile.\n\nIt looks like we need some type that allows us to safely mutate a shared value across threads, for example a type that can ensure only one thread at a time is able to mutate the value inside it at any one time.\n\nFor that, we can use the Mutex<T> type!\n\nHere's the working version:\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n\n    for i in 0..3 {\n        let data = data.clone();\n        thread::spawn(move || {\n            let mut data = data.lock().unwrap();\n            data[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nNote that the value of i is bound (copied) to the closure and not shared among the threads.\n\nWe're \"locking\" the mutex here. A mutex (short for \"mutual exclusion\"), as mentioned, only allows one thread at a time to access a value. When we wish to access the value, we use lock() on it. This will \"lock\" the mutex, and no other thread will be able to lock it (and hence, do anything with the value) until we're done with it. If a thread attempts to lock a mutex which is already locked, it will wait until the other thread releases the lock.\n\nThe lock \"release\" here is implicit; when the result of the lock (in this case, data) goes out of scope, the lock is automatically released.\n\nNote that lock method of Mutex has this signature:\n\nfn lock(&self) -> LockResult<MutexGuard<T>>\n\n\nand because Send is not implemented for MutexGuard<T>, the guard cannot cross thread boundaries, ensuring thread-locality of lock acquire and release.\n\nLet's examine the body of the thread more closely:\n\nthread::spawn(move || {\n    let mut data = data.lock().unwrap();\n    data[0] += i;\n});\n\n\nFirst, we call lock(), which acquires the mutex's lock. Because this may fail, it returns a Result<T, E>, and because this is just an example, we unwrap() it to get a reference to the data. Real code would have more robust error handling here. We're then free to mutate it, since we have the lock.\n\nLastly, while the threads are running, we wait on a short timer. But this is not ideal: we may have picked a reasonable amount of time to wait but it's more likely we'll either be waiting longer than necessary or not long enough, depending on just how much time the threads actually take to finish computing when the program runs.\n\nA more precise alternative to the timer would be to use one of the mechanisms provided by the Rust standard library for synchronizing threads with each other. Let's talk about one of them: channels.\n\nChannels\n\nHere's a version of our code that uses channels for synchronization, rather than waiting for a specific time:\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let data = Arc::new(Mutex::new(0));\n\n    // `tx` is the \"transmitter\" or \"sender\".\n    // `rx` is the \"receiver\".\n    let (tx, rx) = mpsc::channel();\n\n    for _ in 0..10 {\n        let (data, tx) = (data.clone(), tx.clone());\n\n        thread::spawn(move || {\n            let mut data = data.lock().unwrap();\n            *data += 1;\n\n            tx.send(()).unwrap();\n        });\n    }\n\n    for _ in 0..10 {\n        rx.recv().unwrap();\n    }\n}\n\n\nWe use the mpsc::channel() method to construct a new channel. We send a simple () down the channel, and then wait for ten of them to come back.\n\nWhile this channel is sending a generic signal, we can send any data that is Send over the channel!\n\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    for i in 0..10 {\n        let tx = tx.clone();\n\n        thread::spawn(move || {\n            let answer = i * i;\n\n            tx.send(answer).unwrap();\n        });\n    }\n\n    for _ in 0..10 {\n        println!(\"{}\", rx.recv().unwrap());\n    }\n}\n\n\nHere we create 10 threads, asking each to calculate the square of a number (i at the time of spawn()), and then send() back the answer over the channel.\n\nPanics\n\nA panic! will crash the currently executing thread. You can use Rust's threads as a simple isolation mechanism:\n\n\nuse std::thread;\n\nlet handle = thread::spawn(move || {\n    panic!(\"oops!\");\n});\n\nlet result = handle.join();\n\nassert!(result.is_err());\n\nThread.join() gives us a Result back, which allows us to check if the thread has panicked or not.\n\nError Handling\n\nLike most programming languages, Rust encourages the programmer to handle errors in a particular way. Generally speaking, error handling is divided into two broad categories: exceptions and return values. Rust opts for return values.\n\nIn this section, we intend to provide a comprehensive treatment of how to deal with errors in Rust. More than that, we will attempt to introduce error handling one piece at a time so that you'll come away with a solid working knowledge of how everything fits together.\n\nWhen done na√Øvely, error handling in Rust can be verbose and annoying. This section will explore those stumbling blocks and demonstrate how to use the standard library to make error handling concise and ergonomic.\n\nTable of Contents\n\nThis section is very long, mostly because we start at the very beginning with sum types and combinators, and try to motivate the way Rust does error handling incrementally. As such, programmers with experience in other expressive type systems may want to jump around.\n\nThe Basics\nUnwrapping explained\nThe Option type\nComposing Option<T> values\nThe Result type\nParsing integers\nThe Result type alias idiom\nA brief interlude: unwrapping isn't evil\nWorking with multiple error types\nComposing Option and Result\nThe limits of combinators\nEarly returns\nThe try! macro\nDefining your own error type\nStandard library traits used for error handling\nThe Error trait\nThe From trait\nThe real try! macro\nComposing custom error types\nAdvice for library writers\nCase study: A program to read population data\nInitial setup\nArgument parsing\nWriting the logic\nError handling with Box<Error>\nReading from stdin\nError handling with a custom type\nAdding functionality\nThe short story\nThe Basics\n\nYou can think of error handling as using case analysis to determine whether a computation was successful or not. As you will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has to do while keeping code composable.\n\nKeeping code composable is important, because without that requirement, we could panic whenever we come across something unexpected. (panic causes the current task to unwind, and in most cases, the entire program aborts.) Here's an example:\n\n// Guess a number between 1 and 10.\n// If it matches the number we had in mind, return `true`. Else, return `false`.\nfn guess(n: i32) -> bool {\n    if n < 1 || n > 10 {\n        panic!(\"Invalid number: {}\", n);\n    }\n    n == 5\n}\n\nfn main() {\n    guess(11);\n}\n\n\nIf you try running this code, the program will crash with a message like this:\n\nthread 'main' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5\n\n\nHere's another example that is slightly less contrived. A program that accepts an integer as an argument, doubles it and prints it.\n\nuse std::env;\n\nfn main() {\n    let mut argv = env::args();\n    let arg: String = argv.nth(1).unwrap(); // error 1\n    let n: i32 = arg.parse().unwrap(); // error 2\n    println!(\"{}\", 2 * n);\n}\n\n\nIf you give this program zero arguments (error 1) or if the first argument isn't an integer (error 2), the program will panic just like in the first example.\n\nYou can think of this style of error handling as similar to a bull running through a china shop. The bull will get to where it wants to go, but it will trample everything in the process.\n\nUnwrapping explained\n\nIn the previous example, we claimed that the program would simply panic if it reached one of the two error conditions, yet, the program does not include an explicit call to panic like the first example. This is because the panic is embedded in the calls to unwrap.\n\nTo ‚Äúunwrap‚Äù something in Rust is to say, ‚ÄúGive me the result of the computation, and if there was an error, panic and stop the program.‚Äù It would be better if we showed the code for unwrapping because it is so simple, but to do that, we will first need to explore the Option and Result types. Both of these types have a method called unwrap defined on them.\n\nThe Option type\n\nThe Option type is defined in the standard library:\n\n\nenum Option<T> {\n    None,\n    Some(T),\n}\n\nThe Option type is a way to use Rust's type system to express the possibility of absence. Encoding the possibility of absence into the type system is an important concept because it will cause the compiler to force the programmer to handle that absence. Let's take a look at an example that tries to find a character in a string:\n\n\n// Searches `haystack` for the Unicode character `needle`. If one is found, the\n// byte offset of the character is returned. Otherwise, `None` is returned.\nfn find(haystack: &str, needle: char) -> Option<usize> {\n    for (offset, c) in haystack.char_indices() {\n        if c == needle {\n            return Some(offset);\n        }\n    }\n    None\n}\n\nNotice that when this function finds a matching character, it doesn't only return the offset. Instead, it returns Some(offset). Some is a variant or a value constructor for the Option type. You can think of it as a function with the type fn<T>(value: T) -> Option<T>. Correspondingly, None is also a value constructor, except it has no arguments. You can think of None as a function with the type fn<T>() -> Option<T>.\n\nThis might seem like much ado about nothing, but this is only half of the story. The other half is using the find function we've written. Let's try to use it to find the extension in a file name.\n\nfn main() {\n    let file_name = \"foobar.rs\";\n    match find(file_name, '.') {\n        None => println!(\"No file extension found.\"),\n        Some(i) => println!(\"File extension: {}\", &file_name[i+1..]),\n    }\n}\n\n\nThis code uses pattern matching to do case analysis on the Option<usize> returned by the find function. In fact, case analysis is the only way to get at the value stored inside an Option<T>. This means that you, as the programmer, must handle the case when an Option<T> is None instead of Some(t).\n\nBut wait, what about unwrap, which we used previously? There was no case analysis there! Instead, the case analysis was put inside the unwrap method for you. You could define it yourself if you want:\n\n\nenum Option<T> {\n    None,\n    Some(T),\n}\n\nimpl<T> Option<T> {\n    fn unwrap(self) -> T {\n        match self {\n            Option::Some(val) => val,\n            Option::None =>\n              panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n}\n\nThe unwrap method abstracts away the case analysis. This is precisely the thing that makes unwrap ergonomic to use. Unfortunately, that panic! means that unwrap is not composable: it is the bull in the china shop.\n\nComposing Option<T> values\n\nIn an example from before, we saw how to use find to discover the extension in a file name. Of course, not all file names have a . in them, so it's possible that the file name has no extension. This possibility of absence is encoded into the types using Option<T>. In other words, the compiler will force us to address the possibility that an extension does not exist. In our case, we only print out a message saying as such.\n\nGetting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:\n\n\n// Returns the extension of the given file name, where the extension is defined\n// as all characters following the first `.`.\n// If `file_name` has no `.`, then `None` is returned.\nfn extension_explicit(file_name: &str) -> Option<&str> {\n    match find(file_name, '.') {\n        None => None,\n        Some(i) => Some(&file_name[i+1..]),\n    }\n}\n\n(Pro-tip: don't use this code. Use the extension method in the standard library instead.)\n\nThe code stays simple, but the important thing to notice is that the type of find forces us to consider the possibility of absence. This is a good thing because it means the compiler won't let us accidentally forget about the case where a file name doesn't have an extension. On the other hand, doing explicit case analysis like we've done in extension_explicit every time can get a bit tiresome.\n\nIn fact, the case analysis in extension_explicit follows a very common pattern: map a function on to the value inside of an Option<T>, unless the option is None, in which case, return None.\n\nRust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:\n\n\nfn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {\n    match option {\n        None => None,\n        Some(value) => Some(f(value)),\n    }\n}\n\nIndeed, map is defined as a method on Option<T> in the standard library. As a method, it has a slightly different signature: methods take self, &self, or &mut self as their first argument.\n\nArmed with our new combinator, we can rewrite our extension_explicit method to get rid of the case analysis:\n\n\n// Returns the extension of the given file name, where the extension is defined\n// as all characters following the first `.`.\n// If `file_name` has no `.`, then `None` is returned.\nfn extension(file_name: &str) -> Option<&str> {\n    find(file_name, '.').map(|i| &file_name[i+1..])\n}\n\nOne other pattern we commonly find is assigning a default value to the case when an Option value is None. For example, maybe your program assumes that the extension of a file is rs even if none is present. As you might imagine, the case analysis for this is not specific to file extensions - it can work with any Option<T>:\n\n\nfn unwrap_or<T>(option: Option<T>, default: T) -> T {\n    match option {\n        None => default,\n        Some(value) => value,\n    }\n}\n\nLike with map above, the standard library implementation is a method instead of a free function.\n\nThe trick here is that the default value must have the same type as the value that might be inside the Option<T>. Using it is dead simple in our case:\n\nfn main() {\n    assert_eq!(extension(\"foobar.csv\").unwrap_or(\"rs\"), \"csv\");\n    assert_eq!(extension(\"foobar\").unwrap_or(\"rs\"), \"rs\");\n}\n\n\n(Note that unwrap_or is defined as a method on Option<T> in the standard library, so we use that here instead of the free-standing function we defined above. Don't forget to check out the more general unwrap_or_else method.)\n\nThere is one more combinator that we think is worth paying special attention to: and_then. It makes it easy to compose distinct computations that admit the possibility of absence. For example, much of the code in this section is about finding an extension given a file name. In order to do this, you first need the file name which is typically extracted from a file path. While most file paths have a file name, not all of them do. For example, ., .. or /.\n\nSo, we are tasked with the challenge of finding an extension given a file path. Let's start with explicit case analysis:\n\n\nfn file_path_ext_explicit(file_path: &str) -> Option<&str> {\n    match file_name(file_path) {\n        None => None,\n        Some(name) => match extension(name) {\n            None => None,\n            Some(ext) => Some(ext),\n        }\n    }\n}\n\nfn file_name(file_path: &str) -> Option<&str> {\n  // Implementation elided.\n  unimplemented!()\n}\n\nYou might think that we could use the map combinator to reduce the case analysis, but its type doesn't quite fit...\n\nfn file_path_ext(file_path: &str) -> Option<&str> {\n    file_name(file_path).map(|x| extension(x)) // This causes a compilation error.\n}\n\n\nThe map function here wraps the value returned by the extension function inside an Option<_> and since the extension function itself returns an Option<&str> the expression file_name(file_path).map(|x| extension(x)) actually returns an Option<Option<&str>>.\n\nBut since file_path_ext just returns Option<&str> (and not Option<Option<&str>>) we get a compilation error.\n\nThe result of the function taken by map as input is always rewrapped with Some. Instead, we need something like map, but which allows the caller to return a Option<_> directly without wrapping it in another Option<_>.\n\nIts generic implementation is even simpler than map:\n\n\nfn and_then<F, T, A>(option: Option<T>, f: F) -> Option<A>\n        where F: FnOnce(T) -> Option<A> {\n    match option {\n        None => None,\n        Some(value) => f(value),\n    }\n}\n\nNow we can rewrite our file_path_ext function without explicit case analysis:\n\n\nfn file_path_ext(file_path: &str) -> Option<&str> {\n    file_name(file_path).and_then(extension)\n}\n\nSide note: Since and_then essentially works like map but returns an Option<_> instead of an Option<Option<_>> it is known as flatmap in some other languages.\n\nThe Option type has many other combinators defined in the standard library. It is a good idea to skim this list and familiarize yourself with what's available‚Äîthey can often reduce case analysis for you. Familiarizing yourself with these combinators will pay dividends because many of them are also defined (with similar semantics) for Result, which we will talk about next.\n\nCombinators make using types like Option ergonomic because they reduce explicit case analysis. They are also composable because they permit the caller to handle the possibility of absence in their own way. Methods like unwrap remove choices because they will panic if Option<T> is None.\n\nThe Result type\n\nThe Result type is also defined in the standard library:\n\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nThe Result type is a richer version of Option. Instead of expressing the possibility of absence like Option does, Result expresses the possibility of error. Usually, the error is used to explain why the execution of some computation failed. This is a strictly more general form of Option. Consider the following type alias, which is semantically equivalent to the real Option<T> in every way:\n\n\ntype Option<T> = Result<T, ()>;\n\nThis fixes the second type parameter of Result to always be () (pronounced ‚Äúunit‚Äù or ‚Äúempty tuple‚Äù). Exactly one value inhabits the () type: (). (Yup, the type and value level terms have the same notation!)\n\nThe Result type is a way of representing one of two possible outcomes in a computation. By convention, one outcome is meant to be expected or ‚ÄúOk‚Äù while the other outcome is meant to be unexpected or ‚ÄúErr‚Äù.\n\nJust like Option, the Result type also has an unwrap method defined in the standard library. Let's define it:\n\n\nimpl<T, E: ::std::fmt::Debug> Result<T, E> {\n    fn unwrap(self) -> T {\n        match self {\n            Result::Ok(val) => val,\n            Result::Err(err) =>\n              panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", err),\n        }\n    }\n}\n\nThis is effectively the same as our definition for Option::unwrap, except it includes the error value in the panic! message. This makes debugging easier, but it also requires us to add a Debug constraint on the E type parameter (which represents our error type). Since the vast majority of types should satisfy the Debug constraint, this tends to work out in practice. (Debug on a type simply means that there's a reasonable way to print a human-readable description of values with that type.)\n\nOK, let's move on to an example.\n\nParsing integers\n\nThe Rust standard library makes converting strings to integers dead simple. It's so easy in fact, that it is very tempting to write something like the following:\n\nfn double_number(number_str: &str) -> i32 {\n    2 * number_str.parse::<i32>().unwrap()\n}\n\nfn main() {\n    let n: i32 = double_number(\"10\");\n    assert_eq!(n, 20);\n}\n\n\nAt this point, you should be skeptical of calling unwrap. For example, if the string doesn't parse as a number, you'll get a panic:\n\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729\n\n\nThis is rather unsightly, and if this happened inside a library you're using, you might be understandably annoyed. Instead, we should try to handle the error in our function and let the caller decide what to do. This means changing the return type of double_number. But to what? Well, that requires looking at the signature of the parse method in the standard library:\n\nimpl str {\n    fn parse<F: FromStr>(&self) -> Result<F, F::Err>;\n}\n\n\nHmm. So we at least know that we need to use a Result. Certainly, it's possible that this could have returned an Option. After all, a string either parses as a number or it doesn't, right? That's certainly a reasonable way to go, but the implementation internally distinguishes why the string didn't parse as an integer. (Whether it's an empty string, an invalid digit, too big or too small.) Therefore, using a Result makes sense because we want to provide more information than simply ‚Äúabsence.‚Äù We want to say why the parsing failed. You should try to emulate this line of reasoning when faced with a choice between Option and Result. If you can provide detailed error information, then you probably should. (We'll see more on this later.)\n\nOK, but how do we write our return type? The parse method as defined above is generic over all the different number types defined in the standard library. We could (and probably should) also make our function generic, but let's favor explicitness for the moment. We only care about i32, so we need to find its implementation of FromStr (do a CTRL-F in your browser for ‚ÄúFromStr‚Äù) and look at its associated type Err. We did this so we can find the concrete error type. In this case, it's std::num::ParseIntError. Finally, we can rewrite our function:\n\nuse std::num::ParseIntError;\n\nfn double_number(number_str: &str) -> Result<i32, ParseIntError> {\n    match number_str.parse::<i32>() {\n        Ok(n) => Ok(2 * n),\n        Err(err) => Err(err),\n    }\n}\n\nfn main() {\n    match double_number(\"10\") {\n        Ok(n) => assert_eq!(n, 20),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n\n\nThis is a little better, but now we've written much more code! The case analysis has once again bitten us.\n\nCombinators to the rescue! Just like Option, Result has lots of combinators defined as methods. There is a large intersection of common combinators between Result and Option. In particular, map is part of that intersection:\n\nuse std::num::ParseIntError;\n\nfn double_number(number_str: &str) -> Result<i32, ParseIntError> {\n    number_str.parse::<i32>().map(|n| 2 * n)\n}\n\nfn main() {\n    match double_number(\"10\") {\n        Ok(n) => assert_eq!(n, 20),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n\n\nThe usual suspects are all there for Result, including unwrap_or and and_then. Additionally, since Result has a second type parameter, there are combinators that affect only the error type, such as map_err (instead of map) and or_else (instead of and_then).\n\nThe Result type alias idiom\n\nIn the standard library, you may frequently see types like Result<i32>. But wait, we defined Result to have two type parameters. How can we get away with only specifying one? The key is to define a Result type alias that fixes one of the type parameters to a particular type. Usually the fixed type is the error type. For example, our previous example parsing integers could be rewritten like this:\n\n\nuse std::num::ParseIntError;\nuse std::result;\n\ntype Result<T> = result::Result<T, ParseIntError>;\n\nfn double_number(number_str: &str) -> Result<i32> {\n    unimplemented!();\n}\n\nWhy would we do this? Well, if we have a lot of functions that could return ParseIntError, then it's much more convenient to define an alias that always uses ParseIntError so that we don't have to write it out all the time.\n\nThe most prominent place this idiom is used in the standard library is with io::Result. Typically, one writes io::Result<T>, which makes it clear that you're using the io module's type alias instead of the plain definition from std::result. (This idiom is also used for fmt::Result.)\n\nA brief interlude: unwrapping isn't evil\n\nIf you've been following along, you might have noticed that I've taken a pretty hard line against calling methods like unwrap that could panic and abort your program. Generally speaking, this is good advice.\n\nHowever, unwrap can still be used judiciously. What exactly justifies use of unwrap is somewhat of a grey area and reasonable people can disagree. I'll summarize some of my opinions on the matter.\n\nIn examples and quick 'n' dirty code. Sometimes you're writing examples or a quick program, and error handling simply isn't important. Beating the convenience of unwrap can be hard in such scenarios, so it is very appealing.\nWhen panicking indicates a bug in the program. When the invariants of your code should prevent a certain case from happening (like, say, popping from an empty stack), then panicking can be permissible. This is because it exposes a bug in your program. This can be explicit, like from an assert! failing, or it could be because your index into an array was out of bounds.\n\nThis is probably not an exhaustive list. Moreover, when using an Option, it is often better to use its expect method. expect does exactly the same thing as unwrap, except it prints a message you give to expect. This makes the resulting panic a bit nicer to deal with, since it will show your message instead of ‚Äúcalled unwrap on a None value.‚Äù\n\nMy advice boils down to this: use good judgment. There's a reason why the words ‚Äúnever do X‚Äù or ‚ÄúY is considered harmful‚Äù don't appear in my writing. There are trade-offs to all things, and it is up to you as the programmer to determine what is acceptable for your use cases. My goal is only to help you evaluate trade-offs as accurately as possible.\n\nNow that we've covered the basics of error handling in Rust, and explained unwrapping, let's start exploring more of the standard library.\n\nWorking with multiple error types\n\nThus far, we've looked at error handling where everything was either an Option<T> or a Result<T, SomeError>. But what happens when you have both an Option and a Result? Or what if you have a Result<T, Error1> and a Result<T, Error2>? Handling composition of distinct error types is the next challenge in front of us, and it will be the major theme throughout the rest of this section.\n\nComposing Option and Result\n\nSo far, I've talked about combinators defined for Option and combinators defined for Result. We can use these combinators to compose results of different computations without doing explicit case analysis.\n\nOf course, in real code, things aren't always as clean. Sometimes you have a mix of Option and Result types. Must we resort to explicit case analysis, or can we continue using combinators?\n\nFor now, let's revisit one of the first examples in this section:\n\nuse std::env;\n\nfn main() {\n    let mut argv = env::args();\n    let arg: String = argv.nth(1).unwrap(); // error 1\n    let n: i32 = arg.parse().unwrap(); // error 2\n    println!(\"{}\", 2 * n);\n}\n\n\nGiven our new found knowledge of Option, Result and their various combinators, we should try to rewrite this so that errors are handled properly and the program doesn't panic if there's an error.\n\nThe tricky aspect here is that argv.nth(1) produces an Option while arg.parse() produces a Result. These aren't directly composable. When faced with both an Option and a Result, the solution is usually to convert the Option to a Result. In our case, the absence of a command line parameter (from env::args()) means the user didn't invoke the program correctly. We could use a String to describe the error. Let's try:\n\nuse std::env;\n\nfn double_arg(mut argv: env::Args) -> Result<i32, String> {\n    argv.nth(1)\n        .ok_or(\"Please give at least one argument\".to_owned())\n        .and_then(|arg| arg.parse::<i32>().map_err(|err| err.to_string()))\n        .map(|n| 2 * n)\n}\n\nfn main() {\n    match double_arg(env::args()) {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nThere are a couple new things in this example. The first is the use of the Option::ok_or combinator. This is one way to convert an Option into a Result. The conversion requires you to specify what error to use if Option is None. Like the other combinators we've seen, its definition is very simple:\n\n\nfn ok_or<T, E>(option: Option<T>, err: E) -> Result<T, E> {\n    match option {\n        Some(val) => Ok(val),\n        None => Err(err),\n    }\n}\n\nThe other new combinator used here is Result::map_err. This is like Result::map, except it maps a function on to the error portion of a Result value. If the Result is an Ok(...) value, then it is returned unmodified.\n\nWe use map_err here because it is necessary for the error types to remain the same (because of our use of and_then). Since we chose to convert the Option<String> (from argv.nth(1)) to a Result<String, String>, we must also convert the ParseIntError from arg.parse() to a String.\n\nThe limits of combinators\n\nDoing IO and parsing input is a very common task, and it's one that I personally have done a lot of in Rust. Therefore, we will use (and continue to use) IO and various parsing routines to exemplify error handling.\n\nLet's start simple. We are tasked with opening a file, reading all of its contents and converting its contents to a number. Then we multiply it by 2 and print the output.\n\nAlthough I've tried to convince you not to use unwrap, it can be useful to first write your code using unwrap. It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling need to occur. Let's start there so we can get a handle on the code, and then refactor it to use better error handling.\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> i32 {\n    let mut file = File::open(file_path).unwrap(); // error 1\n    let mut contents = String::new();\n    file.read_to_string(&mut contents).unwrap(); // error 2\n    let n: i32 = contents.trim().parse().unwrap(); // error 3\n    2 * n\n}\n\nfn main() {\n    let doubled = file_double(\"foobar\");\n    println!(\"{}\", doubled);\n}\n\n\n(N.B. The AsRef<Path> is used because those are the same bounds used on std::fs::File::open. This makes it ergonomic to use any kind of string as a file path.)\n\nThere are three different errors that can occur here:\n\nA problem opening the file.\nA problem reading data from the file.\nA problem parsing the data as a number.\n\nThe first two problems are described via the std::io::Error type. We know this because of the return types of std::fs::File::open and std::io::Read::read_to_string. (Note that they both use the Result type alias idiom described previously. If you click on the Result type, you'll see the type alias, and consequently, the underlying io::Error type.) The third problem is described by the std::num::ParseIntError type. The io::Error type in particular is pervasive throughout the standard library. You will see it again and again.\n\nLet's start the process of refactoring the file_double function. To make this function composable with other components of the program, it should not panic if any of the above error conditions are met. Effectively, this means that the function should return an error if any of its operations fail. Our problem is that the return type of file_double is i32, which does not give us any useful way of reporting an error. Thus, we must start by changing the return type from i32 to something else.\n\nThe first thing we need to decide: should we use Option or Result? We certainly could use Option very easily. If any of the three errors occur, we could simply return None. This will work and it is better than panicking, but we can do much better. Instead, we should pass some detail about the error that occurred. Since we want to express the possibility of error, we should use Result<i32, E>. But what should E be? Since two different types of errors can occur, we need to convert them to a common type. One such type is String. Let's see how that impacts our code:\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    File::open(file_path)\n         .map_err(|err| err.to_string())\n         .and_then(|mut file| {\n              let mut contents = String::new();\n              file.read_to_string(&mut contents)\n                  .map_err(|err| err.to_string())\n                  .map(|_| contents)\n         })\n         .and_then(|contents| {\n              contents.trim().parse::<i32>()\n                      .map_err(|err| err.to_string())\n         })\n         .map(|n| 2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nThis code looks a bit hairy. It can take quite a bit of practice before code like this becomes easy to write. The way we write it is by following the types. As soon as we changed the return type of file_double to Result<i32, String>, we had to start looking for the right combinators. In this case, we only used three different combinators: and_then, map and map_err.\n\nand_then is used to chain multiple computations where each computation could return an error. After opening the file, there are two more computations that could fail: reading from the file and parsing the contents as a number. Correspondingly, there are two calls to and_then.\n\nmap is used to apply a function to the Ok(...) value of a Result. For example, the very last call to map multiplies the Ok(...) value (which is an i32) by 2. If an error had occurred before that point, this operation would have been skipped because of how map is defined.\n\nmap_err is the trick that makes all of this work. map_err is like map, except it applies a function to the Err(...) value of a Result. In this case, we want to convert all of our errors to one type: String. Since both io::Error and num::ParseIntError implement ToString, we can call the to_string() method to convert them.\n\nWith all of that said, the code is still hairy. Mastering use of combinators is important, but they have their limits. Let's try a different approach: early returns.\n\nEarly returns\n\nI'd like to take the code from the previous section and rewrite it using early returns. Early returns let you exit the function early. We can't return early in file_double from inside another closure, so we'll need to revert back to explicit case analysis.\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    let mut file = match File::open(file_path) {\n        Ok(file) => file,\n        Err(err) => return Err(err.to_string()),\n    };\n    let mut contents = String::new();\n    if let Err(err) = file.read_to_string(&mut contents) {\n        return Err(err.to_string());\n    }\n    let n: i32 = match contents.trim().parse() {\n        Ok(n) => n,\n        Err(err) => return Err(err.to_string()),\n    };\n    Ok(2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nReasonable people can disagree over whether this code is better than the code that uses combinators, but if you aren't familiar with the combinator approach, this code looks simpler to read to me. It uses explicit case analysis with match and if let. If an error occurs, it simply stops executing the function and returns the error (by converting it to string).\n\nIsn't this a step backwards though? Previously, we said that the key to ergonomic error handling is reducing explicit case analysis, yet we've reverted back to explicit case analysis here. It turns out, there are multiple ways to reduce explicit case analysis. Combinators aren't the only way.\n\nThe try! macro\n\nA cornerstone of error handling in Rust is the try! macro. The try! macro abstracts case analysis like combinators, but unlike combinators, it also abstracts control flow. Namely, it can abstract the early return pattern seen above.\n\nHere is a simplified definition of a try! macro:\n\n\nmacro_rules! try {\n    ($e:expr) => (match $e {\n        Ok(val) => val,\n        Err(err) => return Err(err),\n    });\n}\n\n(The real definition is a bit more sophisticated. We will address that later.)\n\nUsing the try! macro makes it very easy to simplify our last example. Since it does the case analysis and the early return for us, we get tighter code that is easier to read:\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));\n    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));\n    Ok(2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nThe map_err calls are still necessary given our definition of try!. This is because the error types still need to be converted to String. The good news is that we will soon learn how to remove those map_err calls! The bad news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove the map_err calls.\n\nDefining your own error type\n\nBefore we dive into some of the standard library error traits, I'd like to wrap up this section by removing the use of String as our error type in the previous examples.\n\nUsing String as we did in our previous examples is convenient because it's easy to convert errors to strings, or even make up your own errors as strings on the spot. However, using String for your errors has some downsides.\n\nThe first downside is that the error messages tend to clutter your code. It's possible to define the error messages elsewhere, but unless you're unusually disciplined, it is very tempting to embed the error message into your code. Indeed, we did exactly this in a previous example.\n\nThe second and more important downside is that Strings are lossy. That is, if all errors are converted to strings, then the errors we pass to the caller become completely opaque. The only reasonable thing the caller can do with a String error is show it to the user. Certainly, inspecting the string to determine the type of error is not robust. (Admittedly, this downside is far more important inside of a library as opposed to, say, an application.)\n\nFor example, the io::Error type embeds an io::ErrorKind, which is structured data that represents what went wrong during an IO operation. This is important because you might want to react differently depending on the error. (e.g., A BrokenPipe error might mean quitting your program gracefully while a NotFound error might mean exiting with an error code and showing an error to the user.) With io::ErrorKind, the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details of an error inside of a String.\n\nInstead of using a String as an error type in our previous example of reading an integer from a file, we can define our own error type that represents errors with structured data. We endeavor to not drop information from underlying errors in case the caller wants to inspect the details.\n\nThe ideal way to represent one of many possibilities is to define our own sum type using enum. In our case, an error is either an io::Error or a num::ParseIntError, so a natural definition arises:\n\n\nuse std::io;\nuse std::num;\n\n// We derive `Debug` because all types should probably derive `Debug`.\n// This gives us a reasonable human-readable description of `CliError` values.\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Parse(num::ParseIntError),\n}\n\nTweaking our code is very easy. Instead of converting errors to strings, we simply convert them to our CliError type using the corresponding value constructor:\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n    let mut file = try!(File::open(file_path).map_err(CliError::Io));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(CliError::Io));\n    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));\n    Ok(2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n\n\nThe only change here is switching map_err(|e| e.to_string()) (which converts errors to strings) to map_err(CliError::Io) or map_err(CliError::Parse). The caller gets to decide the level of detail to report to the user. In effect, using a String as an error type removes choices from the caller while using a custom enum error type like CliError gives the caller all of the conveniences as before in addition to structured data describing the error.\n\nA rule of thumb is to define your own error type, but a String error type will do in a pinch, particularly if you're writing an application. If you're writing a library, defining your own error type should be strongly preferred so that you don't remove choices from the caller unnecessarily.\n\nStandard library traits used for error handling\n\nThe standard library defines two integral traits for error handling: std::error::Error and std::convert::From. While Error is designed specifically for generically describing errors, the From trait serves a more general role for converting values between two distinct types.\n\nThe Error trait\n\nThe Error trait is defined in the standard library:\n\n\nuse std::fmt::{Debug, Display};\n\ntrait Error: Debug + Display {\n  /// A short description of the error.\n  fn description(&self) -> &str;\n\n  /// The lower level cause of this error, if any.\n  fn cause(&self) -> Option<&Error> { None }\n}\n\nThis trait is super generic because it is meant to be implemented for all types that represent errors. This will prove useful for writing composable code as we'll see later. Otherwise, the trait allows you to do at least the following things:\n\nObtain a Debug representation of the error.\nObtain a user-facing Display representation of the error.\nObtain a short description of the error (via the description method).\nInspect the causal chain of an error, if one exists (via the cause method).\n\nThe first two are a result of Error requiring impls for both Debug and Display. The latter two are from the two methods defined on Error. The power of Error comes from the fact that all error types impl Error, which means errors can be existentially quantified as a trait object. This manifests as either Box<Error> or &Error. Indeed, the cause method returns an &Error, which is itself a trait object. We'll revisit the Error trait's utility as a trait object later.\n\nFor now, it suffices to show an example implementing the Error trait. Let's use the error type we defined in the previous section:\n\n\nuse std::io;\nuse std::num;\n\n// We derive `Debug` because all types should probably derive `Debug`.\n// This gives us a reasonable human-readable description of `CliError` values.\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Parse(num::ParseIntError),\n}\n\nThis particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an error converting a string to a number. The error could represent as many error types as you want by adding new variants to the enum definition.\n\nImplementing Error is pretty straight-forward. It's mostly going to be a lot explicit case analysis.\n\nuse std::error;\nuse std::fmt;\n\nimpl fmt::Display for CliError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            // Both underlying errors already impl `Display`, so we defer to\n            // their implementations.\n            CliError::Io(ref err) => write!(f, \"IO error: {}\", err),\n            CliError::Parse(ref err) => write!(f, \"Parse error: {}\", err),\n        }\n    }\n}\n\nimpl error::Error for CliError {\n    fn description(&self) -> &str {\n        // Both underlying errors already impl `Error`, so we defer to their\n        // implementations.\n        match *self {\n            CliError::Io(ref err) => err.description(),\n            CliError::Parse(ref err) => err.description(),\n        }\n    }\n\n    fn cause(&self) -> Option<&error::Error> {\n        match *self {\n            // N.B. Both of these implicitly cast `err` from their concrete\n            // types (either `&io::Error` or `&num::ParseIntError`)\n            // to a trait object `&Error`. This works because both error types\n            // implement `Error`.\n            CliError::Io(ref err) => Some(err),\n            CliError::Parse(ref err) => Some(err),\n        }\n    }\n}\n\n\nWe note that this is a very typical implementation of Error: match on your different error types and satisfy the contracts defined for description and cause.\n\nThe From trait\n\nThe std::convert::From trait is defined in the standard library:\n\n\ntrait From<T> {\n    fn from(T) -> Self;\n}\n\nDeliciously simple, yes? From is very useful because it gives us a generic way to talk about conversion from a particular type T to some other type (in this case, ‚Äúsome other type‚Äù is the subject of the impl, or Self). The crux of From is the set of implementations provided by the standard library.\n\nHere are a few simple examples demonstrating how From works:\n\n\nlet string: String = From::from(\"foo\");\nlet bytes: Vec<u8> = From::from(\"foo\");\nlet cow: ::std::borrow::Cow<str> = From::from(\"foo\");\n\nOK, so From is useful for converting between strings. But what about errors? It turns out, there is one critical impl:\n\nimpl<'a, E: Error + 'a> From<E> for Box<Error + 'a>\n\n\nThis impl says that for any type that impls Error, we can convert it to a trait object Box<Error>. This may not seem terribly surprising, but it is useful in a generic context.\n\nRemember the two errors we were dealing with previously? Specifically, io::Error and num::ParseIntError. Since both impl Error, they work with From:\n\n\nuse std::error::Error;\nuse std::fs;\nuse std::io;\nuse std::num;\n\n// We have to jump through some hoops to actually get error values:\nlet io_err: io::Error = io::Error::last_os_error();\nlet parse_err: num::ParseIntError = \"not a number\".parse::<i32>().unwrap_err();\n\n// OK, here are the conversions:\nlet err1: Box<Error> = From::from(io_err);\nlet err2: Box<Error> = From::from(parse_err);\n\nThere is a really important pattern to recognize here. Both err1 and err2 have the same type. This is because they are existentially quantified types, or trait objects. In particular, their underlying type is erased from the compiler's knowledge, so it truly sees err1 and err2 as exactly the same. Additionally, we constructed err1 and err2 using precisely the same function call: From::from. This is because From::from is overloaded on both its argument and its return type.\n\nThis pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the same type using the same function.\n\nTime to revisit an old friend; the try! macro.\n\nThe real try! macro\n\nPreviously, we presented this definition of try!:\n\n\nmacro_rules! try {\n    ($e:expr) => (match $e {\n        Ok(val) => val,\n        Err(err) => return Err(err),\n    });\n}\n\nThis is not its real definition. Its real definition is in the standard library:\n\n\nmacro_rules! try {\n    ($e:expr) => (match $e {\n        Ok(val) => val,\n        Err(err) => return Err(::std::convert::From::from(err)),\n    });\n}\n\nThere's one tiny but powerful change: the error value is passed through From::from. This makes the try! macro much more powerful because it gives you automatic type conversion for free.\n\nArmed with our more powerful try! macro, let's take a look at code we wrote previously to read a file and convert its contents to an integer:\n\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));\n    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));\n    Ok(2 * n)\n}\n\nEarlier, we promised that we could get rid of the map_err calls. Indeed, all we have to do is pick a type that From works with. As we saw in the previous section, From has an impl that lets it convert any error type into a Box<Error>:\n\n\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, Box<Error>> {\n    let mut file = try!(File::open(file_path));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents));\n    let n = try!(contents.trim().parse::<i32>());\n    Ok(2 * n)\n}\n\nWe are getting very close to ideal error handling. Our code has very little overhead as a result from error handling because the try! macro encapsulates three things simultaneously:\n\nCase analysis.\nControl flow.\nError type conversion.\n\nWhen all three things are combined, we get code that is unencumbered by combinators, calls to unwrap or case analysis.\n\nThere's one little nit left: the Box<Error> type is opaque. If we return a Box<Error> to the caller, the caller can't (easily) inspect underlying error type. The situation is certainly better than String because the caller can call methods like description and cause, but the limitation remains: Box<Error> is opaque. (N.B. This isn't entirely true because Rust does have runtime reflection, which is useful in some scenarios that are beyond the scope of this section.)\n\nIt's time to revisit our custom CliError type and tie everything together.\n\nComposing custom error types\n\nIn the last section, we looked at the real try! macro and how it does automatic type conversion for us by calling From::from on the error value. In particular, we converted errors to Box<Error>, which works, but the type is opaque to callers.\n\nTo fix this, we use the same remedy that we're already familiar with: a custom error type. Once again, here is the code that reads the contents of a file and converts it to an integer:\n\n\nuse std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\nuse std::path::Path;\n\n// We derive `Debug` because all types should probably derive `Debug`.\n// This gives us a reasonable human-readable description of `CliError` values.\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Parse(num::ParseIntError),\n}\n\nfn file_double_verbose<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n    let mut file = try!(File::open(file_path).map_err(CliError::Io));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(CliError::Io));\n    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));\n    Ok(2 * n)\n}\n\nNotice that we still have the calls to map_err. Why? Well, recall the definitions of try! and From. The problem is that there is no From impl that allows us to convert from error types like io::Error and num::ParseIntError to our own custom CliError. Of course, it is easy to fix this! Since we defined CliError, we can impl From with it:\n\n\nuse std::io;\nuse std::num;\n\nimpl From<io::Error> for CliError {\n    fn from(err: io::Error) -> CliError {\n        CliError::Io(err)\n    }\n}\n\nimpl From<num::ParseIntError> for CliError {\n    fn from(err: num::ParseIntError) -> CliError {\n        CliError::Parse(err)\n    }\n}\n\nAll these impls are doing is teaching From how to create a CliError from other error types. In our case, construction is as simple as invoking the corresponding value constructor. Indeed, it is typically this easy.\n\nWe can finally rewrite file_double:\n\n\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n    let mut file = try!(File::open(file_path));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents));\n    let n: i32 = try!(contents.trim().parse());\n    Ok(2 * n)\n}\n\nThe only thing we did here was remove the calls to map_err. They are no longer needed because the try! macro invokes From::from on the error value. This works because we've provided From impls for all the error types that could appear.\n\nIf we modified our file_double function to perform some other operation, say, convert a string to a float, then we'd need to add a new variant to our error type:\n\n\nuse std::io;\nuse std::num;\n\nenum CliError {\n    Io(io::Error),\n    ParseInt(num::ParseIntError),\n    ParseFloat(num::ParseFloatError),\n}\n\nAnd add a new From impl:\n\n\n\nuse std::num;\n\nimpl From<num::ParseFloatError> for CliError {\n    fn from(err: num::ParseFloatError) -> CliError {\n        CliError::ParseFloat(err)\n    }\n}\n\nAnd that's it!\n\nAdvice for library writers\n\nIf your library needs to report custom errors, then you should probably define your own error type. It's up to you whether or not to expose its representation (like ErrorKind) or keep it hidden (like ParseIntError). Regardless of how you do it, it's usually good practice to at least provide some information about the error beyond its String representation. But certainly, this will vary depending on use cases.\n\nAt a minimum, you should probably implement the Error trait. This will give users of your library some minimum flexibility for composing errors. Implementing the Error trait also means that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both fmt::Debug and fmt::Display).\n\nBeyond that, it can also be useful to provide implementations of From on your error types. This allows you (the library author) and your users to compose more detailed errors. For example, csv::Error provides From impls for both io::Error and byteorder::Error.\n\nFinally, depending on your tastes, you may also want to define a Result type alias, particularly if your library defines a single error type. This is used in the standard library for io::Result and fmt::Result.\n\nCase study: A program to read population data\n\nThis section was long, and depending on your background, it might be rather dense. While there is plenty of example code to go along with the prose, most of it was specifically designed to be pedagogical. So, we're going to do something new: a case study.\n\nFor this, we're going to build up a command line program that lets you query world population data. The objective is simple: you give it a location and it will tell you the population. Despite the simplicity, there is a lot that can go wrong!\n\nThe data we'll be using comes from the Data Science Toolkit. I've prepared some data from it for this exercise. You can either grab the world population data (41MB gzip compressed, 145MB uncompressed) or only the US population data (2.2MB gzip compressed, 7.2MB uncompressed).\n\nUp until now, we've kept the code limited to Rust's standard library. For a real task like this though, we'll want to at least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically. For that, we'll use the csv, and rustc-serialize crates.\n\nInitial setup\n\nWe're not going to spend a lot of time on setting up a project with Cargo because it is already covered well in the Cargo section and Cargo's documentation.\n\nTo get started from scratch, run cargo new --bin city-pop and make sure your Cargo.toml looks something like this:\n\n[package]\nname = \"city-pop\"\nversion = \"0.1.0\"\nauthors = [\"Andrew Gallant <jamslam@gmail.com>\"]\n\n[[bin]]\nname = \"city-pop\"\n\n[dependencies]\ncsv = \"0.*\"\nrustc-serialize = \"0.*\"\ngetopts = \"0.*\"\n\n\nYou should already be able to run:\n\ncargo build --release\n./target/release/city-pop\n# Outputs: Hello, world!\n\nArgument parsing\n\nLet's get argument parsing out of the way. We won't go into too much detail on Getopts, but there is some good documentation describing it. The short story is that Getopts generates an argument parser and a help message from a vector of options (The fact that it is a vector is hidden behind a struct and a set of methods). Once the parsing is done, the parser returns a struct that records matches for defined options, and remaining \"free\" arguments. From there, we can get information about the flags, for instance, whether they were passed in, and what arguments they had. Here's our program with the appropriate extern crate statements, and the basic argument setup for Getopts:\n\nextern crate getopts;\nextern crate rustc_serialize;\n\nuse getopts::Options;\nuse std::env;\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let program = &args[0];\n\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m)  => { m }\n        Err(e) => { panic!(e.to_string()) }\n    };\n    if matches.opt_present(\"h\") {\n        print_usage(&program, opts);\n        return;\n    }\n    let data_path = &matches.free[0];\n    let city: &str = &matches.free[1];\n\n    // Do stuff with information.\n}\n\n\nFirst, we get a vector of the arguments passed into our program. We then store the first one, knowing that it is our program's name. Once that's done, we set up our argument flags, in this case a simplistic help message flag. Once we have the argument flags set up, we use Options.parse to parse the argument vector (starting from index one, because index 0 is the program name). If this was successful, we assign matches to the parsed object, if not, we panic. Once past that, we test if the user passed in the help flag, and if so print the usage message. The option help messages are constructed by Getopts, so all we have to do to print the usage message is tell it what we want it to print for the program name and template. If the user has not passed in the help flag, we assign the proper variables to their corresponding arguments.\n\nWriting the logic\n\nWe all write code differently, but error handling is usually the last thing we want to think about. This isn't great for the overall design of a program, but it can be useful for rapid prototyping. Because Rust forces us to be explicit about error handling (by making us call unwrap), it is easy to see which parts of our program can cause errors.\n\nIn this case study, the logic is really simple. All we need to do is parse the CSV data given to us and print out a field in matching rows. Let's do it. (Make sure to add extern crate csv; to the top of your file.)\n\nuse std::fs::File;\n\n// This struct represents the data in each row of the CSV file.\n// Type based decoding absolves us of a lot of the nitty-gritty error\n// handling, like parsing strings as integers or floats.\n#[derive(Debug, RustcDecodable)]\nstruct Row {\n    country: String,\n    city: String,\n    accent_city: String,\n    region: String,\n\n    // Not every row has data for the population, latitude or longitude!\n    // So we express them as `Option` types, which admits the possibility of\n    // absence. The CSV parser will fill in the correct value for us.\n    population: Option<u64>,\n    latitude: Option<f64>,\n    longitude: Option<f64>,\n}\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let program = &args[0];\n\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m)  => { m }\n        Err(e) => { panic!(e.to_string()) }\n    };\n\n    if matches.opt_present(\"h\") {\n        print_usage(&program, opts);\n        return;\n    }\n\n    let data_path = &matches.free[0];\n    let city: &str = &matches.free[1];\n\n    let file = File::open(data_path).unwrap();\n    let mut rdr = csv::Reader::from_reader(file);\n\n    for row in rdr.decode::<Row>() {\n        let row = row.unwrap();\n\n        if row.city == city {\n            println!(\"{}, {}: {:?}\",\n                row.city, row.country,\n                row.population.expect(\"population count\"));\n        }\n    }\n}\n\n\nLet's outline the errors. We can start with the obvious: the three places that unwrap is called:\n\nFile::open can return an io::Error.\ncsv::Reader::decode decodes one record at a time, and decoding a record (look at the Item associated type on the Iterator impl) can produce a csv::Error.\nIf row.population is None, then calling expect will panic.\n\nAre there any others? What if we can't find a matching city? Tools like grep will return an error code, so we probably should too. So we have logic errors specific to our problem, IO errors and CSV parsing errors. We're going to explore two different ways to approach handling these errors.\n\nI'd like to start with Box<Error>. Later, we'll see how defining our own error type can be useful.\n\nError handling with Box<Error>\n\nBox<Error> is nice because it just works. You don't need to define your own error types and you don't need any From implementations. The downside is that since Box<Error> is a trait object, it erases the type, which means the compiler can no longer reason about its underlying type.\n\nPreviously we started refactoring our code by changing the type of our function from T to Result<T, OurErrorType>. In this case, OurErrorType is only Box<Error>. But what's T? And can we add a return type to main?\n\nThe answer to the second question is no, we can't. That means we'll need to write a new function. But what is T? The simplest thing we can do is to return a list of matching Row values as a Vec<Row>. (Better code would return an iterator, but that is left as an exercise to the reader.)\n\nLet's refactor our code into its own function, but keep the calls to unwrap. Note that we opt to handle the possibility of a missing population count by simply ignoring that row.\n\nuse std::path::Path;\n\nstruct Row {\n    // This struct remains unchanged.\n}\n\nstruct PopulationCount {\n    city: String,\n    country: String,\n    // This is no longer an `Option` because values of this type are only\n    // constructed if they have a population count.\n    count: u64,\n}\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n}\n\nfn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {\n    let mut found = vec![];\n    let file = File::open(file_path).unwrap();\n    let mut rdr = csv::Reader::from_reader(file);\n    for row in rdr.decode::<Row>() {\n        let row = row.unwrap();\n        match row.population {\n            None => { } // Skip it.\n            Some(count) => if row.city == city {\n                found.push(PopulationCount {\n                    city: row.city,\n                    country: row.country,\n                    count: count,\n                });\n            },\n        }\n    }\n    found\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let program = &args[0];\n\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m)  => { m }\n        Err(e) => { panic!(e.to_string()) }\n    };\n\n    if matches.opt_present(\"h\") {\n        print_usage(&program, opts);\n        return;\n    }\n\n    let data_path = &matches.free[0];\n    let city: &str = &matches.free[1];\n\n    for pop in search(data_path, city) {\n        println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n    }\n}\n\n\n\nWhile we got rid of one use of expect (which is a nicer variant of unwrap), we still should handle the absence of any search results.\n\nTo convert this to proper error handling, we need to do the following:\n\nChange the return type of search to be Result<Vec<PopulationCount>, Box<Error>>.\nUse the try! macro so that errors are returned to the caller instead of panicking the program.\nHandle the error in main.\n\nLet's try it:\n\nuse std::error::Error;\n\n// The rest of the code before this is unchanged.\n\nfn search<P: AsRef<Path>>\n         (file_path: P, city: &str)\n         -> Result<Vec<PopulationCount>, Box<Error>> {\n    let mut found = vec![];\n    let file = try!(File::open(file_path));\n    let mut rdr = csv::Reader::from_reader(file);\n    for row in rdr.decode::<Row>() {\n        let row = try!(row);\n        match row.population {\n            None => { } // Skip it.\n            Some(count) => if row.city == city {\n                found.push(PopulationCount {\n                    city: row.city,\n                    country: row.country,\n                    count: count,\n                });\n            },\n        }\n    }\n    if found.is_empty() {\n        Err(From::from(\"No matching cities with a population were found.\"))\n    } else {\n        Ok(found)\n    }\n}\n\n\nInstead of x.unwrap(), we now have try!(x). Since our function returns a Result<T, E>, the try! macro will return early from the function if an error occurs.\n\nAt the end of search we also convert a plain string to an error type by using the corresponding From impls:\n\n// We are making use of this impl in the code above, since we call `From::from`\n// on a `&'static str`.\nimpl<'a> From<&'a str> for Box<Error>\n\n// But this is also useful when you need to allocate a new string for an\n// error message, usually with `format!`.\nimpl From<String> for Box<Error>\n\n\nSince search now returns a Result<T, E>, main should use case analysis when calling search:\n\n...\n    match search(data_path, city) {\n        Ok(pops) => {\n            for pop in pops {\n                println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n            }\n        }\n        Err(err) => println!(\"{}\", err)\n    }\n...\n\n\nNow that we've seen how to do proper error handling with Box<Error>, let's try a different approach with our own custom error type. But first, let's take a quick break from error handling and add support for reading from stdin.\n\nReading from stdin\n\nIn our program, we accept a single file for input and do one pass over the data. This means we probably should be able to accept input on stdin. But maybe we like the current format too‚Äîso let's have both!\n\nAdding support for stdin is actually quite easy. There are only three things we have to do:\n\nTweak the program arguments so that a single parameter‚Äîthe city‚Äîcan be accepted while the population data is read from stdin.\nModify the program so that an option -f can take the file, if it is not passed into stdin.\nModify the search function to take an optional file path. When None, it should know to read from stdin.\n\nFirst, here's the new usage:\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <city>\", program)));\n}\n\n\nOf course we need to adapt the argument handling code:\n\n...\n    let mut opts = Options::new();\n    opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n    ...\n    let data_path = matches.opt_str(\"f\");\n\n    let city = if !matches.free.is_empty() {\n        &matches.free[0]\n    } else {\n        print_usage(&program, opts);\n        return;\n    };\n\n    match search(&data_path, city) {\n        Ok(pops) => {\n            for pop in pops {\n                println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n            }\n        }\n        Err(err) => println!(\"{}\", err)\n    }\n...\n\n\nWe've made the user experience a bit nicer by showing the usage message, instead of a panic from an out-of-bounds index, when city, the remaining free argument, is not present.\n\nModifying search is slightly trickier. The csv crate can build a parser out of any type that implements io::Read. But how can we use the same code over both types? There's actually a couple ways we could go about this. One way is to write search such that it is generic on some type parameter R that satisfies io::Read. Another way is to use trait objects:\n\nuse std::io;\n\n// The rest of the code before this is unchanged.\n\nfn search<P: AsRef<Path>>\n         (file_path: &Option<P>, city: &str)\n         -> Result<Vec<PopulationCount>, Box<Error>> {\n    let mut found = vec![];\n    let input: Box<io::Read> = match *file_path {\n        None => Box::new(io::stdin()),\n        Some(ref file_path) => Box::new(try!(File::open(file_path))),\n    };\n    let mut rdr = csv::Reader::from_reader(input);\n    // The rest remains unchanged!\n}\n\nError handling with a custom type\n\nPreviously, we learned how to compose errors using a custom error type. We did this by defining our error type as an enum and implementing Error and From.\n\nSince we have three distinct errors (IO, CSV parsing and not found), let's define an enum with three variants:\n\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Csv(csv::Error),\n    NotFound,\n}\n\n\nAnd now for impls on Display and Error:\n\nuse std::fmt;\n\nimpl fmt::Display for CliError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            CliError::Io(ref err) => err.fmt(f),\n            CliError::Csv(ref err) => err.fmt(f),\n            CliError::NotFound => write!(f, \"No matching cities with a \\\n                                             population were found.\"),\n        }\n    }\n}\n\nimpl Error for CliError {\n    fn description(&self) -> &str {\n        match *self {\n            CliError::Io(ref err) => err.description(),\n            CliError::Csv(ref err) => err.description(),\n            CliError::NotFound => \"not found\",\n        }\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        match *self {\n            CliError::Io(ref err) => Some(err),\n            CliError::Csv(ref err) => Some(err),\n            // Our custom error doesn't have an underlying cause,\n            // but we could modify it so that it does.\n            CliError::NotFound => None,\n        }\n    }\n}\n\n\nBefore we can use our CliError type in our search function, we need to provide a couple From impls. How do we know which impls to provide? Well, we'll need to convert from both io::Error and csv::Error to CliError. Those are the only external errors, so we'll only need two From impls for now:\n\nimpl From<io::Error> for CliError {\n    fn from(err: io::Error) -> CliError {\n        CliError::Io(err)\n    }\n}\n\nimpl From<csv::Error> for CliError {\n    fn from(err: csv::Error) -> CliError {\n        CliError::Csv(err)\n    }\n}\n\n\nThe From impls are important because of how try! is defined. In particular, if an error occurs, From::from is called on the error, which in this case, will convert it to our own error type CliError.\n\nWith the From impls done, we only need to make two small tweaks to our search function: the return type and the ‚Äúnot found‚Äù error. Here it is in full:\n\nfn search<P: AsRef<Path>>\n         (file_path: &Option<P>, city: &str)\n         -> Result<Vec<PopulationCount>, CliError> {\n    let mut found = vec![];\n    let input: Box<io::Read> = match *file_path {\n        None => Box::new(io::stdin()),\n        Some(ref file_path) => Box::new(try!(File::open(file_path))),\n    };\n    let mut rdr = csv::Reader::from_reader(input);\n    for row in rdr.decode::<Row>() {\n        let row = try!(row);\n        match row.population {\n            None => { } // Skip it.\n            Some(count) => if row.city == city {\n                found.push(PopulationCount {\n                    city: row.city,\n                    country: row.country,\n                    count: count,\n                });\n            },\n        }\n    }\n    if found.is_empty() {\n        Err(CliError::NotFound)\n    } else {\n        Ok(found)\n    }\n}\n\n\nNo other changes are necessary.\n\nAdding functionality\n\nWriting generic code is great, because generalizing stuff is cool, and it can then be useful later. But sometimes, the juice isn't worth the squeeze. Look at what we just did in the previous step:\n\nDefined a new error type.\nAdded impls for Error, Display and two for From.\n\nThe big downside here is that our program didn't improve a whole lot. There is quite a bit of overhead to representing errors with enums, especially in short programs like this.\n\nOne useful aspect of using a custom error type like we've done here is that the main function can now choose to handle errors differently. Previously, with Box<Error>, it didn't have much of a choice: just print the message. We're still doing that here, but what if we wanted to, say, add a --quiet flag? The --quiet flag should silence any verbose output.\n\nRight now, if the program doesn't find a match, it will output a message saying so. This can be a little clumsy, especially if you intend for the program to be used in shell scripts.\n\nSo let's start by adding the flags. Like before, we need to tweak the usage string and add a flag to the Option variable. Once we've done that, Getopts does the rest:\n\n...\n    let mut opts = Options::new();\n    opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n    opts.optflag(\"q\", \"quiet\", \"Silences errors and warnings.\");\n...\n\n\nNow we only need to implement our ‚Äúquiet‚Äù functionality. This requires us to tweak the case analysis in main:\n\nuse std::process;\n...\n    match search(&data_path, city) {\n        Err(CliError::NotFound) if matches.opt_present(\"q\") => process::exit(1),\n        Err(err) => panic!(\"{}\", err),\n        Ok(pops) => for pop in pops {\n            println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n        }\n    }\n...\n\n\nCertainly, we don't want to be quiet if there was an IO error or if the data failed to parse. Therefore, we use case analysis to check if the error type is NotFound and if --quiet has been enabled. If the search failed, we still quit with an exit code (following grep's convention).\n\nIf we had stuck with Box<Error>, then it would be pretty tricky to implement the --quiet functionality.\n\nThis pretty much sums up our case study. From here, you should be ready to go out into the world and write your own programs and libraries with proper error handling.\n\nThe Short Story\n\nSince this section is long, it is useful to have a quick summary for error handling in Rust. These are some good ‚Äúrules of thumb.\" They are emphatically not commandments. There are probably good reasons to break every one of these heuristics!\n\nIf you're writing short example code that would be overburdened by error handling, it's probably fine to use unwrap (whether that's Result::unwrap, Option::unwrap or preferably Option::expect). Consumers of your code should know to use proper error handling. (If they don't, send them here!)\nIf you're writing a quick 'n' dirty program, don't feel ashamed if you use unwrap. Be warned: if it winds up in someone else's hands, don't be surprised if they are agitated by poor error messages!\nIf you're writing a quick 'n' dirty program and feel ashamed about panicking anyway, then use either a String or a Box<Error> for your error type.\nOtherwise, in a program, define your own error types with appropriate From and Error impls to make the try! macro more ergonomic.\nIf you're writing a library and your code can produce errors, define your own error type and implement the std::error::Error trait. Where appropriate, implement From to make both your library code and the caller's code easier to write. (Because of Rust's coherence rules, callers will not be able to impl From on your error type, so your library should do it.)\nLearn the combinators defined on Option and Result. Using them exclusively can be a bit tiring at times, but I've personally found a healthy mix of try! and combinators to be quite appealing. and_then, map and unwrap_or are my favorites.\nChoosing your Guarantees\n\nOne important feature of Rust is that it lets us control the costs and guarantees of a program.\n\nThere are various ‚Äúwrapper type‚Äù abstractions in the Rust standard library which embody a multitude of trade-offs between cost, ergonomics, and guarantees. Many let one choose between run-time and compile-time enforcement. This section will explain a few selected abstractions in detail.\n\nBefore proceeding, it is highly recommended that one reads about ownership and borrowing in Rust.\n\nBasic pointer types\nBox<T>\n\nBox<T> is an ‚Äúowned‚Äù pointer, or a ‚Äúbox‚Äù. While it can hand out references to the contained data, it is the only owner of the data. In particular, consider the following:\n\n\nlet x = Box::new(1);\nlet y = x;\n// `x` is no longer accessible here.\n\nHere, the box was moved into y. As x no longer owns it, the compiler will no longer allow the programmer to use x after this. A box can similarly be moved out of a function by returning it.\n\nWhen a box (that hasn't been moved) goes out of scope, destructors are run. These destructors take care of deallocating the inner data.\n\nThis is a zero-cost abstraction for dynamic allocation. If you want to allocate some memory on the heap and safely pass around a pointer to that memory, this is ideal. Note that you will only be allowed to share references to this by the regular borrowing rules, checked at compile time.\n\n&T and &mut T\n\nThese are immutable and mutable references respectively. They follow the ‚Äúread-write lock‚Äù pattern, such that one may either have only one mutable reference to some data, or any number of immutable ones, but not both. This guarantee is enforced at compile time, and has no visible cost at runtime. In most cases these two pointer types suffice for sharing cheap references between sections of code.\n\nThese pointers cannot be copied in such a way that they outlive the lifetime associated with them.\n\n*const T and *mut T\n\nThese are C-like raw pointers with no lifetime or ownership attached to them. They point to some location in memory with no other restrictions. The only guarantee that these provide is that they cannot be dereferenced except in code marked unsafe.\n\nThese are useful when building safe, low cost abstractions like Vec<T>, but should be avoided in safe code.\n\nRc<T>\n\nThis is the first wrapper we will cover that has a runtime cost.\n\nRc<T> is a reference counted pointer. In other words, this lets us have multiple \"owning\" pointers to the same data, and the data will be dropped (destructors will be run) when all pointers are out of scope.\n\nInternally, it contains a shared ‚Äúreference count‚Äù (also called ‚Äúrefcount‚Äù), which is incremented each time the Rc is cloned, and decremented each time one of the Rcs goes out of scope. The main responsibility of Rc<T> is to ensure that destructors are called for shared data.\n\nThe internal data here is immutable, and if a cycle of references is created, the data will be leaked. If we want data that doesn't leak when there are cycles, we need a garbage collector.\n\nGuarantees\n\nThe main guarantee provided here is that the data will not be destroyed until all references to it are out of scope.\n\nThis should be used when we wish to dynamically allocate and share some data (read-only) between various portions of your program, where it is not certain which portion will finish using the pointer last. It's a viable alternative to &T when &T is either impossible to statically check for correctness, or creates extremely unergonomic code where the programmer does not wish to spend the development cost of working with.\n\nThis pointer is not thread-safe, and Rust will not let it be sent or shared with other threads. This lets one avoid the cost of atomics in situations where they are unnecessary.\n\nThere is a sister smart pointer to this one, Weak<T>. This is a non-owning, but also non-borrowed, smart pointer. It is also similar to &T, but it is not restricted in lifetime‚Äîa Weak<T> can be held on to forever. However, it is possible that an attempt to access the inner data may fail and return None, since this can outlive the owned Rcs. This is useful for cyclic data structures and other things.\n\nCost\n\nAs far as memory goes, Rc<T> is a single allocation, though it will allocate two extra words (i.e. two usize values) as compared to a regular Box<T> (for \"strong\" and \"weak\" refcounts).\n\nRc<T> has the computational cost of incrementing/decrementing the refcount whenever it is cloned or goes out of scope respectively. Note that a clone will not do a deep copy, rather it will simply increment the inner reference count and return a copy of the Rc<T>.\n\nCell types\n\nCells provide interior mutability. In other words, they contain data which can be manipulated even if the type cannot be obtained in a mutable form (for example, when it is behind an &-ptr or Rc<T>).\n\nThe documentation for the cell module has a pretty good explanation for these.\n\nThese types are generally found in struct fields, but they may be found elsewhere too.\n\nCell<T>\n\nCell<T> is a type that provides zero-cost interior mutability by moving data in and out of the cell. Since the compiler knows that all the data owned by the contained value is on the stack, there's no worry of leaking any data behind references (or worse!) by simply replacing the data.\n\nIt is still possible to violate your own invariants using this wrapper, so be careful when using it. If a field is wrapped in Cell, it's a nice indicator that the chunk of data is mutable and may not stay the same between the time you first read it and when you intend to use it.\n\n\nuse std::cell::Cell;\n\nlet x = Cell::new(1);\nlet y = &x;\nlet z = &x;\nx.set(2);\ny.set(3);\nz.set(4);\nprintln!(\"{}\", x.get());\n\nNote that here we were able to mutate the same value from various immutable references.\n\nThis has the same runtime cost as the following:\n\nlet mut x = 1;\nlet y = &mut x;\nlet z = &mut x;\nx = 2;\n*y = 3;\n*z = 4;\nprintln!(\"{}\", x);\n\n\nbut it has the added benefit of actually compiling successfully.\n\nGuarantees\n\nThis relaxes the ‚Äúno aliasing with mutability‚Äù restriction in places where it's unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your invariants depend on data stored within Cell, you should be careful.\n\nThis is useful for mutating primitives and other types when there is no easy way of doing it in line with the static rules of & and &mut.\n\nCell does not let you obtain interior references to the data, which makes it safe to freely mutate.\n\nCost\n\nThere is no runtime cost to using Cell<T>, however if you are using it to wrap larger structs, it might be worthwhile to instead wrap individual fields in Cell<T> since each write is otherwise a full copy of the struct.\n\nRefCell<T>\n\nRefCell<T> also provides interior mutability, but doesn't move data in and out of the cell.\n\nHowever, it has a runtime cost. RefCell<T> enforces the read-write lock pattern at runtime (it's like a single-threaded mutex), unlike &T/&mut T which do so at compile time. This is done by the borrow() and borrow_mut() functions, which modify an internal reference count and return smart pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when the smart pointers go out of scope. With this system, we can dynamically ensure that there are never any other borrows active when a mutable borrow is active. If the programmer attempts to make such a borrow, the thread will panic.\n\n\nuse std::cell::RefCell;\n\nlet x = RefCell::new(vec![1,2,3,4]);\n{\n    println!(\"{:?}\", *x.borrow())\n}\n\n{\n    let mut my_ref = x.borrow_mut();\n    my_ref.push(1);\n}\n\nSimilar to Cell, this is mainly useful for situations where it's hard or impossible to satisfy the borrow checker. Generally we know that such mutations won't happen in a nested form, but it's good to check.\n\nFor large, complicated programs, it becomes useful to put some things in RefCells to make things simpler. For example, a lot of the maps in the ctxt struct in the Rust compiler internals are inside this wrapper. These are only modified once (during creation, which is not right after initialization) or a couple of times in well-separated places. However, since this struct is pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps impossible) and probably form a soup of &-ptrs which would be hard to extend. On the other hand, the RefCell provides a cheap (not zero-cost) way of safely accessing these. In the future, if someone adds some code that attempts to modify the cell when it's already borrowed, it will cause a (usually deterministic) panic which can be traced back to the offending borrow.\n\nSimilarly, in Servo's DOM there is a lot of mutation, most of which is local to a DOM type, but some of which crisscrosses the DOM and modifies various things. Using RefCell and Cell to guard all mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the places where mutation is actually happening.\n\nNote that RefCell should be avoided if a mostly simple solution is possible with & pointers.\n\nGuarantees\n\nRefCell relaxes the static restrictions preventing aliased mutation, and replaces them with dynamic ones. As such the guarantees have not changed.\n\nCost\n\nRefCell does not allocate, but it contains an additional \"borrow state\" indicator (one word in size) along with the data.\n\nAt runtime each borrow causes a modification/check of the refcount.\n\nSynchronous types\n\nMany of the types above cannot be used in a threadsafe manner. Particularly, Rc<T> and RefCell<T>, which both use non-atomic reference counts (atomic reference counts are those which can be incremented from multiple threads without causing a data race), cannot be used this way. This makes them cheaper to use, but we need thread-safe versions of these too. They exist, in the form of Arc<T> and Mutex<T>/RwLock<T>\n\nNote that the non-threadsafe types cannot be sent between threads, and this is checked at compile time.\n\nThere are many useful wrappers for concurrent programming in the sync module, but only the major ones will be covered below.\n\nArc<T>\n\nArc<T> is a version of Rc<T> that uses an atomic reference count (hence, \"Arc\"). This can be sent freely between threads.\n\nC++'s shared_ptr is similar to Arc, however in the case of C++ the inner data is always mutable. For semantics similar to that from C++, we should use Arc<Mutex<T>>, Arc<RwLock<T>>, or Arc<UnsafeCell<T>>1 (UnsafeCell<T> is a cell type that can be used to hold any data and has no runtime cost, but accessing it requires unsafe blocks). The last one should only be used if we are certain that the usage won't cause any memory unsafety. Remember that writing to a struct is not an atomic operation, and many functions like vec.push() can reallocate internally and cause unsafe behavior, so even monotonicity may not be enough to justify UnsafeCell.\n\n1\n\nArc<UnsafeCell<T>> actually won't compile since UnsafeCell<T> isn't Send or Sync, but we can wrap it in a type and implement Send/Sync for it manually to get Arc<Wrapper<T>> where Wrapper is struct Wrapper<T>(UnsafeCell<T>).\n\nGuarantees\n\nLike Rc, this provides the (thread-safe) guarantee that the destructor for the internal data will be run when the last Arc goes out of scope (barring any cycles).\n\nCost\n\nThis has the added cost of using atomics for changing the refcount (which will happen whenever it is cloned or goes out of scope). When sharing data from an Arc in a single thread, it is preferable to share & pointers whenever possible.\n\nMutex<T> and RwLock<T>\n\nMutex<T> and RwLock<T> provide mutual-exclusion via RAII guards (guards are objects which maintain some state, like a lock, until their destructor is called). For both of these, the mutex is opaque until we call lock() on it, at which point the thread will block until a lock can be acquired, and then a guard will be returned. This guard can be used to access the inner data (mutably), and the lock will be released when the guard goes out of scope.\n\n{\n    let guard = mutex.lock();\n    // `guard` dereferences mutably to the inner type.\n    *guard += 1;\n} // Lock is released when destructor runs.\n\n\nRwLock has the added benefit of being efficient for multiple reads. It is always safe to have multiple readers to shared data as long as there are no writers; and RwLock lets readers acquire a \"read lock\". Such locks can be acquired concurrently and are kept track of via a reference count. Writers must obtain a \"write lock\" which can only be obtained when all readers have gone out of scope.\n\nGuarantees\n\nBoth of these provide safe shared mutability across threads, however they are prone to deadlocks. Some level of additional protocol safety can be obtained via the type system.\n\nCosts\n\nThese use internal atomic-like types to maintain the locks, which are pretty costly (they can block all memory reads across processors till they're done). Waiting on these locks can also be slow when there's a lot of concurrent access happening.\n\nComposition\n\nA common gripe when reading Rust code is with types like Rc<RefCell<Vec<T>>> (or even more complicated compositions of such types). It's not always clear what the composition does, or why the author chose one like this (and when one should be using such a composition in one's own code)\n\nUsually, it's a case of composing together the guarantees that you need, without paying for stuff that is unnecessary.\n\nFor example, Rc<RefCell<T>> is one such composition. Rc<T> itself can't be dereferenced mutably; because Rc<T> provides sharing and shared mutability can lead to unsafe behavior, so we put RefCell<T> inside to get dynamically verified shared mutability. Now we have shared mutable data, but it's shared in a way that there can only be one mutator (and no readers) or multiple readers.\n\nNow, we can take this a step further, and have Rc<RefCell<Vec<T>>> or Rc<Vec<RefCell<T>>>. These are both shareable, mutable vectors, but they're not the same.\n\nWith the former, the RefCell<T> is wrapping the Vec<T>, so the Vec<T> in its entirety is mutable. At the same time, there can only be one mutable borrow of the whole Vec at a given time. This means that your code cannot simultaneously work on different elements of the vector from different Rc handles. However, we are able to push and pop from the Vec<T> at will. This is similar to a &mut Vec<T> with the borrow checking done at runtime.\n\nWith the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus, we can independently borrow separate elements, but we cannot push or pop from the vector. This is similar to a &mut [T]2, but, again, the borrow checking is at runtime.\n\nIn concurrent programs, we have a similar situation with Arc<Mutex<T>>, which provides shared mutability and ownership.\n\nWhen reading code that uses these, go in step by step and look at the guarantees/costs provided.\n\nWhen choosing a composed type, we must do the reverse; figure out which guarantees we want, and at which point of the composition we need them. For example, if there is a choice between Vec<RefCell<T>> and RefCell<Vec<T>>, we should figure out the trade-offs as done above and pick one.\n\n2\n\n&[T] and &mut [T] are slices; they consist of a pointer and a length and can refer to a portion of a vector or array. &mut [T] can have its elements mutated, however its length cannot be touched.\n\nForeign Function Interface\nIntroduction\n\nThis guide will use the snappy compression/decompression library as an introduction to writing bindings for foreign code. Rust is currently unable to call directly into a C++ library, but snappy includes a C interface (documented in snappy-c.h).\n\nA note about libc\n\nMany of these examples use the libc crate, which provides various type definitions for C types, among other things. If you‚Äôre trying these examples yourself, you‚Äôll need to add libc to your Cargo.toml:\n\n[dependencies]\nlibc = \"0.2.0\"\n\n\nand add extern crate libc; to your crate root.\n\nCalling foreign functions\n\nThe following is a minimal example of calling a foreign function which will compile if snappy is installed:\n\nextern crate libc;\nuse libc::size_t;\n\n#[link(name = \"snappy\")]\nextern {\n    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n}\n\nfn main() {\n    let x = unsafe { snappy_max_compressed_length(100) };\n    println!(\"max compressed length of a 100 byte buffer: {}\", x);\n}\n\n\nThe extern block is a list of function signatures in a foreign library, in this case with the platform's C ABI. The #[link(...)] attribute is used to instruct the linker to link against the snappy library so the symbols are resolved.\n\nForeign functions are assumed to be unsafe so calls to them need to be wrapped with unsafe {} as a promise to the compiler that everything contained within truly is safe. C libraries often expose interfaces that aren't thread-safe, and almost any function that takes a pointer argument isn't valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of Rust's safe memory model.\n\nWhen declaring the argument types to a foreign function, the Rust compiler cannot check if the declaration is correct, so specifying it correctly is part of keeping the binding correct at runtime.\n\nThe extern block can be extended to cover the entire snappy API:\n\nextern crate libc;\nuse libc::{c_int, size_t};\n\n#[link(name = \"snappy\")]\nextern {\n    fn snappy_compress(input: *const u8,\n                       input_length: size_t,\n                       compressed: *mut u8,\n                       compressed_length: *mut size_t) -> c_int;\n    fn snappy_uncompress(compressed: *const u8,\n                         compressed_length: size_t,\n                         uncompressed: *mut u8,\n                         uncompressed_length: *mut size_t) -> c_int;\n    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n    fn snappy_uncompressed_length(compressed: *const u8,\n                                  compressed_length: size_t,\n                                  result: *mut size_t) -> c_int;\n    fn snappy_validate_compressed_buffer(compressed: *const u8,\n                                         compressed_length: size_t) -> c_int;\n}\n\nCreating a safe interface\n\nThe raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe internal details.\n\nWrapping the functions which expect buffers involves using the slice::raw module to manipulate Rust vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The length is the number of elements currently contained, and the capacity is the total size in elements of the allocated memory. The length is less than or equal to the capacity.\n\npub fn validate_compressed_buffer(src: &[u8]) -> bool {\n    unsafe {\n        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n    }\n}\n\n\nThe validate_compressed_buffer wrapper above makes use of an unsafe block, but it makes the guarantee that calling it is safe for all inputs by leaving off unsafe from the function signature.\n\nThe snappy_compress and snappy_uncompress functions are more complex, since a buffer has to be allocated to hold the output too.\n\nThe snappy_max_compressed_length function can be used to allocate a vector with the maximum required capacity to hold the compressed output. The vector can then be passed to the snappy_compress function as an output parameter. An output parameter is also passed to retrieve the true length after compression for setting the length.\n\npub fn compress(src: &[u8]) -> Vec<u8> {\n    unsafe {\n        let srclen = src.len() as size_t;\n        let psrc = src.as_ptr();\n\n        let mut dstlen = snappy_max_compressed_length(srclen);\n        let mut dst = Vec::with_capacity(dstlen as usize);\n        let pdst = dst.as_mut_ptr();\n\n        snappy_compress(psrc, srclen, pdst, &mut dstlen);\n        dst.set_len(dstlen as usize);\n        dst\n    }\n}\n\n\nDecompression is similar, because snappy stores the uncompressed size as part of the compression format and snappy_uncompressed_length will retrieve the exact buffer size required.\n\npub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n    unsafe {\n        let srclen = src.len() as size_t;\n        let psrc = src.as_ptr();\n\n        let mut dstlen: size_t = 0;\n        snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n\n        let mut dst = Vec::with_capacity(dstlen as usize);\n        let pdst = dst.as_mut_ptr();\n\n        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n            dst.set_len(dstlen as usize);\n            Some(dst)\n        } else {\n            None // SNAPPY_INVALID_INPUT\n        }\n    }\n}\n\n\nThen, we can add some tests to show how to use them.\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid() {\n        let d = vec![0xde, 0xad, 0xd0, 0x0d];\n        let c: &[u8] = &compress(&d);\n        assert!(validate_compressed_buffer(c));\n        assert!(uncompress(c) == Some(d));\n    }\n\n    #[test]\n    fn invalid() {\n        let d = vec![0, 0, 0, 0];\n        assert!(!validate_compressed_buffer(&d));\n        assert!(uncompress(&d).is_none());\n    }\n\n    #[test]\n    fn empty() {\n        let d = vec![];\n        assert!(!validate_compressed_buffer(&d));\n        assert!(uncompress(&d).is_none());\n        let c = compress(&d);\n        assert!(validate_compressed_buffer(&c));\n        assert!(uncompress(&c) == Some(d));\n    }\n}\n\nDestructors\n\nForeign libraries often hand off ownership of resources to the calling code. When this occurs, we must use Rust's destructors to provide safety and guarantee the release of these resources (especially in the case of panic).\n\nFor more about destructors, see the Drop trait.\n\nCallbacks from C code to Rust functions\n\nSome external libraries require the usage of callbacks to report back their current state or intermediate data to the caller. It is possible to pass functions defined in Rust to an external library. The requirement for this is that the callback function is marked as extern with the correct calling convention to make it callable from C code.\n\nThe callback function can then be sent through a registration call to the C library and afterwards be invoked from there.\n\nA basic example is:\n\nRust code:\n\nextern fn callback(a: i32) {\n    println!(\"I'm called from C with value {0}\", a);\n}\n\n#[link(name = \"extlib\")]\nextern {\n   fn register_callback(cb: extern fn(i32)) -> i32;\n   fn trigger_callback();\n}\n\nfn main() {\n    unsafe {\n        register_callback(callback);\n        trigger_callback(); // Triggers the callback.\n    }\n}\n\n\nC code:\n\ntypedef void (*rust_callback)(int32_t);\nrust_callback cb;\n\nint32_t register_callback(rust_callback callback) {\n    cb = callback;\n    return 1;\n}\n\nvoid trigger_callback() {\n  cb(7); // Will call callback(7) in Rust.\n}\n\n\nIn this example Rust's main() will call trigger_callback() in C, which would, in turn, call back to callback() in Rust.\n\nTargeting callbacks to Rust objects\n\nThe former example showed how a global function can be called from C code. However it is often desired that the callback is targeted to a special Rust object. This could be the object that represents the wrapper for the respective C object.\n\nThis can be achieved by passing a raw pointer to the object down to the C library. The C library can then include the pointer to the Rust object in the notification. This will allow the callback to unsafely access the referenced Rust object.\n\nRust code:\n\n#[repr(C)]\nstruct RustObject {\n    a: i32,\n    // Other members...\n}\n\nextern \"C\" fn callback(target: *mut RustObject, a: i32) {\n    println!(\"I'm called from C with value {0}\", a);\n    unsafe {\n        // Update the value in RustObject with the value received from the callback:\n        (*target).a = a;\n    }\n}\n\n#[link(name = \"extlib\")]\nextern {\n   fn register_callback(target: *mut RustObject,\n                        cb: extern fn(*mut RustObject, i32)) -> i32;\n   fn trigger_callback();\n}\n\nfn main() {\n    // Create the object that will be referenced in the callback:\n    let mut rust_object = Box::new(RustObject { a: 5 });\n\n    unsafe {\n        register_callback(&mut *rust_object, callback);\n        trigger_callback();\n    }\n}\n\n\nC code:\n\ntypedef void (*rust_callback)(void*, int32_t);\nvoid* cb_target;\nrust_callback cb;\n\nint32_t register_callback(void* callback_target, rust_callback callback) {\n    cb_target = callback_target;\n    cb = callback;\n    return 1;\n}\n\nvoid trigger_callback() {\n  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust.\n}\n\nAsynchronous callbacks\n\nIn the previously given examples the callbacks are invoked as a direct reaction to a function call to the external C library. The control over the current thread is switched from Rust to C to Rust for the execution of the callback, but in the end the callback is executed on the same thread that called the function which triggered the callback.\n\nThings get more complicated when the external library spawns its own threads and invokes callbacks from there. In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to use channels (in std::sync::mpsc) to forward data from the C thread that invoked the callback into a Rust thread.\n\nIf an asynchronous callback targets a special object in the Rust address space it is also absolutely necessary that no more callbacks are performed by the C library after the respective Rust object gets destroyed. This can be achieved by unregistering the callback in the object's destructor and designing the library in a way that guarantees that no callback will be performed after deregistration.\n\nLinking\n\nThe link attribute on extern blocks provides the basic building block for instructing rustc how it will link to native libraries. There are two accepted forms of the link attribute today:\n\n#[link(name = \"foo\")]\n#[link(name = \"foo\", kind = \"bar\")]\n\nIn both of these cases, foo is the name of the native library that we're linking to, and in the second case bar is the type of native library that the compiler is linking to. There are currently three known types of native libraries:\n\nDynamic - #[link(name = \"readline\")]\nStatic - #[link(name = \"my_build_dependency\", kind = \"static\")]\nFrameworks - #[link(name = \"CoreFoundation\", kind = \"framework\")]\n\nNote that frameworks are only available on macOS targets.\n\nThe different kind values are meant to differentiate how the native library participates in linkage. From a linkage perspective, the Rust compiler creates two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary). Native dynamic library and framework dependencies are propagated to the final artifact boundary, while static library dependencies are not propagated at all, because the static libraries are integrated directly into the subsequent artifact.\n\nA few examples of how this model can be used are:\n\nA native build dependency. Sometimes some C/C++ glue is needed when writing some Rust code, but distribution of the C/C++ code in a library format is a burden. In this case, the code will be archived into libfoo.a and then the Rust crate would declare a dependency via #[link(name = \"foo\", kind = \"static\")].\n\nRegardless of the flavor of output for the crate, the native static library will be included in the output, meaning that distribution of the native static library is not necessary.\n\nA normal dynamic dependency. Common system libraries (like readline) are available on a large number of systems, and often a static copy of these libraries cannot be found. When this dependency is included in a Rust crate, partial targets (like rlibs) will not link to the library, but when the rlib is included in a final target (like a binary), the native library will be linked in.\n\nOn macOS, frameworks behave with the same semantics as a dynamic library.\n\nUnsafe blocks\n\nSome operations, like dereferencing raw pointers or calling functions that have been marked unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to the compiler that the unsafety does not leak out of the block.\n\nUnsafe functions, on the other hand, advertise it to the world. An unsafe function is written like this:\n\n\nunsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n\nThis function can only be called from an unsafe block or another unsafe function.\n\nAccessing foreign globals\n\nForeign APIs often export a global variable which could do something like track global state. In order to access these variables, you declare them in extern blocks with the static keyword:\n\nextern crate libc;\n\n#[link(name = \"readline\")]\nextern {\n    static rl_readline_version: libc::c_int;\n}\n\nfn main() {\n    println!(\"You have readline version {} installed.\",\n             unsafe { rl_readline_version as i32 });\n}\n\n\nAlternatively, you may need to alter global state provided by a foreign interface. To do this, statics can be declared with mut so we can mutate them.\n\nextern crate libc;\n\nuse std::ffi::CString;\nuse std::ptr;\n\n#[link(name = \"readline\")]\nextern {\n    static mut rl_prompt: *const libc::c_char;\n}\n\nfn main() {\n    let prompt = CString::new(\"[my-awesome-shell] $\").unwrap();\n    unsafe {\n        rl_prompt = prompt.as_ptr();\n\n        println!(\"{:?}\", rl_prompt);\n\n        rl_prompt = ptr::null();\n    }\n}\n\n\nNote that all interaction with a static mut is unsafe, both reading and writing. Dealing with global mutable state requires a great deal of care.\n\nForeign calling conventions\n\nMost foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when calling foreign functions. Some foreign functions, most notably the Windows API, use other calling conventions. Rust provides a way to tell the compiler which convention to use:\n\nextern crate libc;\n\n#[cfg(all(target_os = \"win32\", target_arch = \"x86\"))]\n#[link(name = \"kernel32\")]\n#[allow(non_snake_case)]\nextern \"stdcall\" {\n    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n}\n\n\nThis applies to the entire extern block. The list of supported ABI constraints are:\n\nstdcall\naapcs\ncdecl\nfastcall\nvectorcall This is currently hidden behind the abi_vectorcall gate and is subject to change.\nRust\nrust-intrinsic\nsystem\nC\nwin64\nsysv64\n\nMost of the ABIs in this list are self-explanatory, but the system ABI may seem a little odd. This constraint selects whatever the appropriate ABI is for interoperating with the target's libraries. For example, on win32 with a x86 architecture, this means that the ABI used would be stdcall. On x86_64, however, windows uses the C calling convention, so C would be used. This means that in our previous example, we could have used extern \"system\" { ... } to define a block for all windows systems, not only x86 ones.\n\nInteroperability with foreign code\n\nRust guarantees that the layout of a struct is compatible with the platform's representation in C only if the #[repr(C)] attribute is applied to it. #[repr(C, packed)] can be used to lay out struct members without padding. #[repr(C)] can also be applied to an enum.\n\nRust's owned boxes (Box<T>) use non-nullable pointers as handles which point to the contained object. However, they should not be manually created because they are managed by internal allocators. References can safely be assumed to be non-nullable pointers directly to the type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw pointers (*) if that's needed because the compiler can't make as many assumptions about them.\n\nVectors and strings share the same basic memory layout, and utilities are available in the vec and str modules for working with C APIs. However, strings are not terminated with \\0. If you need a NUL-terminated string for interoperability with C, you should use the CString type in the std::ffi module.\n\nThe libc crate on crates.io includes type aliases and function definitions for the C standard library in the libc module, and Rust links against libc and libm by default.\n\nVariadic functions\n\nIn C, functions can be 'variadic', meaning they accept a variable number of arguments. This can be achieved in Rust by specifying ... within the argument list of a foreign function declaration:\n\nextern {\n    fn foo(x: i32, ...);\n}\n\nfn main() {\n    unsafe {\n        foo(10, 20, 30, 40, 50);\n    }\n}\n\n\nNormal Rust functions can not be variadic:\n\n// This will not compile\n\nfn foo(x: i32, ...) { }\n\nThe \"nullable pointer optimization\"\n\nCertain Rust types are defined to never be null. This includes references (&T, &mut T), boxes (Box<T>), and function pointers (extern \"abi\" fn()). When interfacing with C, pointers that might be null are often used, which would seem to require some messy transmutes and/or unsafe code to handle conversions to/from Rust types. However, the language provides a workaround.\n\nAs a special case, an enum is eligible for the \"nullable pointer optimization\" if it contains exactly two variants, one of which contains no data and the other contains a field of one of the non-nullable types listed above. This means no extra space is required for a discriminant; rather, the empty variant is represented by putting a null value into the non-nullable field. This is called an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible types.\n\nThe most common type that takes advantage of the nullable pointer optimization is Option<T>, where None corresponds to null. So Option<extern \"C\" fn(c_int) -> c_int> is a correct way to represent a nullable function pointer using the C ABI (corresponding to the C type int (*)(int)).\n\nHere is a contrived example. Let's say some C library has a facility for registering a callback, which gets called in certain situations. The callback is passed a function pointer and an integer and it is supposed to run the function with the integer as a parameter. So we have function pointers flying across the FFI boundary in both directions.\n\nextern crate libc;\nuse libc::c_int;\n\nextern \"C\" {\n    /// Registers the callback.\n    fn register(cb: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>, c_int) -> c_int>);\n}\n\n/// This fairly useless function receives a function pointer and an integer\n/// from C, and returns the result of calling the function with the integer.\n/// In case no function is provided, it squares the integer by default.\nextern \"C\" fn apply(process: Option<extern \"C\" fn(c_int) -> c_int>, int: c_int) -> c_int {\n    match process {\n        Some(f) => f(int),\n        None    => int * int\n    }\n}\n\nfn main() {\n    unsafe {\n        register(Some(apply));\n    }\n}\n\n\nAnd the code on the C side looks like this:\n\nvoid register(void (*f)(void (*)(int), int)) {\n    ...\n}\n\n\nNo transmute required!\n\nCalling Rust code from C\n\nYou may wish to compile Rust code in a way so that it can be called from C. This is fairly easy, but requires a few things:\n\n#[no_mangle]\npub extern fn hello_rust() -> *const u8 {\n    \"Hello, world!\\0\".as_ptr()\n}\n\n\nThe extern makes this function adhere to the C calling convention, as discussed above in \"Foreign Calling Conventions\". The no_mangle attribute turns off Rust's name mangling, so that it is easier to link to.\n\nFFI and panics\n\nIt‚Äôs important to be mindful of panic!s when working with FFI. A panic! across an FFI boundary is undefined behavior. If you‚Äôre writing code that may panic, you should run it in a closure with catch_unwind:\n\nuse std::panic::catch_unwind;\n\n#[no_mangle]\npub extern fn oh_no() -> i32 {\n    let result = catch_unwind(|| {\n        panic!(\"Oops!\");\n    });\n    match result {\n        Ok(_) => 0,\n        Err(_) => 1,\n    }\n}\n\nfn main() {}\n\n\nPlease note that catch_unwind will only catch unwinding panics, not those who abort the process. See the documentation of catch_unwind for more information.\n\nRepresenting opaque structs\n\nSometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants. The simplest way is to use a void * argument:\n\nvoid foo(void *arg);\nvoid bar(void *arg);\n\n\nWe can represent this in Rust with the c_void type:\n\nextern crate libc;\n\nextern \"C\" {\n    pub fn foo(arg: *mut libc::c_void);\n    pub fn bar(arg: *mut libc::c_void);\n}\n\n\nThis is a perfectly valid way of handling the situation. However, we can do a bit better. To solve this, some C libraries will instead create a struct, where the details and memory layout of the struct are private. This gives some amount of type safety. These structures are called ‚Äòopaque‚Äô. Here‚Äôs an example, in C:\n\nstruct Foo; /* Foo is a structure, but its contents are not part of the public interface */\nstruct Bar;\nvoid foo(struct Foo *arg);\nvoid bar(struct Bar *arg);\n\n\nTo do this in Rust, let‚Äôs create our own opaque types:\n\n#[repr(C)] pub struct Foo { private: [u8; 0] }\n#[repr(C)] pub struct Bar { private: [u8; 0] }\n\nextern \"C\" {\n    pub fn foo(arg: *mut Foo);\n    pub fn bar(arg: *mut Bar);\n}\n\n\nBy including a private field and no constructor, we create an opaque type that we can‚Äôt instantiate outside of this module. An empty array is both zero-size and compatible with #[repr(C)]. But because our Foo and Bar types are different, we‚Äôll get type safety between the two of them, so we cannot accidentally pass a pointer to Foo to bar().\n\nBorrow and AsRef\n\nThe Borrow and AsRef traits are very similar, but different. Here‚Äôs a quick refresher on what these two traits mean.\n\nBorrow\n\nThe Borrow trait is used when you‚Äôre writing a data structure, and you want to use either an owned or borrowed type as synonymous for some purpose.\n\nFor example, HashMap has a get method which uses Borrow:\n\nfn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n    where K: Borrow<Q>,\n          Q: Hash + Eq\n\n\nThis signature is pretty complicated. The K parameter is what we‚Äôre interested in here. It refers to a parameter of the HashMap itself:\n\nstruct HashMap<K, V, S = RandomState> {\n\n\nThe K parameter is the type of key the HashMap uses. So, looking at the signature of get() again, we can use get() when the key implements Borrow<Q>. That way, we can make a HashMap which uses String keys, but use &strs when we‚Äôre searching:\n\n\nuse std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(\"Foo\".to_string(), 42);\n\nassert_eq!(map.get(\"Foo\"), Some(&42));\n\nThis is because the standard library has impl Borrow<str> for String.\n\nFor most types, when you want to take an owned or borrowed type, a &T is enough. But one area where Borrow is effective is when there‚Äôs more than one kind of borrowed value. This is especially true of references and slices: you can have both an &T or a &mut T. If we wanted to accept both of these types, Borrow is up for it:\n\n\nuse std::borrow::Borrow;\nuse std::fmt::Display;\n\nfn foo<T: Borrow<i32> + Display>(a: T) {\n    println!(\"a is borrowed: {}\", a);\n}\n\nlet mut i = 5;\n\nfoo(&i);\nfoo(&mut i);\n\nThis will print out a is borrowed: 5 twice.\n\nAsRef\n\nThe AsRef trait is a conversion trait. It‚Äôs used for converting some value to a reference in generic code. Like this:\n\n\nlet s = \"Hello\".to_string();\n\nfn foo<T: AsRef<str>>(s: T) {\n    let slice = s.as_ref();\n}\nWhich should I use?\n\nWe can see how they‚Äôre kind of the same: they both deal with owned and borrowed versions of some type. However, they‚Äôre a bit different.\n\nChoose Borrow when you want to abstract over different kinds of borrowing, or when you‚Äôre building a data structure that treats owned and borrowed values in equivalent ways, such as hashing and comparison.\n\nChoose AsRef when you want to convert something to a reference directly, and you‚Äôre writing generic code.\n\nRelease Channels\n\nThe Rust project uses a concept called ‚Äòrelease channels‚Äô to manage releases. It‚Äôs important to understand this process to choose which version of Rust your project should use.\n\nOverview\n\nThere are three channels for Rust releases:\n\nNightly\nBeta\nStable\n\nNew nightly releases are created once a day. Every six weeks, the latest nightly release is promoted to ‚ÄòBeta‚Äô. At that point, it will only receive patches to fix serious errors. Six weeks later, the beta is promoted to ‚ÄòStable‚Äô, and becomes the next release of 1.x.\n\nThis process happens in parallel. So every six weeks, on the same day, nightly goes to beta, beta goes to stable. When 1.x is released, at the same time, 1.(x + 1)-beta is released, and the nightly becomes the first version of 1.(x + 2)-nightly.\n\nChoosing a version\n\nGenerally speaking, unless you have a specific reason, you should be using the stable release channel. These releases are intended for a general audience.\n\nHowever, depending on your interest in Rust, you may choose to use nightly instead. The basic trade-off is this: in the nightly channel, you can use unstable, new Rust features. However, unstable features are subject to change, and so any new nightly release may break your code. If you use the stable release, you cannot use experimental features, but the next release of Rust will not cause significant issues through breaking changes.\n\nHelping the ecosystem through CI\n\nWhat about beta? We encourage all Rust users who use the stable release channel to also test against the beta channel in their continuous integration systems. This will help alert the team in case there‚Äôs an accidental regression.\n\nAdditionally, testing against nightly can catch regressions even sooner, and so if you don‚Äôt mind a third build, we‚Äôd appreciate testing against all channels.\n\nAs an example, many Rust programmers use Travis to test their crates, which is free for open source projects. Travis supports Rust directly, and you can use a .travis.yml file like this to test on all channels:\n\nlanguage: rust\nrust:\n  - nightly\n  - beta\n  - stable\n\nmatrix:\n  allow_failures:\n    - rust: nightly\n\n\nWith this configuration, Travis will test all three channels, but if something breaks on nightly, it won‚Äôt fail your build. A similar configuration is recommended for any CI system, check the documentation of the one you‚Äôre using for more details.\n\nUsing Rust Without the Standard Library\n\nRust‚Äôs standard library provides a lot of useful functionality, but assumes support for various features of its host system: threads, networking, heap allocation, and others. There are systems that do not have these features, however, and Rust can work with those too! To do so, we tell Rust that we don‚Äôt want to use the standard library via an attribute: #![no_std].\n\nNote: This feature is technically stable, but there are some caveats. For one, you can build a #![no_std] library on stable, but not a binary. For details on binaries without the standard library, see the nightly chapter on 'lang items'\n\nTo use #![no_std], add it to your crate root:\n\n#![no_std]\n\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\n\nMuch of the functionality that‚Äôs exposed in the standard library is also available via the core crate. When we‚Äôre using the standard library, Rust automatically brings std into scope, allowing you to use its features without an explicit import. By the same token, when using #![no_std], Rust will bring core into scope for you, as well as its prelude. This means that a lot of code will Just Work:\n\n#![no_std]\n\nfn may_fail(failure: bool) -> Result<(), &'static str> {\n    if failure {\n        Err(\"this didn‚Äôt work!\")\n    } else {\n        Ok(())\n    }\n}\n\nProcedural Macros (and custom Derive)\n\nAs you've seen throughout the rest of the book, Rust provides a mechanism called \"derive\" that lets you implement traits easily. For example,\n\n\n#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nis a lot simpler than\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nuse std::fmt;\n\nimpl fmt::Debug for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Point {{ x: {}, y: {} }}\", self.x, self.y)\n    }\n}\n\nRust includes several traits that you can derive, but it also lets you define your own. We can accomplish this task through a feature of Rust called \"procedural macros.\" Eventually, procedural macros will allow for all sorts of advanced metaprogramming in Rust, but today, they're only for custom derive.\n\nLet's build a very simple trait, and derive it with custom derive.\n\nHello World\n\nSo the first thing we need to do is start a new crate for our project.\n\n$ cargo new --bin hello-world\n\n\nAll we want is to be able to call hello_world() on a derived type. Something like this:\n\n#[derive(HelloWorld)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_world();\n}\n\n\nWith some kind of nice output, like Hello, World! My name is Pancakes..\n\nLet's go ahead and write up what we think our macro will look like from a user perspective. In src/main.rs we write:\n\n#[macro_use]\nextern crate hello_world_derive;\n\ntrait HelloWorld {\n    fn hello_world();\n}\n\n#[derive(HelloWorld)]\nstruct FrenchToast;\n\n#[derive(HelloWorld)]\nstruct Waffles;\n\nfn main() {\n    FrenchToast::hello_world();\n    Waffles::hello_world();\n}\n\n\nGreat. So now we just need to actually write the procedural macro. At the moment, procedural macros need to be in their own crate. Eventually, this restriction may be lifted, but for now, it's required. As such, there's a convention; for a crate named foo, a custom derive procedural macro is called foo-derive. Let's start a new crate called hello-world-derive inside our hello-world project.\n\n$ cargo new hello-world-derive\n\n\nTo make sure that our hello-world crate is able to find this new crate we've created, we'll add it to our toml:\n\n[dependencies]\nhello-world-derive = { path = \"hello-world-derive\" }\n\n\nAs for the source of our hello-world-derive crate, here's an example:\n\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(HelloWorld)]\npub fn hello_world(input: TokenStream) -> TokenStream {\n    // Construct a string representation of the type definition\n    let s = input.to_string();\n    \n    // Parse the string representation\n    let ast = syn::parse_derive_input(&s).unwrap();\n\n    // Build the impl\n    let gen = impl_hello_world(&ast);\n    \n    // Return the generated impl\n    gen.parse().unwrap()\n}\n\n\nSo there is a lot going on here. We have introduced two new crates: syn and quote. As you may have noticed, input: TokenSteam is immediately converted to a String. This String is a string representation of the Rust code for which we are deriving HelloWorld. At the moment, the only thing you can do with a TokenStream is convert it to a string. A richer API will exist in the future.\n\nSo what we really need is to be able to parse Rust code into something usable. This is where syn comes to play. syn is a crate for parsing Rust code. The other crate we've introduced is quote. It's essentially the dual of syn as it will make generating Rust code really easy. We could write this stuff on our own, but it's much simpler to use these libraries. Writing a full parser for Rust code is no simple task.\n\nThe comments seem to give us a pretty good idea of our overall strategy. We are going to take a String of the Rust code for the type we are deriving, parse it using syn, construct the implementation of hello_world (using quote), then pass it back to Rust compiler.\n\nOne last note: you'll see some unwrap()s there. If you want to provide an error for a procedural macro, then you should panic! with the error message. In this case, we're keeping it as simple as possible.\n\nGreat, so let's write impl_hello_world(&ast).\n\nfn impl_hello_world(ast: &syn::DeriveInput) -> quote::Tokens {\n    let name = &ast.ident;\n    quote! {\n        impl HelloWorld for #name {\n            fn hello_world() {\n                println!(\"Hello, World! My name is {}\", stringify!(#name));\n            }\n        }\n    }\n}\n\n\nSo this is where quotes comes in. The ast argument is a struct that gives us a representation of our type (which can be either a struct or an enum). Check out the docs, there is some useful information there. We are able to get the name of the type using ast.ident. The quote! macro lets us write up the Rust code that we wish to return and convert it into Tokens. quote! lets us use some really cool templating mechanics; we simply write #name and quote! will replace it with the variable named name. You can even do some repetition similar to regular macros work. You should check out the docs for a good introduction.\n\nSo I think that's it. Oh, well, we do need to add dependencies for syn and quote in the Cargo.toml for hello-world-derive.\n\n[dependencies]\nsyn = \"0.11.11\"\nquote = \"0.3.15\"\n\n\nThat should be it. Let's try to compile hello-world.\n\nerror: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type\n --> hello-world-derive/src/lib.rs:8:3\n  |\n8 | #[proc_macro_derive(HelloWorld)]\n  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nOh, so it appears that we need to declare that our hello-world-derive crate is a proc-macro crate type. How do we do this? Like this:\n\n[lib]\nproc-macro = true\n\n\nOk so now, let's compile hello-world. Executing cargo run now yields:\n\nHello, World! My name is FrenchToast\nHello, World! My name is Waffles\n\n\nWe've done it!\n\nCustom Attributes\n\nIn some cases it might make sense to allow users some kind of configuration. For example, the user might want to overwrite the name that is printed in the hello_world() method.\n\nThis can be achieved with custom attributes:\n\n#[derive(HelloWorld)]\n#[HelloWorldName = \"the best Pancakes\"]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_world();\n}\n\n\nIf we try to compile this though, the compiler will respond with an error:\n\nerror: The attribute `HelloWorldName` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n\n\nThe compiler needs to know that we're handling this attribute and to not respond with an error. This is done in the hello-world-derive crate by adding attributes to the proc_macro_derive attribute:\n\n#[proc_macro_derive(HelloWorld, attributes(HelloWorldName))]\npub fn hello_world(input: TokenStream) -> TokenStream \n\n\nMultiple attributes can be specified that way.\n\nRaising Errors\n\nLet's assume that we do not want to accept enums as input to our custom derive method.\n\nThis condition can be easily checked with the help of syn. But how do we tell the user, that we do not accept enums? The idiomatic way to report errors in procedural macros is to panic:\n\nfn impl_hello_world(ast: &syn::DeriveInput) -> quote::Tokens {\n    let name = &ast.ident;\n    // Check if derive(HelloWorld) was specified for a struct\n    if let syn::Body::Struct(_) = ast.body {\n        // Yes, this is a struct\n        quote! {\n            impl HelloWorld for #name {\n                fn hello_world() {\n                    println!(\"Hello, World! My name is {}\", stringify!(#name));\n                }\n            }\n        }\n    } else {\n        //Nope. This is an Enum. We cannot handle these!\n       panic!(\"#[derive(HelloWorld)] is only defined for structs, not for enums!\");\n    }\n}\n\n\nIf a user now tries to derive HelloWorld from an enum they will be greeted with following, hopefully helpful, error:\n\nerror: custom derive attribute panicked\n  --> src/main.rs\n   |\n   | #[derive(HelloWorld)]\n   |          ^^^^^^^^^^\n   |\n   = help: message: #[derive(HelloWorld)] is only defined for structs, not for enums!\n\nGlossary\n\nNot every Rustacean has a background in systems programming, nor in computer science, so we've added explanations of terms that might be unfamiliar.\n\nAbstract Syntax Tree\n\nWhen a compiler is compiling your program, it does a number of different things. One of the things that it does is turn the text of your program into an ‚Äòabstract syntax tree‚Äô, or ‚ÄòAST‚Äô. This tree is a representation of the structure of your program. For example, 2 + 3 can be turned into a tree:\n\n  +\n / \\\n2   3\n\n\nAnd 2 + (3 * 4) would look like this:\n\n  +\n / \\\n2   *\n   / \\\n  3   4\n\nArity\n\nArity refers to the number of arguments a function or operation takes.\n\n\nlet x = (2, 3);\nlet y = (4, 6);\nlet z = (8, 2, 6);\n\nIn the example above x and y have arity 2. z has arity 3.\n\nBounds\n\nBounds are constraints on a type or trait. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.\n\nCombinators\n\nCombinators are higher-order functions that apply only functions and earlier defined combinators to provide a result from its arguments. They can be used to manage control flow in a modular fashion.\n\nDST (Dynamically Sized Type)\n\nA type without a statically known size or alignment. (more info)\n\nExpression\n\nIn computer programming, an expression is a combination of values, constants, variables, operators and functions that evaluate to a single value. For example, 2 + (3 * 4) is an expression that returns the value 14. It is worth noting that expressions can have side-effects. For example, a function included in an expression might perform actions other than simply returning a value.\n\nExpression-Oriented Language\n\nIn early programming languages, expressions and statements were two separate syntactic categories: expressions had a value and statements did things. However, later languages blurred this distinction, allowing expressions to do things and statements to have a value. In an expression-oriented language, (nearly) every statement is an expression and therefore returns a value. Consequently, these expression statements can themselves form part of larger expressions.\n\nStatement\n\nIn computer programming, a statement is the smallest standalone element of a programming language that commands a computer to perform an action.\n\nSyntax Index\nKeywords\nas: primitive casting, or disambiguating the specific trait containing an item. See Casting Between Types (as), Universal Function Call Syntax (Angle-bracket Form), Associated Types.\nbreak: break out of loop. See Loops (Ending Iteration Early).\nconst: constant items and constant raw pointers. See const and static, Raw Pointers.\ncontinue: continue to next loop iteration. See Loops (Ending Iteration Early).\ncrate: external crate linkage. See Crates and Modules (Importing External Crates).\nelse: fallback for if and if let constructs. See if, if let.\nenum: defining enumeration. See Enums.\nextern: external crate, function, and variable linkage. See Crates and Modules (Importing External Crates), Foreign Function Interface.\nfalse: boolean false literal. See Primitive Types (Booleans).\nfn: function definition and function pointer types. See Functions.\nfor: iterator loop, part of trait impl syntax, and higher-ranked lifetime syntax. See Loops (for), Method Syntax.\nif: conditional branching. See if, if let.\nimpl: inherent and trait implementation blocks. See Method Syntax.\nin: part of for loop syntax. See Loops (for).\nlet: variable binding. See Variable Bindings.\nloop: unconditional, infinite loop. See Loops (loop).\nmatch: pattern matching. See Match.\nmod: module declaration. See Crates and Modules (Defining Modules).\nmove: part of closure syntax. See Closures (move closures).\nmut: denotes mutability in pointer types and pattern bindings. See Mutability.\npub: denotes public visibility in struct fields, impl blocks, and modules. See Crates and Modules (Exporting a Public Interface).\nref: by-reference binding. See Patterns (ref and ref mut).\nreturn: return from function. See Functions (Early Returns).\nSelf: implementor type alias. See Traits.\nself: method subject. See Method Syntax (Method Calls).\nstatic: global variable. See const and static (static).\nstruct: structure definition. See Structs.\ntrait: trait definition. See Traits.\ntrue: boolean true literal. See Primitive Types (Booleans).\ntype: type alias, and associated type definition. See type Aliases, Associated Types.\nunsafe: denotes unsafe code, functions, traits, and implementations. See Unsafe.\nuse: import symbols into scope. See Crates and Modules (Importing Modules with use).\nwhere: type constraint clauses. See Traits (where clause).\nwhile: conditional loop. See Loops (while).\nOperators and Symbols\n! (ident!(‚Ä¶), ident!{‚Ä¶}, ident![‚Ä¶]): denotes macro expansion. See Macros.\n! (!expr): bitwise or logical complement. Overloadable (Not).\n!= (var != expr): nonequality comparison. Overloadable (PartialEq).\n% (expr % expr): arithmetic remainder. Overloadable (Rem).\n%= (var %= expr): arithmetic remainder & assignment. Overloadable (RemAssign).\n& (expr & expr): bitwise and. Overloadable (BitAnd).\n& (&expr, &mut expr): borrow. See References and Borrowing.\n& (&type, &mut type, &'a type, &'a mut type): borrowed pointer type. See References and Borrowing.\n&= (var &= expr): bitwise and & assignment. Overloadable (BitAndAssign).\n&& (expr && expr): logical and.\n* (expr * expr): arithmetic multiplication. Overloadable (Mul).\n* (*expr): dereference.\n* (*const type, *mut type): raw pointer. See Raw Pointers.\n*= (var *= expr): arithmetic multiplication & assignment. Overloadable (MulAssign).\n+ (expr + expr): arithmetic addition. Overloadable (Add).\n+ (trait + trait, 'a + trait): compound type constraint. See Traits (Multiple Trait Bounds).\n+= (var += expr): arithmetic addition & assignment. Overloadable (AddAssign).\n,: argument and element separator. See Attributes, Functions, Structs, Generics, Match, Closures, Crates and Modules (Importing Modules with use).\n- (expr - expr): arithmetic subtraction. Overloadable (Sub).\n- (- expr): arithmetic negation. Overloadable (Neg).\n-= (var -= expr): arithmetic subtraction & assignment. Overloadable (SubAssign).\n-> (fn(‚Ä¶) -> type, |‚Ä¶| -> type): function and closure return type. See Functions, Closures.\n. (expr.ident): member access. See Structs, Method Syntax.\n.. (.., expr.., ..expr, expr..expr): right-exclusive range literal.\n.. (..expr): struct literal update syntax. See Structs (Update syntax).\n.. (variant(x, ..), struct_type { x, .. }): \"and the rest\" pattern binding. See Patterns (Ignoring bindings).\n... (...expr, expr...expr) in an expression: inclusive range expression. See Iterators.\n... (expr...expr) in a pattern: inclusive range pattern. See Patterns (Ranges).\n/ (expr / expr): arithmetic division. Overloadable (Div).\n/= (var /= expr): arithmetic division & assignment. Overloadable (DivAssign).\n: (pat: type, ident: type): constraints. See Variable Bindings, Functions, Structs, Traits.\n: (ident: expr): struct field initializer. See Structs.\n: ('a: loop {‚Ä¶}): loop label. See Loops (Loops Labels).\n;: statement and item terminator.\n; ([‚Ä¶; len]): part of fixed-size array syntax. See Primitive Types (Arrays).\n<< (expr << expr): left-shift. Overloadable (Shl).\n<<= (var <<= expr): left-shift & assignment. Overloadable (ShlAssign).\n< (expr < expr): less-than comparison. Overloadable (PartialOrd).\n<= (var <= expr): less-than or equal-to comparison. Overloadable (PartialOrd).\n= (var = expr, ident = type): assignment/equivalence. See Variable Bindings, type Aliases, generic parameter defaults.\n== (var == expr): equality comparison. Overloadable (PartialEq).\n=> (pat => expr): part of match arm syntax. See Match.\n> (expr > expr): greater-than comparison. Overloadable (PartialOrd).\n>= (var >= expr): greater-than or equal-to comparison. Overloadable (PartialOrd).\n>> (expr >> expr): right-shift. Overloadable (Shr).\n>>= (var >>= expr): right-shift & assignment. Overloadable (ShrAssign).\n@ (ident @ pat): pattern binding. See Patterns (Bindings).\n^ (expr ^ expr): bitwise exclusive or. Overloadable (BitXor).\n^= (var ^= expr): bitwise exclusive or & assignment. Overloadable (BitXorAssign).\n| (expr | expr): bitwise or. Overloadable (BitOr).\n| (pat | pat): pattern alternatives. See Patterns (Multiple patterns).\n| (|‚Ä¶| expr): closures. See Closures.\n|= (var |= expr): bitwise or & assignment. Overloadable (BitOrAssign).\n|| (expr || expr): logical or.\n_: \"ignored\" pattern binding (see Patterns (Ignoring bindings)). Also used to make integer-literals readable (see Reference (Integer literals)).\n? (expr?): Error propagation. Returns early when Err(_) is encountered, unwraps otherwise. Similar to the try! macro.\nOther Syntax\n'ident: named lifetime or loop label. See Lifetimes, Loops (Loops Labels).\n‚Ä¶u8, ‚Ä¶i32, ‚Ä¶f64, ‚Ä¶usize, ‚Ä¶: numeric literal of specific type.\n\"‚Ä¶\": string literal. See Strings.\nr\"‚Ä¶\", r#\"‚Ä¶\"#, r##\"‚Ä¶\"##, ‚Ä¶: raw string literal, escape characters are not processed. See Reference (Raw String Literals).\nb\"‚Ä¶\": byte string literal, constructs a [u8] instead of a string. See Reference (Byte String Literals).\nbr\"‚Ä¶\", br#\"‚Ä¶\"#, br##\"‚Ä¶\"##, ‚Ä¶: raw byte string literal, combination of raw and byte string literal. See Reference (Raw Byte String Literals).\n'‚Ä¶': character literal. See Primitive Types (char).\nb'‚Ä¶': ASCII byte literal.\n|‚Ä¶| expr: closure. See Closures.\nident::ident: path. See Crates and Modules (Defining Modules).\n::path: path relative to the crate root (i.e. an explicitly absolute path). See Crates and Modules (Re-exporting with pub use).\nself::path: path relative to the current module (i.e. an explicitly relative path). See Crates and Modules (Re-exporting with pub use).\nsuper::path: path relative to the parent of the current module. See Crates and Modules (Re-exporting with pub use).\ntype::ident, <type as trait>::ident: associated constants, functions, and types. See Associated Types.\n<type>::‚Ä¶: associated item for a type which cannot be directly named (e.g. <&T>::‚Ä¶, <[T]>::‚Ä¶, etc.). See Associated Types.\ntrait::method(‚Ä¶): disambiguating a method call by naming the trait which defines it. See Universal Function Call Syntax.\ntype::method(‚Ä¶): disambiguating a method call by naming the type for which it's defined. See Universal Function Call Syntax.\n<type as trait>::method(‚Ä¶): disambiguating a method call by naming the trait and type. See Universal Function Call Syntax (Angle-bracket Form).\npath<‚Ä¶> (e.g. Vec<u8>): specifies parameters to generic type in a type. See Generics.\npath::<‚Ä¶>, method::<‚Ä¶> (e.g. \"42\".parse::<i32>()): specifies parameters to generic type, function, or method in an expression. See Generics ¬ß Resolving ambiguities.\nfn ident<‚Ä¶> ‚Ä¶: define generic function. See Generics.\nstruct ident<‚Ä¶> ‚Ä¶: define generic structure. See Generics.\nenum ident<‚Ä¶> ‚Ä¶: define generic enumeration. See Generics.\nimpl<‚Ä¶> ‚Ä¶: define generic implementation.\nfor<‚Ä¶> type: higher-ranked lifetime bounds.\ntype<ident=type> (e.g. Iterator<Item=T>): a generic type where one or more associated types have specific assignments. See Associated Types.\nT: U: generic parameter T constrained to types that implement U. See Traits.\nT: 'a: generic type T must outlive lifetime 'a. When we say that a type 'outlives' the lifetime, we mean that it cannot transitively contain any references with lifetimes shorter than 'a.\nT : 'static: The generic type T contains no borrowed references other than 'static ones.\n'b: 'a: generic lifetime 'b must outlive lifetime 'a.\nT: ?Sized: allow generic type parameter to be a dynamically-sized type. See Unsized Types (?Sized).\n'a + trait, trait + trait: compound type constraint. See Traits (Multiple Trait Bounds).\n#[meta]: outer attribute. See Attributes.\n#![meta]: inner attribute. See Attributes.\n$ident: macro substitution. See Macros.\n$ident:kind: macro capture. See Macros.\n$(‚Ä¶)‚Ä¶: macro repetition. See Macros.\n//: line comment. See Comments.\n//!: inner line doc comment. See Comments.\n///: outer line doc comment. See Comments.\n/*‚Ä¶*/: block comment. See Comments.\n/*!‚Ä¶*/: inner block doc comment. See Comments.\n/**‚Ä¶*/: outer block doc comment. See Comments.\n!: always empty Never type. See Diverging Functions.\n(): empty tuple (a.k.a. unit), both literal and type.\n(expr): parenthesized expression.\n(expr,): single-element tuple expression. See Primitive Types (Tuples).\n(type,): single-element tuple type. See Primitive Types (Tuples).\n(expr, ‚Ä¶): tuple expression. See Primitive Types (Tuples).\n(type, ‚Ä¶): tuple type. See Primitive Types (Tuples).\nexpr(expr, ‚Ä¶): function call expression. Also used to initialize tuple structs and tuple enum variants. See Functions.\nident!(‚Ä¶), ident!{‚Ä¶}, ident![‚Ä¶]: macro invocation. See Macros.\nexpr.0, expr.1, ‚Ä¶: tuple indexing. See Primitive Types (Tuple Indexing).\n{‚Ä¶}: block expression.\nType {‚Ä¶}: struct literal. See Structs.\n[‚Ä¶]: array literal. See Primitive Types (Arrays).\n[expr; len]: array literal containing len copies of expr. See Primitive Types (Arrays).\n[type; len]: array type containing len instances of type. See Primitive Types (Arrays).\nexpr[expr]: collection indexing. Overloadable (Index, IndexMut).\nexpr[..], expr[a..], expr[..b], expr[a..b]: collection indexing pretending to be collection slicing, using Range, RangeFrom, RangeTo, RangeFull as the \"index\".\nBibliography\n\nThis is a reading list of material relevant to Rust. It includes prior research that has - at one time or another - influenced the design of Rust, as well as publications about Rust.\n\nType system\nRegion based memory management in Cyclone\nSafe manual memory management in Cyclone\nTypeclasses: making ad-hoc polymorphism less ad hoc\nMacros that work together\nTraits: composable units of behavior\nAlias burying - We tried something similar and abandoned it.\nExternal uniqueness is unique enough\nUniqueness and Reference Immutability for Safe Parallelism\nRegion Based Memory Management\nConcurrency\nSingularity: rethinking the software stack\nLanguage support for fast and reliable message passing in singularity OS\nScheduling multithreaded computations by work stealing\nThread scheduling for multiprogramming multiprocessors\nThe data locality of work stealing\nDynamic circular work stealing deque - The Chase/Lev deque\nWork-first and help-first scheduling policies for async-finish task parallelism - More general than fully-strict work stealing\nA Java fork/join calamity - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation\nScheduling techniques for concurrent systems\nContention aware scheduling\nBalanced work stealing for time-sharing multicores\nThree layer cake for shared-memory programming\nNon-blocking steal-half work queues\nReagents: expressing and composing fine-grained concurrency\nAlgorithms for scalable synchronization of shared-memory multiprocessors\nEpoch-based reclamation.\nOthers\nCrash-only software\nComposing High-Performance Memory Allocators\nReconsidering Custom Memory Allocation\nPapers about Rust\nGPU Programming in Rust: Implementing High Level Abstractions in a Systems Level Language. Early GPU work by Eric Holk.\nParallel closures: a new twist on an old idea\nnot exactly about Rust, but by nmatsakis\nPatina: A Formalization of the Rust Programming Language. Early formalization of a subset of the type system, by Eric Reed.\nExperience Report: Developing the Servo Web Browser Engine using Rust. By Lars Bergstrom.\nImplementing a Generic Radix Trie in Rust. Undergrad paper by Michael Sproul.\nReenix: Implementing a Unix-Like Operating System in Rust. Undergrad paper by Alex Light.\nEvaluation of performance and productivity metrics of potential programming languages in the HPC environment. Bachelor's thesis by Florian Wilkens. Compares C, Go and Rust.\nNom, a byte oriented, streaming, zero copy, parser combinators library in Rust. By Geoffroy Couprie, research for VLC.\nGraph-Based Higher-Order Intermediate Representation. An experimental IR implemented in Impala, a Rust-like language.\nCode Refinement of Stencil Codes. Another paper using Impala.\nParallelization in Rust with fork-join and friends. Linus Farnstrand's master's thesis.\nSession Types for Rust. Philip Munksgaard's master's thesis. Research for Servo.\nOwnership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.\nYou can't spell trust without Rust. Alexis Beingessner's master's thesis.\nRust as a Language for High Performance GC Implementation"
  },
  {
    "title": "Bibliography - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/bibliography.html",
    "html": "Bibliography\n\nThis is a reading list of material relevant to Rust. It includes prior research that has - at one time or another - influenced the design of Rust, as well as publications about Rust.\n\nType system\nRegion based memory management in Cyclone\nSafe manual memory management in Cyclone\nTypeclasses: making ad-hoc polymorphism less ad hoc\nMacros that work together\nTraits: composable units of behavior\nAlias burying - We tried something similar and abandoned it.\nExternal uniqueness is unique enough\nUniqueness and Reference Immutability for Safe Parallelism\nRegion Based Memory Management\nConcurrency\nSingularity: rethinking the software stack\nLanguage support for fast and reliable message passing in singularity OS\nScheduling multithreaded computations by work stealing\nThread scheduling for multiprogramming multiprocessors\nThe data locality of work stealing\nDynamic circular work stealing deque - The Chase/Lev deque\nWork-first and help-first scheduling policies for async-finish task parallelism - More general than fully-strict work stealing\nA Java fork/join calamity - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation\nScheduling techniques for concurrent systems\nContention aware scheduling\nBalanced work stealing for time-sharing multicores\nThree layer cake for shared-memory programming\nNon-blocking steal-half work queues\nReagents: expressing and composing fine-grained concurrency\nAlgorithms for scalable synchronization of shared-memory multiprocessors\nEpoch-based reclamation.\nOthers\nCrash-only software\nComposing High-Performance Memory Allocators\nReconsidering Custom Memory Allocation\nPapers about Rust\nGPU Programming in Rust: Implementing High Level Abstractions in a Systems Level Language. Early GPU work by Eric Holk.\nParallel closures: a new twist on an old idea\nnot exactly about Rust, but by nmatsakis\nPatina: A Formalization of the Rust Programming Language. Early formalization of a subset of the type system, by Eric Reed.\nExperience Report: Developing the Servo Web Browser Engine using Rust. By Lars Bergstrom.\nImplementing a Generic Radix Trie in Rust. Undergrad paper by Michael Sproul.\nReenix: Implementing a Unix-Like Operating System in Rust. Undergrad paper by Alex Light.\nEvaluation of performance and productivity metrics of potential programming languages in the HPC environment. Bachelor's thesis by Florian Wilkens. Compares C, Go and Rust.\nNom, a byte oriented, streaming, zero copy, parser combinators library in Rust. By Geoffroy Couprie, research for VLC.\nGraph-Based Higher-Order Intermediate Representation. An experimental IR implemented in Impala, a Rust-like language.\nCode Refinement of Stencil Codes. Another paper using Impala.\nParallelization in Rust with fork-join and friends. Linus Farnstrand's master's thesis.\nSession Types for Rust. Philip Munksgaard's master's thesis. Research for Servo.\nOwnership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.\nYou can't spell trust without Rust. Alexis Beingessner's master's thesis.\nRust as a Language for High Performance GC Implementation"
  },
  {
    "title": "Syntax Index - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/syntax-index.html",
    "html": "Syntax Index\nKeywords\nas: primitive casting, or disambiguating the specific trait containing an item. See Casting Between Types (as), Universal Function Call Syntax (Angle-bracket Form), Associated Types.\nbreak: break out of loop. See Loops (Ending Iteration Early).\nconst: constant items and constant raw pointers. See const and static, Raw Pointers.\ncontinue: continue to next loop iteration. See Loops (Ending Iteration Early).\ncrate: external crate linkage. See Crates and Modules (Importing External Crates).\nelse: fallback for if and if let constructs. See if, if let.\nenum: defining enumeration. See Enums.\nextern: external crate, function, and variable linkage. See Crates and Modules (Importing External Crates), Foreign Function Interface.\nfalse: boolean false literal. See Primitive Types (Booleans).\nfn: function definition and function pointer types. See Functions.\nfor: iterator loop, part of trait impl syntax, and higher-ranked lifetime syntax. See Loops (for), Method Syntax.\nif: conditional branching. See if, if let.\nimpl: inherent and trait implementation blocks. See Method Syntax.\nin: part of for loop syntax. See Loops (for).\nlet: variable binding. See Variable Bindings.\nloop: unconditional, infinite loop. See Loops (loop).\nmatch: pattern matching. See Match.\nmod: module declaration. See Crates and Modules (Defining Modules).\nmove: part of closure syntax. See Closures (move closures).\nmut: denotes mutability in pointer types and pattern bindings. See Mutability.\npub: denotes public visibility in struct fields, impl blocks, and modules. See Crates and Modules (Exporting a Public Interface).\nref: by-reference binding. See Patterns (ref and ref mut).\nreturn: return from function. See Functions (Early Returns).\nSelf: implementor type alias. See Traits.\nself: method subject. See Method Syntax (Method Calls).\nstatic: global variable. See const and static (static).\nstruct: structure definition. See Structs.\ntrait: trait definition. See Traits.\ntrue: boolean true literal. See Primitive Types (Booleans).\ntype: type alias, and associated type definition. See type Aliases, Associated Types.\nunsafe: denotes unsafe code, functions, traits, and implementations. See Unsafe.\nuse: import symbols into scope. See Crates and Modules (Importing Modules with use).\nwhere: type constraint clauses. See Traits (where clause).\nwhile: conditional loop. See Loops (while).\nOperators and Symbols\n! (ident!(‚Ä¶), ident!{‚Ä¶}, ident![‚Ä¶]): denotes macro expansion. See Macros.\n! (!expr): bitwise or logical complement. Overloadable (Not).\n!= (var != expr): nonequality comparison. Overloadable (PartialEq).\n% (expr % expr): arithmetic remainder. Overloadable (Rem).\n%= (var %= expr): arithmetic remainder & assignment. Overloadable (RemAssign).\n& (expr & expr): bitwise and. Overloadable (BitAnd).\n& (&expr, &mut expr): borrow. See References and Borrowing.\n& (&type, &mut type, &'a type, &'a mut type): borrowed pointer type. See References and Borrowing.\n&= (var &= expr): bitwise and & assignment. Overloadable (BitAndAssign).\n&& (expr && expr): logical and.\n* (expr * expr): arithmetic multiplication. Overloadable (Mul).\n* (*expr): dereference.\n* (*const type, *mut type): raw pointer. See Raw Pointers.\n*= (var *= expr): arithmetic multiplication & assignment. Overloadable (MulAssign).\n+ (expr + expr): arithmetic addition. Overloadable (Add).\n+ (trait + trait, 'a + trait): compound type constraint. See Traits (Multiple Trait Bounds).\n+= (var += expr): arithmetic addition & assignment. Overloadable (AddAssign).\n,: argument and element separator. See Attributes, Functions, Structs, Generics, Match, Closures, Crates and Modules (Importing Modules with use).\n- (expr - expr): arithmetic subtraction. Overloadable (Sub).\n- (- expr): arithmetic negation. Overloadable (Neg).\n-= (var -= expr): arithmetic subtraction & assignment. Overloadable (SubAssign).\n-> (fn(‚Ä¶) -> type, |‚Ä¶| -> type): function and closure return type. See Functions, Closures.\n. (expr.ident): member access. See Structs, Method Syntax.\n.. (.., expr.., ..expr, expr..expr): right-exclusive range literal.\n.. (..expr): struct literal update syntax. See Structs (Update syntax).\n.. (variant(x, ..), struct_type { x, .. }): \"and the rest\" pattern binding. See Patterns (Ignoring bindings).\n... (...expr, expr...expr) in an expression: inclusive range expression. See Iterators.\n... (expr...expr) in a pattern: inclusive range pattern. See Patterns (Ranges).\n/ (expr / expr): arithmetic division. Overloadable (Div).\n/= (var /= expr): arithmetic division & assignment. Overloadable (DivAssign).\n: (pat: type, ident: type): constraints. See Variable Bindings, Functions, Structs, Traits.\n: (ident: expr): struct field initializer. See Structs.\n: ('a: loop {‚Ä¶}): loop label. See Loops (Loops Labels).\n;: statement and item terminator.\n; ([‚Ä¶; len]): part of fixed-size array syntax. See Primitive Types (Arrays).\n<< (expr << expr): left-shift. Overloadable (Shl).\n<<= (var <<= expr): left-shift & assignment. Overloadable (ShlAssign).\n< (expr < expr): less-than comparison. Overloadable (PartialOrd).\n<= (var <= expr): less-than or equal-to comparison. Overloadable (PartialOrd).\n= (var = expr, ident = type): assignment/equivalence. See Variable Bindings, type Aliases, generic parameter defaults.\n== (var == expr): equality comparison. Overloadable (PartialEq).\n=> (pat => expr): part of match arm syntax. See Match.\n> (expr > expr): greater-than comparison. Overloadable (PartialOrd).\n>= (var >= expr): greater-than or equal-to comparison. Overloadable (PartialOrd).\n>> (expr >> expr): right-shift. Overloadable (Shr).\n>>= (var >>= expr): right-shift & assignment. Overloadable (ShrAssign).\n@ (ident @ pat): pattern binding. See Patterns (Bindings).\n^ (expr ^ expr): bitwise exclusive or. Overloadable (BitXor).\n^= (var ^= expr): bitwise exclusive or & assignment. Overloadable (BitXorAssign).\n| (expr | expr): bitwise or. Overloadable (BitOr).\n| (pat | pat): pattern alternatives. See Patterns (Multiple patterns).\n| (|‚Ä¶| expr): closures. See Closures.\n|= (var |= expr): bitwise or & assignment. Overloadable (BitOrAssign).\n|| (expr || expr): logical or.\n_: \"ignored\" pattern binding (see Patterns (Ignoring bindings)). Also used to make integer-literals readable (see Reference (Integer literals)).\n? (expr?): Error propagation. Returns early when Err(_) is encountered, unwraps otherwise. Similar to the try! macro.\nOther Syntax\n'ident: named lifetime or loop label. See Lifetimes, Loops (Loops Labels).\n‚Ä¶u8, ‚Ä¶i32, ‚Ä¶f64, ‚Ä¶usize, ‚Ä¶: numeric literal of specific type.\n\"‚Ä¶\": string literal. See Strings.\nr\"‚Ä¶\", r#\"‚Ä¶\"#, r##\"‚Ä¶\"##, ‚Ä¶: raw string literal, escape characters are not processed. See Reference (Raw String Literals).\nb\"‚Ä¶\": byte string literal, constructs a [u8] instead of a string. See Reference (Byte String Literals).\nbr\"‚Ä¶\", br#\"‚Ä¶\"#, br##\"‚Ä¶\"##, ‚Ä¶: raw byte string literal, combination of raw and byte string literal. See Reference (Raw Byte String Literals).\n'‚Ä¶': character literal. See Primitive Types (char).\nb'‚Ä¶': ASCII byte literal.\n|‚Ä¶| expr: closure. See Closures.\nident::ident: path. See Crates and Modules (Defining Modules).\n::path: path relative to the crate root (i.e. an explicitly absolute path). See Crates and Modules (Re-exporting with pub use).\nself::path: path relative to the current module (i.e. an explicitly relative path). See Crates and Modules (Re-exporting with pub use).\nsuper::path: path relative to the parent of the current module. See Crates and Modules (Re-exporting with pub use).\ntype::ident, <type as trait>::ident: associated constants, functions, and types. See Associated Types.\n<type>::‚Ä¶: associated item for a type which cannot be directly named (e.g. <&T>::‚Ä¶, <[T]>::‚Ä¶, etc.). See Associated Types.\ntrait::method(‚Ä¶): disambiguating a method call by naming the trait which defines it. See Universal Function Call Syntax.\ntype::method(‚Ä¶): disambiguating a method call by naming the type for which it's defined. See Universal Function Call Syntax.\n<type as trait>::method(‚Ä¶): disambiguating a method call by naming the trait and type. See Universal Function Call Syntax (Angle-bracket Form).\npath<‚Ä¶> (e.g. Vec<u8>): specifies parameters to generic type in a type. See Generics.\npath::<‚Ä¶>, method::<‚Ä¶> (e.g. \"42\".parse::<i32>()): specifies parameters to generic type, function, or method in an expression. See Generics ¬ß Resolving ambiguities.\nfn ident<‚Ä¶> ‚Ä¶: define generic function. See Generics.\nstruct ident<‚Ä¶> ‚Ä¶: define generic structure. See Generics.\nenum ident<‚Ä¶> ‚Ä¶: define generic enumeration. See Generics.\nimpl<‚Ä¶> ‚Ä¶: define generic implementation.\nfor<‚Ä¶> type: higher-ranked lifetime bounds.\ntype<ident=type> (e.g. Iterator<Item=T>): a generic type where one or more associated types have specific assignments. See Associated Types.\nT: U: generic parameter T constrained to types that implement U. See Traits.\nT: 'a: generic type T must outlive lifetime 'a. When we say that a type 'outlives' the lifetime, we mean that it cannot transitively contain any references with lifetimes shorter than 'a.\nT : 'static: The generic type T contains no borrowed references other than 'static ones.\n'b: 'a: generic lifetime 'b must outlive lifetime 'a.\nT: ?Sized: allow generic type parameter to be a dynamically-sized type. See Unsized Types (?Sized).\n'a + trait, trait + trait: compound type constraint. See Traits (Multiple Trait Bounds).\n#[meta]: outer attribute. See Attributes.\n#![meta]: inner attribute. See Attributes.\n$ident: macro substitution. See Macros.\n$ident:kind: macro capture. See Macros.\n$(‚Ä¶)‚Ä¶: macro repetition. See Macros.\n//: line comment. See Comments.\n//!: inner line doc comment. See Comments.\n///: outer line doc comment. See Comments.\n/*‚Ä¶*/: block comment. See Comments.\n/*!‚Ä¶*/: inner block doc comment. See Comments.\n/**‚Ä¶*/: outer block doc comment. See Comments.\n!: always empty Never type. See Diverging Functions.\n(): empty tuple (a.k.a. unit), both literal and type.\n(expr): parenthesized expression.\n(expr,): single-element tuple expression. See Primitive Types (Tuples).\n(type,): single-element tuple type. See Primitive Types (Tuples).\n(expr, ‚Ä¶): tuple expression. See Primitive Types (Tuples).\n(type, ‚Ä¶): tuple type. See Primitive Types (Tuples).\nexpr(expr, ‚Ä¶): function call expression. Also used to initialize tuple structs and tuple enum variants. See Functions.\nident!(‚Ä¶), ident!{‚Ä¶}, ident![‚Ä¶]: macro invocation. See Macros.\nexpr.0, expr.1, ‚Ä¶: tuple indexing. See Primitive Types (Tuple Indexing).\n{‚Ä¶}: block expression.\nType {‚Ä¶}: struct literal. See Structs.\n[‚Ä¶]: array literal. See Primitive Types (Arrays).\n[expr; len]: array literal containing len copies of expr. See Primitive Types (Arrays).\n[type; len]: array type containing len instances of type. See Primitive Types (Arrays).\nexpr[expr]: collection indexing. Overloadable (Index, IndexMut).\nexpr[..], expr[a..], expr[..b], expr[a..b]: collection indexing pretending to be collection slicing, using Range, RangeFrom, RangeTo, RangeFull as the \"index\"."
  },
  {
    "title": "Procedural Macros (and custom derive) - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/procedural-macros.html",
    "html": "Procedural Macros (and custom Derive)\n\nAs you've seen throughout the rest of the book, Rust provides a mechanism called \"derive\" that lets you implement traits easily. For example,\n\n\n#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nis a lot simpler than\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nuse std::fmt;\n\nimpl fmt::Debug for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Point {{ x: {}, y: {} }}\", self.x, self.y)\n    }\n}\n\nRust includes several traits that you can derive, but it also lets you define your own. We can accomplish this task through a feature of Rust called \"procedural macros.\" Eventually, procedural macros will allow for all sorts of advanced metaprogramming in Rust, but today, they're only for custom derive.\n\nLet's build a very simple trait, and derive it with custom derive.\n\nHello World\n\nSo the first thing we need to do is start a new crate for our project.\n\n$ cargo new --bin hello-world\n\n\nAll we want is to be able to call hello_world() on a derived type. Something like this:\n\n#[derive(HelloWorld)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_world();\n}\n\n\nWith some kind of nice output, like Hello, World! My name is Pancakes..\n\nLet's go ahead and write up what we think our macro will look like from a user perspective. In src/main.rs we write:\n\n#[macro_use]\nextern crate hello_world_derive;\n\ntrait HelloWorld {\n    fn hello_world();\n}\n\n#[derive(HelloWorld)]\nstruct FrenchToast;\n\n#[derive(HelloWorld)]\nstruct Waffles;\n\nfn main() {\n    FrenchToast::hello_world();\n    Waffles::hello_world();\n}\n\n\nGreat. So now we just need to actually write the procedural macro. At the moment, procedural macros need to be in their own crate. Eventually, this restriction may be lifted, but for now, it's required. As such, there's a convention; for a crate named foo, a custom derive procedural macro is called foo-derive. Let's start a new crate called hello-world-derive inside our hello-world project.\n\n$ cargo new hello-world-derive\n\n\nTo make sure that our hello-world crate is able to find this new crate we've created, we'll add it to our toml:\n\n[dependencies]\nhello-world-derive = { path = \"hello-world-derive\" }\n\n\nAs for the source of our hello-world-derive crate, here's an example:\n\nextern crate proc_macro;\nextern crate syn;\n#[macro_use]\nextern crate quote;\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_derive(HelloWorld)]\npub fn hello_world(input: TokenStream) -> TokenStream {\n    // Construct a string representation of the type definition\n    let s = input.to_string();\n    \n    // Parse the string representation\n    let ast = syn::parse_derive_input(&s).unwrap();\n\n    // Build the impl\n    let gen = impl_hello_world(&ast);\n    \n    // Return the generated impl\n    gen.parse().unwrap()\n}\n\n\nSo there is a lot going on here. We have introduced two new crates: syn and quote. As you may have noticed, input: TokenSteam is immediately converted to a String. This String is a string representation of the Rust code for which we are deriving HelloWorld. At the moment, the only thing you can do with a TokenStream is convert it to a string. A richer API will exist in the future.\n\nSo what we really need is to be able to parse Rust code into something usable. This is where syn comes to play. syn is a crate for parsing Rust code. The other crate we've introduced is quote. It's essentially the dual of syn as it will make generating Rust code really easy. We could write this stuff on our own, but it's much simpler to use these libraries. Writing a full parser for Rust code is no simple task.\n\nThe comments seem to give us a pretty good idea of our overall strategy. We are going to take a String of the Rust code for the type we are deriving, parse it using syn, construct the implementation of hello_world (using quote), then pass it back to Rust compiler.\n\nOne last note: you'll see some unwrap()s there. If you want to provide an error for a procedural macro, then you should panic! with the error message. In this case, we're keeping it as simple as possible.\n\nGreat, so let's write impl_hello_world(&ast).\n\nfn impl_hello_world(ast: &syn::DeriveInput) -> quote::Tokens {\n    let name = &ast.ident;\n    quote! {\n        impl HelloWorld for #name {\n            fn hello_world() {\n                println!(\"Hello, World! My name is {}\", stringify!(#name));\n            }\n        }\n    }\n}\n\n\nSo this is where quotes comes in. The ast argument is a struct that gives us a representation of our type (which can be either a struct or an enum). Check out the docs, there is some useful information there. We are able to get the name of the type using ast.ident. The quote! macro lets us write up the Rust code that we wish to return and convert it into Tokens. quote! lets us use some really cool templating mechanics; we simply write #name and quote! will replace it with the variable named name. You can even do some repetition similar to regular macros work. You should check out the docs for a good introduction.\n\nSo I think that's it. Oh, well, we do need to add dependencies for syn and quote in the Cargo.toml for hello-world-derive.\n\n[dependencies]\nsyn = \"0.11.11\"\nquote = \"0.3.15\"\n\n\nThat should be it. Let's try to compile hello-world.\n\nerror: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type\n --> hello-world-derive/src/lib.rs:8:3\n  |\n8 | #[proc_macro_derive(HelloWorld)]\n  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nOh, so it appears that we need to declare that our hello-world-derive crate is a proc-macro crate type. How do we do this? Like this:\n\n[lib]\nproc-macro = true\n\n\nOk so now, let's compile hello-world. Executing cargo run now yields:\n\nHello, World! My name is FrenchToast\nHello, World! My name is Waffles\n\n\nWe've done it!\n\nCustom Attributes\n\nIn some cases it might make sense to allow users some kind of configuration. For example, the user might want to overwrite the name that is printed in the hello_world() method.\n\nThis can be achieved with custom attributes:\n\n#[derive(HelloWorld)]\n#[HelloWorldName = \"the best Pancakes\"]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_world();\n}\n\n\nIf we try to compile this though, the compiler will respond with an error:\n\nerror: The attribute `HelloWorldName` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n\n\nThe compiler needs to know that we're handling this attribute and to not respond with an error. This is done in the hello-world-derive crate by adding attributes to the proc_macro_derive attribute:\n\n#[proc_macro_derive(HelloWorld, attributes(HelloWorldName))]\npub fn hello_world(input: TokenStream) -> TokenStream \n\n\nMultiple attributes can be specified that way.\n\nRaising Errors\n\nLet's assume that we do not want to accept enums as input to our custom derive method.\n\nThis condition can be easily checked with the help of syn. But how do we tell the user, that we do not accept enums? The idiomatic way to report errors in procedural macros is to panic:\n\nfn impl_hello_world(ast: &syn::DeriveInput) -> quote::Tokens {\n    let name = &ast.ident;\n    // Check if derive(HelloWorld) was specified for a struct\n    if let syn::Body::Struct(_) = ast.body {\n        // Yes, this is a struct\n        quote! {\n            impl HelloWorld for #name {\n                fn hello_world() {\n                    println!(\"Hello, World! My name is {}\", stringify!(#name));\n                }\n            }\n        }\n    } else {\n        //Nope. This is an Enum. We cannot handle these!\n       panic!(\"#[derive(HelloWorld)] is only defined for structs, not for enums!\");\n    }\n}\n\n\nIf a user now tries to derive HelloWorld from an enum they will be greeted with following, hopefully helpful, error:\n\nerror: custom derive attribute panicked\n  --> src/main.rs\n   |\n   | #[derive(HelloWorld)]\n   |          ^^^^^^^^^^\n   |\n   = help: message: #[derive(HelloWorld)] is only defined for structs, not for enums!\n"
  },
  {
    "title": "Glossary - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/glossary.html",
    "html": "Glossary\n\nNot every Rustacean has a background in systems programming, nor in computer science, so we've added explanations of terms that might be unfamiliar.\n\nAbstract Syntax Tree\n\nWhen a compiler is compiling your program, it does a number of different things. One of the things that it does is turn the text of your program into an ‚Äòabstract syntax tree‚Äô, or ‚ÄòAST‚Äô. This tree is a representation of the structure of your program. For example, 2 + 3 can be turned into a tree:\n\n  +\n / \\\n2   3\n\n\nAnd 2 + (3 * 4) would look like this:\n\n  +\n / \\\n2   *\n   / \\\n  3   4\n\nArity\n\nArity refers to the number of arguments a function or operation takes.\n\n\nlet x = (2, 3);\nlet y = (4, 6);\nlet z = (8, 2, 6);\n\nIn the example above x and y have arity 2. z has arity 3.\n\nBounds\n\nBounds are constraints on a type or trait. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.\n\nCombinators\n\nCombinators are higher-order functions that apply only functions and earlier defined combinators to provide a result from its arguments. They can be used to manage control flow in a modular fashion.\n\nDST (Dynamically Sized Type)\n\nA type without a statically known size or alignment. (more info)\n\nExpression\n\nIn computer programming, an expression is a combination of values, constants, variables, operators and functions that evaluate to a single value. For example, 2 + (3 * 4) is an expression that returns the value 14. It is worth noting that expressions can have side-effects. For example, a function included in an expression might perform actions other than simply returning a value.\n\nExpression-Oriented Language\n\nIn early programming languages, expressions and statements were two separate syntactic categories: expressions had a value and statements did things. However, later languages blurred this distinction, allowing expressions to do things and statements to have a value. In an expression-oriented language, (nearly) every statement is an expression and therefore returns a value. Consequently, these expression statements can themselves form part of larger expressions.\n\nStatement\n\nIn computer programming, a statement is the smallest standalone element of a programming language that commands a computer to perform an action."
  },
  {
    "title": "Using Rust without the standard library - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/using-rust-without-the-standard-library.html",
    "html": "Using Rust Without the Standard Library\n\nRust‚Äôs standard library provides a lot of useful functionality, but assumes support for various features of its host system: threads, networking, heap allocation, and others. There are systems that do not have these features, however, and Rust can work with those too! To do so, we tell Rust that we don‚Äôt want to use the standard library via an attribute: #![no_std].\n\nNote: This feature is technically stable, but there are some caveats. For one, you can build a #![no_std] library on stable, but not a binary. For details on binaries without the standard library, see the nightly chapter on 'lang items'\n\nTo use #![no_std], add it to your crate root:\n\n#![no_std]\n\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\n\nMuch of the functionality that‚Äôs exposed in the standard library is also available via the core crate. When we‚Äôre using the standard library, Rust automatically brings std into scope, allowing you to use its features without an explicit import. By the same token, when using #![no_std], Rust will bring core into scope for you, as well as its prelude. This means that a lot of code will Just Work:\n\n#![no_std]\n\nfn may_fail(failure: bool) -> Result<(), &'static str> {\n    if failure {\n        Err(\"this didn‚Äôt work!\")\n    } else {\n        Ok(())\n    }\n}\n"
  },
  {
    "title": "Release Channels - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/release-channels.html",
    "html": "Release Channels\n\nThe Rust project uses a concept called ‚Äòrelease channels‚Äô to manage releases. It‚Äôs important to understand this process to choose which version of Rust your project should use.\n\nOverview\n\nThere are three channels for Rust releases:\n\nNightly\nBeta\nStable\n\nNew nightly releases are created once a day. Every six weeks, the latest nightly release is promoted to ‚ÄòBeta‚Äô. At that point, it will only receive patches to fix serious errors. Six weeks later, the beta is promoted to ‚ÄòStable‚Äô, and becomes the next release of 1.x.\n\nThis process happens in parallel. So every six weeks, on the same day, nightly goes to beta, beta goes to stable. When 1.x is released, at the same time, 1.(x + 1)-beta is released, and the nightly becomes the first version of 1.(x + 2)-nightly.\n\nChoosing a version\n\nGenerally speaking, unless you have a specific reason, you should be using the stable release channel. These releases are intended for a general audience.\n\nHowever, depending on your interest in Rust, you may choose to use nightly instead. The basic trade-off is this: in the nightly channel, you can use unstable, new Rust features. However, unstable features are subject to change, and so any new nightly release may break your code. If you use the stable release, you cannot use experimental features, but the next release of Rust will not cause significant issues through breaking changes.\n\nHelping the ecosystem through CI\n\nWhat about beta? We encourage all Rust users who use the stable release channel to also test against the beta channel in their continuous integration systems. This will help alert the team in case there‚Äôs an accidental regression.\n\nAdditionally, testing against nightly can catch regressions even sooner, and so if you don‚Äôt mind a third build, we‚Äôd appreciate testing against all channels.\n\nAs an example, many Rust programmers use Travis to test their crates, which is free for open source projects. Travis supports Rust directly, and you can use a .travis.yml file like this to test on all channels:\n\nlanguage: rust\nrust:\n  - nightly\n  - beta\n  - stable\n\nmatrix:\n  allow_failures:\n    - rust: nightly\n\n\nWith this configuration, Travis will test all three channels, but if something breaks on nightly, it won‚Äôt fail your build. A similar configuration is recommended for any CI system, check the documentation of the one you‚Äôre using for more details."
  },
  {
    "title": "Borrow and AsRef - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/borrow-and-asref.html",
    "html": "Borrow and AsRef\n\nThe Borrow and AsRef traits are very similar, but different. Here‚Äôs a quick refresher on what these two traits mean.\n\nBorrow\n\nThe Borrow trait is used when you‚Äôre writing a data structure, and you want to use either an owned or borrowed type as synonymous for some purpose.\n\nFor example, HashMap has a get method which uses Borrow:\n\nfn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n    where K: Borrow<Q>,\n          Q: Hash + Eq\n\n\nThis signature is pretty complicated. The K parameter is what we‚Äôre interested in here. It refers to a parameter of the HashMap itself:\n\nstruct HashMap<K, V, S = RandomState> {\n\n\nThe K parameter is the type of key the HashMap uses. So, looking at the signature of get() again, we can use get() when the key implements Borrow<Q>. That way, we can make a HashMap which uses String keys, but use &strs when we‚Äôre searching:\n\n\nuse std::collections::HashMap;\n\nlet mut map = HashMap::new();\nmap.insert(\"Foo\".to_string(), 42);\n\nassert_eq!(map.get(\"Foo\"), Some(&42));\n\nThis is because the standard library has impl Borrow<str> for String.\n\nFor most types, when you want to take an owned or borrowed type, a &T is enough. But one area where Borrow is effective is when there‚Äôs more than one kind of borrowed value. This is especially true of references and slices: you can have both an &T or a &mut T. If we wanted to accept both of these types, Borrow is up for it:\n\n\nuse std::borrow::Borrow;\nuse std::fmt::Display;\n\nfn foo<T: Borrow<i32> + Display>(a: T) {\n    println!(\"a is borrowed: {}\", a);\n}\n\nlet mut i = 5;\n\nfoo(&i);\nfoo(&mut i);\n\nThis will print out a is borrowed: 5 twice.\n\nAsRef\n\nThe AsRef trait is a conversion trait. It‚Äôs used for converting some value to a reference in generic code. Like this:\n\n\nlet s = \"Hello\".to_string();\n\nfn foo<T: AsRef<str>>(s: T) {\n    let slice = s.as_ref();\n}\nWhich should I use?\n\nWe can see how they‚Äôre kind of the same: they both deal with owned and borrowed versions of some type. However, they‚Äôre a bit different.\n\nChoose Borrow when you want to abstract over different kinds of borrowing, or when you‚Äôre building a data structure that treats owned and borrowed values in equivalent ways, such as hashing and comparison.\n\nChoose AsRef when you want to convert something to a reference directly, and you‚Äôre writing generic code."
  },
  {
    "title": "Error Handling - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/error-handling.html",
    "html": "Error Handling\n\nLike most programming languages, Rust encourages the programmer to handle errors in a particular way. Generally speaking, error handling is divided into two broad categories: exceptions and return values. Rust opts for return values.\n\nIn this section, we intend to provide a comprehensive treatment of how to deal with errors in Rust. More than that, we will attempt to introduce error handling one piece at a time so that you'll come away with a solid working knowledge of how everything fits together.\n\nWhen done na√Øvely, error handling in Rust can be verbose and annoying. This section will explore those stumbling blocks and demonstrate how to use the standard library to make error handling concise and ergonomic.\n\nTable of Contents\n\nThis section is very long, mostly because we start at the very beginning with sum types and combinators, and try to motivate the way Rust does error handling incrementally. As such, programmers with experience in other expressive type systems may want to jump around.\n\nThe Basics\nUnwrapping explained\nThe Option type\nComposing Option<T> values\nThe Result type\nParsing integers\nThe Result type alias idiom\nA brief interlude: unwrapping isn't evil\nWorking with multiple error types\nComposing Option and Result\nThe limits of combinators\nEarly returns\nThe try! macro\nDefining your own error type\nStandard library traits used for error handling\nThe Error trait\nThe From trait\nThe real try! macro\nComposing custom error types\nAdvice for library writers\nCase study: A program to read population data\nInitial setup\nArgument parsing\nWriting the logic\nError handling with Box<Error>\nReading from stdin\nError handling with a custom type\nAdding functionality\nThe short story\nThe Basics\n\nYou can think of error handling as using case analysis to determine whether a computation was successful or not. As you will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has to do while keeping code composable.\n\nKeeping code composable is important, because without that requirement, we could panic whenever we come across something unexpected. (panic causes the current task to unwind, and in most cases, the entire program aborts.) Here's an example:\n\n// Guess a number between 1 and 10.\n// If it matches the number we had in mind, return `true`. Else, return `false`.\nfn guess(n: i32) -> bool {\n    if n < 1 || n > 10 {\n        panic!(\"Invalid number: {}\", n);\n    }\n    n == 5\n}\n\nfn main() {\n    guess(11);\n}\n\n\nIf you try running this code, the program will crash with a message like this:\n\nthread 'main' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5\n\n\nHere's another example that is slightly less contrived. A program that accepts an integer as an argument, doubles it and prints it.\n\nuse std::env;\n\nfn main() {\n    let mut argv = env::args();\n    let arg: String = argv.nth(1).unwrap(); // error 1\n    let n: i32 = arg.parse().unwrap(); // error 2\n    println!(\"{}\", 2 * n);\n}\n\n\nIf you give this program zero arguments (error 1) or if the first argument isn't an integer (error 2), the program will panic just like in the first example.\n\nYou can think of this style of error handling as similar to a bull running through a china shop. The bull will get to where it wants to go, but it will trample everything in the process.\n\nUnwrapping explained\n\nIn the previous example, we claimed that the program would simply panic if it reached one of the two error conditions, yet, the program does not include an explicit call to panic like the first example. This is because the panic is embedded in the calls to unwrap.\n\nTo ‚Äúunwrap‚Äù something in Rust is to say, ‚ÄúGive me the result of the computation, and if there was an error, panic and stop the program.‚Äù It would be better if we showed the code for unwrapping because it is so simple, but to do that, we will first need to explore the Option and Result types. Both of these types have a method called unwrap defined on them.\n\nThe Option type\n\nThe Option type is defined in the standard library:\n\n\nenum Option<T> {\n    None,\n    Some(T),\n}\n\nThe Option type is a way to use Rust's type system to express the possibility of absence. Encoding the possibility of absence into the type system is an important concept because it will cause the compiler to force the programmer to handle that absence. Let's take a look at an example that tries to find a character in a string:\n\n\n// Searches `haystack` for the Unicode character `needle`. If one is found, the\n// byte offset of the character is returned. Otherwise, `None` is returned.\nfn find(haystack: &str, needle: char) -> Option<usize> {\n    for (offset, c) in haystack.char_indices() {\n        if c == needle {\n            return Some(offset);\n        }\n    }\n    None\n}\n\nNotice that when this function finds a matching character, it doesn't only return the offset. Instead, it returns Some(offset). Some is a variant or a value constructor for the Option type. You can think of it as a function with the type fn<T>(value: T) -> Option<T>. Correspondingly, None is also a value constructor, except it has no arguments. You can think of None as a function with the type fn<T>() -> Option<T>.\n\nThis might seem like much ado about nothing, but this is only half of the story. The other half is using the find function we've written. Let's try to use it to find the extension in a file name.\n\nfn main() {\n    let file_name = \"foobar.rs\";\n    match find(file_name, '.') {\n        None => println!(\"No file extension found.\"),\n        Some(i) => println!(\"File extension: {}\", &file_name[i+1..]),\n    }\n}\n\n\nThis code uses pattern matching to do case analysis on the Option<usize> returned by the find function. In fact, case analysis is the only way to get at the value stored inside an Option<T>. This means that you, as the programmer, must handle the case when an Option<T> is None instead of Some(t).\n\nBut wait, what about unwrap, which we used previously? There was no case analysis there! Instead, the case analysis was put inside the unwrap method for you. You could define it yourself if you want:\n\n\nenum Option<T> {\n    None,\n    Some(T),\n}\n\nimpl<T> Option<T> {\n    fn unwrap(self) -> T {\n        match self {\n            Option::Some(val) => val,\n            Option::None =>\n              panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n}\n\nThe unwrap method abstracts away the case analysis. This is precisely the thing that makes unwrap ergonomic to use. Unfortunately, that panic! means that unwrap is not composable: it is the bull in the china shop.\n\nComposing Option<T> values\n\nIn an example from before, we saw how to use find to discover the extension in a file name. Of course, not all file names have a . in them, so it's possible that the file name has no extension. This possibility of absence is encoded into the types using Option<T>. In other words, the compiler will force us to address the possibility that an extension does not exist. In our case, we only print out a message saying as such.\n\nGetting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:\n\n\n// Returns the extension of the given file name, where the extension is defined\n// as all characters following the first `.`.\n// If `file_name` has no `.`, then `None` is returned.\nfn extension_explicit(file_name: &str) -> Option<&str> {\n    match find(file_name, '.') {\n        None => None,\n        Some(i) => Some(&file_name[i+1..]),\n    }\n}\n\n(Pro-tip: don't use this code. Use the extension method in the standard library instead.)\n\nThe code stays simple, but the important thing to notice is that the type of find forces us to consider the possibility of absence. This is a good thing because it means the compiler won't let us accidentally forget about the case where a file name doesn't have an extension. On the other hand, doing explicit case analysis like we've done in extension_explicit every time can get a bit tiresome.\n\nIn fact, the case analysis in extension_explicit follows a very common pattern: map a function on to the value inside of an Option<T>, unless the option is None, in which case, return None.\n\nRust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:\n\n\nfn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {\n    match option {\n        None => None,\n        Some(value) => Some(f(value)),\n    }\n}\n\nIndeed, map is defined as a method on Option<T> in the standard library. As a method, it has a slightly different signature: methods take self, &self, or &mut self as their first argument.\n\nArmed with our new combinator, we can rewrite our extension_explicit method to get rid of the case analysis:\n\n\n// Returns the extension of the given file name, where the extension is defined\n// as all characters following the first `.`.\n// If `file_name` has no `.`, then `None` is returned.\nfn extension(file_name: &str) -> Option<&str> {\n    find(file_name, '.').map(|i| &file_name[i+1..])\n}\n\nOne other pattern we commonly find is assigning a default value to the case when an Option value is None. For example, maybe your program assumes that the extension of a file is rs even if none is present. As you might imagine, the case analysis for this is not specific to file extensions - it can work with any Option<T>:\n\n\nfn unwrap_or<T>(option: Option<T>, default: T) -> T {\n    match option {\n        None => default,\n        Some(value) => value,\n    }\n}\n\nLike with map above, the standard library implementation is a method instead of a free function.\n\nThe trick here is that the default value must have the same type as the value that might be inside the Option<T>. Using it is dead simple in our case:\n\nfn main() {\n    assert_eq!(extension(\"foobar.csv\").unwrap_or(\"rs\"), \"csv\");\n    assert_eq!(extension(\"foobar\").unwrap_or(\"rs\"), \"rs\");\n}\n\n\n(Note that unwrap_or is defined as a method on Option<T> in the standard library, so we use that here instead of the free-standing function we defined above. Don't forget to check out the more general unwrap_or_else method.)\n\nThere is one more combinator that we think is worth paying special attention to: and_then. It makes it easy to compose distinct computations that admit the possibility of absence. For example, much of the code in this section is about finding an extension given a file name. In order to do this, you first need the file name which is typically extracted from a file path. While most file paths have a file name, not all of them do. For example, ., .. or /.\n\nSo, we are tasked with the challenge of finding an extension given a file path. Let's start with explicit case analysis:\n\n\nfn file_path_ext_explicit(file_path: &str) -> Option<&str> {\n    match file_name(file_path) {\n        None => None,\n        Some(name) => match extension(name) {\n            None => None,\n            Some(ext) => Some(ext),\n        }\n    }\n}\n\nfn file_name(file_path: &str) -> Option<&str> {\n  // Implementation elided.\n  unimplemented!()\n}\n\nYou might think that we could use the map combinator to reduce the case analysis, but its type doesn't quite fit...\n\nfn file_path_ext(file_path: &str) -> Option<&str> {\n    file_name(file_path).map(|x| extension(x)) // This causes a compilation error.\n}\n\n\nThe map function here wraps the value returned by the extension function inside an Option<_> and since the extension function itself returns an Option<&str> the expression file_name(file_path).map(|x| extension(x)) actually returns an Option<Option<&str>>.\n\nBut since file_path_ext just returns Option<&str> (and not Option<Option<&str>>) we get a compilation error.\n\nThe result of the function taken by map as input is always rewrapped with Some. Instead, we need something like map, but which allows the caller to return a Option<_> directly without wrapping it in another Option<_>.\n\nIts generic implementation is even simpler than map:\n\n\nfn and_then<F, T, A>(option: Option<T>, f: F) -> Option<A>\n        where F: FnOnce(T) -> Option<A> {\n    match option {\n        None => None,\n        Some(value) => f(value),\n    }\n}\n\nNow we can rewrite our file_path_ext function without explicit case analysis:\n\n\nfn file_path_ext(file_path: &str) -> Option<&str> {\n    file_name(file_path).and_then(extension)\n}\n\nSide note: Since and_then essentially works like map but returns an Option<_> instead of an Option<Option<_>> it is known as flatmap in some other languages.\n\nThe Option type has many other combinators defined in the standard library. It is a good idea to skim this list and familiarize yourself with what's available‚Äîthey can often reduce case analysis for you. Familiarizing yourself with these combinators will pay dividends because many of them are also defined (with similar semantics) for Result, which we will talk about next.\n\nCombinators make using types like Option ergonomic because they reduce explicit case analysis. They are also composable because they permit the caller to handle the possibility of absence in their own way. Methods like unwrap remove choices because they will panic if Option<T> is None.\n\nThe Result type\n\nThe Result type is also defined in the standard library:\n\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nThe Result type is a richer version of Option. Instead of expressing the possibility of absence like Option does, Result expresses the possibility of error. Usually, the error is used to explain why the execution of some computation failed. This is a strictly more general form of Option. Consider the following type alias, which is semantically equivalent to the real Option<T> in every way:\n\n\ntype Option<T> = Result<T, ()>;\n\nThis fixes the second type parameter of Result to always be () (pronounced ‚Äúunit‚Äù or ‚Äúempty tuple‚Äù). Exactly one value inhabits the () type: (). (Yup, the type and value level terms have the same notation!)\n\nThe Result type is a way of representing one of two possible outcomes in a computation. By convention, one outcome is meant to be expected or ‚ÄúOk‚Äù while the other outcome is meant to be unexpected or ‚ÄúErr‚Äù.\n\nJust like Option, the Result type also has an unwrap method defined in the standard library. Let's define it:\n\n\nimpl<T, E: ::std::fmt::Debug> Result<T, E> {\n    fn unwrap(self) -> T {\n        match self {\n            Result::Ok(val) => val,\n            Result::Err(err) =>\n              panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", err),\n        }\n    }\n}\n\nThis is effectively the same as our definition for Option::unwrap, except it includes the error value in the panic! message. This makes debugging easier, but it also requires us to add a Debug constraint on the E type parameter (which represents our error type). Since the vast majority of types should satisfy the Debug constraint, this tends to work out in practice. (Debug on a type simply means that there's a reasonable way to print a human-readable description of values with that type.)\n\nOK, let's move on to an example.\n\nParsing integers\n\nThe Rust standard library makes converting strings to integers dead simple. It's so easy in fact, that it is very tempting to write something like the following:\n\nfn double_number(number_str: &str) -> i32 {\n    2 * number_str.parse::<i32>().unwrap()\n}\n\nfn main() {\n    let n: i32 = double_number(\"10\");\n    assert_eq!(n, 20);\n}\n\n\nAt this point, you should be skeptical of calling unwrap. For example, if the string doesn't parse as a number, you'll get a panic:\n\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729\n\n\nThis is rather unsightly, and if this happened inside a library you're using, you might be understandably annoyed. Instead, we should try to handle the error in our function and let the caller decide what to do. This means changing the return type of double_number. But to what? Well, that requires looking at the signature of the parse method in the standard library:\n\nimpl str {\n    fn parse<F: FromStr>(&self) -> Result<F, F::Err>;\n}\n\n\nHmm. So we at least know that we need to use a Result. Certainly, it's possible that this could have returned an Option. After all, a string either parses as a number or it doesn't, right? That's certainly a reasonable way to go, but the implementation internally distinguishes why the string didn't parse as an integer. (Whether it's an empty string, an invalid digit, too big or too small.) Therefore, using a Result makes sense because we want to provide more information than simply ‚Äúabsence.‚Äù We want to say why the parsing failed. You should try to emulate this line of reasoning when faced with a choice between Option and Result. If you can provide detailed error information, then you probably should. (We'll see more on this later.)\n\nOK, but how do we write our return type? The parse method as defined above is generic over all the different number types defined in the standard library. We could (and probably should) also make our function generic, but let's favor explicitness for the moment. We only care about i32, so we need to find its implementation of FromStr (do a CTRL-F in your browser for ‚ÄúFromStr‚Äù) and look at its associated type Err. We did this so we can find the concrete error type. In this case, it's std::num::ParseIntError. Finally, we can rewrite our function:\n\nuse std::num::ParseIntError;\n\nfn double_number(number_str: &str) -> Result<i32, ParseIntError> {\n    match number_str.parse::<i32>() {\n        Ok(n) => Ok(2 * n),\n        Err(err) => Err(err),\n    }\n}\n\nfn main() {\n    match double_number(\"10\") {\n        Ok(n) => assert_eq!(n, 20),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n\n\nThis is a little better, but now we've written much more code! The case analysis has once again bitten us.\n\nCombinators to the rescue! Just like Option, Result has lots of combinators defined as methods. There is a large intersection of common combinators between Result and Option. In particular, map is part of that intersection:\n\nuse std::num::ParseIntError;\n\nfn double_number(number_str: &str) -> Result<i32, ParseIntError> {\n    number_str.parse::<i32>().map(|n| 2 * n)\n}\n\nfn main() {\n    match double_number(\"10\") {\n        Ok(n) => assert_eq!(n, 20),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n\n\nThe usual suspects are all there for Result, including unwrap_or and and_then. Additionally, since Result has a second type parameter, there are combinators that affect only the error type, such as map_err (instead of map) and or_else (instead of and_then).\n\nThe Result type alias idiom\n\nIn the standard library, you may frequently see types like Result<i32>. But wait, we defined Result to have two type parameters. How can we get away with only specifying one? The key is to define a Result type alias that fixes one of the type parameters to a particular type. Usually the fixed type is the error type. For example, our previous example parsing integers could be rewritten like this:\n\n\nuse std::num::ParseIntError;\nuse std::result;\n\ntype Result<T> = result::Result<T, ParseIntError>;\n\nfn double_number(number_str: &str) -> Result<i32> {\n    unimplemented!();\n}\n\nWhy would we do this? Well, if we have a lot of functions that could return ParseIntError, then it's much more convenient to define an alias that always uses ParseIntError so that we don't have to write it out all the time.\n\nThe most prominent place this idiom is used in the standard library is with io::Result. Typically, one writes io::Result<T>, which makes it clear that you're using the io module's type alias instead of the plain definition from std::result. (This idiom is also used for fmt::Result.)\n\nA brief interlude: unwrapping isn't evil\n\nIf you've been following along, you might have noticed that I've taken a pretty hard line against calling methods like unwrap that could panic and abort your program. Generally speaking, this is good advice.\n\nHowever, unwrap can still be used judiciously. What exactly justifies use of unwrap is somewhat of a grey area and reasonable people can disagree. I'll summarize some of my opinions on the matter.\n\nIn examples and quick 'n' dirty code. Sometimes you're writing examples or a quick program, and error handling simply isn't important. Beating the convenience of unwrap can be hard in such scenarios, so it is very appealing.\nWhen panicking indicates a bug in the program. When the invariants of your code should prevent a certain case from happening (like, say, popping from an empty stack), then panicking can be permissible. This is because it exposes a bug in your program. This can be explicit, like from an assert! failing, or it could be because your index into an array was out of bounds.\n\nThis is probably not an exhaustive list. Moreover, when using an Option, it is often better to use its expect method. expect does exactly the same thing as unwrap, except it prints a message you give to expect. This makes the resulting panic a bit nicer to deal with, since it will show your message instead of ‚Äúcalled unwrap on a None value.‚Äù\n\nMy advice boils down to this: use good judgment. There's a reason why the words ‚Äúnever do X‚Äù or ‚ÄúY is considered harmful‚Äù don't appear in my writing. There are trade-offs to all things, and it is up to you as the programmer to determine what is acceptable for your use cases. My goal is only to help you evaluate trade-offs as accurately as possible.\n\nNow that we've covered the basics of error handling in Rust, and explained unwrapping, let's start exploring more of the standard library.\n\nWorking with multiple error types\n\nThus far, we've looked at error handling where everything was either an Option<T> or a Result<T, SomeError>. But what happens when you have both an Option and a Result? Or what if you have a Result<T, Error1> and a Result<T, Error2>? Handling composition of distinct error types is the next challenge in front of us, and it will be the major theme throughout the rest of this section.\n\nComposing Option and Result\n\nSo far, I've talked about combinators defined for Option and combinators defined for Result. We can use these combinators to compose results of different computations without doing explicit case analysis.\n\nOf course, in real code, things aren't always as clean. Sometimes you have a mix of Option and Result types. Must we resort to explicit case analysis, or can we continue using combinators?\n\nFor now, let's revisit one of the first examples in this section:\n\nuse std::env;\n\nfn main() {\n    let mut argv = env::args();\n    let arg: String = argv.nth(1).unwrap(); // error 1\n    let n: i32 = arg.parse().unwrap(); // error 2\n    println!(\"{}\", 2 * n);\n}\n\n\nGiven our new found knowledge of Option, Result and their various combinators, we should try to rewrite this so that errors are handled properly and the program doesn't panic if there's an error.\n\nThe tricky aspect here is that argv.nth(1) produces an Option while arg.parse() produces a Result. These aren't directly composable. When faced with both an Option and a Result, the solution is usually to convert the Option to a Result. In our case, the absence of a command line parameter (from env::args()) means the user didn't invoke the program correctly. We could use a String to describe the error. Let's try:\n\nuse std::env;\n\nfn double_arg(mut argv: env::Args) -> Result<i32, String> {\n    argv.nth(1)\n        .ok_or(\"Please give at least one argument\".to_owned())\n        .and_then(|arg| arg.parse::<i32>().map_err(|err| err.to_string()))\n        .map(|n| 2 * n)\n}\n\nfn main() {\n    match double_arg(env::args()) {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nThere are a couple new things in this example. The first is the use of the Option::ok_or combinator. This is one way to convert an Option into a Result. The conversion requires you to specify what error to use if Option is None. Like the other combinators we've seen, its definition is very simple:\n\n\nfn ok_or<T, E>(option: Option<T>, err: E) -> Result<T, E> {\n    match option {\n        Some(val) => Ok(val),\n        None => Err(err),\n    }\n}\n\nThe other new combinator used here is Result::map_err. This is like Result::map, except it maps a function on to the error portion of a Result value. If the Result is an Ok(...) value, then it is returned unmodified.\n\nWe use map_err here because it is necessary for the error types to remain the same (because of our use of and_then). Since we chose to convert the Option<String> (from argv.nth(1)) to a Result<String, String>, we must also convert the ParseIntError from arg.parse() to a String.\n\nThe limits of combinators\n\nDoing IO and parsing input is a very common task, and it's one that I personally have done a lot of in Rust. Therefore, we will use (and continue to use) IO and various parsing routines to exemplify error handling.\n\nLet's start simple. We are tasked with opening a file, reading all of its contents and converting its contents to a number. Then we multiply it by 2 and print the output.\n\nAlthough I've tried to convince you not to use unwrap, it can be useful to first write your code using unwrap. It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling need to occur. Let's start there so we can get a handle on the code, and then refactor it to use better error handling.\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> i32 {\n    let mut file = File::open(file_path).unwrap(); // error 1\n    let mut contents = String::new();\n    file.read_to_string(&mut contents).unwrap(); // error 2\n    let n: i32 = contents.trim().parse().unwrap(); // error 3\n    2 * n\n}\n\nfn main() {\n    let doubled = file_double(\"foobar\");\n    println!(\"{}\", doubled);\n}\n\n\n(N.B. The AsRef<Path> is used because those are the same bounds used on std::fs::File::open. This makes it ergonomic to use any kind of string as a file path.)\n\nThere are three different errors that can occur here:\n\nA problem opening the file.\nA problem reading data from the file.\nA problem parsing the data as a number.\n\nThe first two problems are described via the std::io::Error type. We know this because of the return types of std::fs::File::open and std::io::Read::read_to_string. (Note that they both use the Result type alias idiom described previously. If you click on the Result type, you'll see the type alias, and consequently, the underlying io::Error type.) The third problem is described by the std::num::ParseIntError type. The io::Error type in particular is pervasive throughout the standard library. You will see it again and again.\n\nLet's start the process of refactoring the file_double function. To make this function composable with other components of the program, it should not panic if any of the above error conditions are met. Effectively, this means that the function should return an error if any of its operations fail. Our problem is that the return type of file_double is i32, which does not give us any useful way of reporting an error. Thus, we must start by changing the return type from i32 to something else.\n\nThe first thing we need to decide: should we use Option or Result? We certainly could use Option very easily. If any of the three errors occur, we could simply return None. This will work and it is better than panicking, but we can do much better. Instead, we should pass some detail about the error that occurred. Since we want to express the possibility of error, we should use Result<i32, E>. But what should E be? Since two different types of errors can occur, we need to convert them to a common type. One such type is String. Let's see how that impacts our code:\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    File::open(file_path)\n         .map_err(|err| err.to_string())\n         .and_then(|mut file| {\n              let mut contents = String::new();\n              file.read_to_string(&mut contents)\n                  .map_err(|err| err.to_string())\n                  .map(|_| contents)\n         })\n         .and_then(|contents| {\n              contents.trim().parse::<i32>()\n                      .map_err(|err| err.to_string())\n         })\n         .map(|n| 2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nThis code looks a bit hairy. It can take quite a bit of practice before code like this becomes easy to write. The way we write it is by following the types. As soon as we changed the return type of file_double to Result<i32, String>, we had to start looking for the right combinators. In this case, we only used three different combinators: and_then, map and map_err.\n\nand_then is used to chain multiple computations where each computation could return an error. After opening the file, there are two more computations that could fail: reading from the file and parsing the contents as a number. Correspondingly, there are two calls to and_then.\n\nmap is used to apply a function to the Ok(...) value of a Result. For example, the very last call to map multiplies the Ok(...) value (which is an i32) by 2. If an error had occurred before that point, this operation would have been skipped because of how map is defined.\n\nmap_err is the trick that makes all of this work. map_err is like map, except it applies a function to the Err(...) value of a Result. In this case, we want to convert all of our errors to one type: String. Since both io::Error and num::ParseIntError implement ToString, we can call the to_string() method to convert them.\n\nWith all of that said, the code is still hairy. Mastering use of combinators is important, but they have their limits. Let's try a different approach: early returns.\n\nEarly returns\n\nI'd like to take the code from the previous section and rewrite it using early returns. Early returns let you exit the function early. We can't return early in file_double from inside another closure, so we'll need to revert back to explicit case analysis.\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    let mut file = match File::open(file_path) {\n        Ok(file) => file,\n        Err(err) => return Err(err.to_string()),\n    };\n    let mut contents = String::new();\n    if let Err(err) = file.read_to_string(&mut contents) {\n        return Err(err.to_string());\n    }\n    let n: i32 = match contents.trim().parse() {\n        Ok(n) => n,\n        Err(err) => return Err(err.to_string()),\n    };\n    Ok(2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nReasonable people can disagree over whether this code is better than the code that uses combinators, but if you aren't familiar with the combinator approach, this code looks simpler to read to me. It uses explicit case analysis with match and if let. If an error occurs, it simply stops executing the function and returns the error (by converting it to string).\n\nIsn't this a step backwards though? Previously, we said that the key to ergonomic error handling is reducing explicit case analysis, yet we've reverted back to explicit case analysis here. It turns out, there are multiple ways to reduce explicit case analysis. Combinators aren't the only way.\n\nThe try! macro\n\nA cornerstone of error handling in Rust is the try! macro. The try! macro abstracts case analysis like combinators, but unlike combinators, it also abstracts control flow. Namely, it can abstract the early return pattern seen above.\n\nHere is a simplified definition of a try! macro:\n\n\nmacro_rules! try {\n    ($e:expr) => (match $e {\n        Ok(val) => val,\n        Err(err) => return Err(err),\n    });\n}\n\n(The real definition is a bit more sophisticated. We will address that later.)\n\nUsing the try! macro makes it very easy to simplify our last example. Since it does the case analysis and the early return for us, we get tighter code that is easier to read:\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));\n    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));\n    Ok(2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n\n\nThe map_err calls are still necessary given our definition of try!. This is because the error types still need to be converted to String. The good news is that we will soon learn how to remove those map_err calls! The bad news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove the map_err calls.\n\nDefining your own error type\n\nBefore we dive into some of the standard library error traits, I'd like to wrap up this section by removing the use of String as our error type in the previous examples.\n\nUsing String as we did in our previous examples is convenient because it's easy to convert errors to strings, or even make up your own errors as strings on the spot. However, using String for your errors has some downsides.\n\nThe first downside is that the error messages tend to clutter your code. It's possible to define the error messages elsewhere, but unless you're unusually disciplined, it is very tempting to embed the error message into your code. Indeed, we did exactly this in a previous example.\n\nThe second and more important downside is that Strings are lossy. That is, if all errors are converted to strings, then the errors we pass to the caller become completely opaque. The only reasonable thing the caller can do with a String error is show it to the user. Certainly, inspecting the string to determine the type of error is not robust. (Admittedly, this downside is far more important inside of a library as opposed to, say, an application.)\n\nFor example, the io::Error type embeds an io::ErrorKind, which is structured data that represents what went wrong during an IO operation. This is important because you might want to react differently depending on the error. (e.g., A BrokenPipe error might mean quitting your program gracefully while a NotFound error might mean exiting with an error code and showing an error to the user.) With io::ErrorKind, the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details of an error inside of a String.\n\nInstead of using a String as an error type in our previous example of reading an integer from a file, we can define our own error type that represents errors with structured data. We endeavor to not drop information from underlying errors in case the caller wants to inspect the details.\n\nThe ideal way to represent one of many possibilities is to define our own sum type using enum. In our case, an error is either an io::Error or a num::ParseIntError, so a natural definition arises:\n\n\nuse std::io;\nuse std::num;\n\n// We derive `Debug` because all types should probably derive `Debug`.\n// This gives us a reasonable human-readable description of `CliError` values.\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Parse(num::ParseIntError),\n}\n\nTweaking our code is very easy. Instead of converting errors to strings, we simply convert them to our CliError type using the corresponding value constructor:\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n    let mut file = try!(File::open(file_path).map_err(CliError::Io));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(CliError::Io));\n    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));\n    Ok(2 * n)\n}\n\nfn main() {\n    match file_double(\"foobar\") {\n        Ok(n) => println!(\"{}\", n),\n        Err(err) => println!(\"Error: {:?}\", err),\n    }\n}\n\n\nThe only change here is switching map_err(|e| e.to_string()) (which converts errors to strings) to map_err(CliError::Io) or map_err(CliError::Parse). The caller gets to decide the level of detail to report to the user. In effect, using a String as an error type removes choices from the caller while using a custom enum error type like CliError gives the caller all of the conveniences as before in addition to structured data describing the error.\n\nA rule of thumb is to define your own error type, but a String error type will do in a pinch, particularly if you're writing an application. If you're writing a library, defining your own error type should be strongly preferred so that you don't remove choices from the caller unnecessarily.\n\nStandard library traits used for error handling\n\nThe standard library defines two integral traits for error handling: std::error::Error and std::convert::From. While Error is designed specifically for generically describing errors, the From trait serves a more general role for converting values between two distinct types.\n\nThe Error trait\n\nThe Error trait is defined in the standard library:\n\n\nuse std::fmt::{Debug, Display};\n\ntrait Error: Debug + Display {\n  /// A short description of the error.\n  fn description(&self) -> &str;\n\n  /// The lower level cause of this error, if any.\n  fn cause(&self) -> Option<&Error> { None }\n}\n\nThis trait is super generic because it is meant to be implemented for all types that represent errors. This will prove useful for writing composable code as we'll see later. Otherwise, the trait allows you to do at least the following things:\n\nObtain a Debug representation of the error.\nObtain a user-facing Display representation of the error.\nObtain a short description of the error (via the description method).\nInspect the causal chain of an error, if one exists (via the cause method).\n\nThe first two are a result of Error requiring impls for both Debug and Display. The latter two are from the two methods defined on Error. The power of Error comes from the fact that all error types impl Error, which means errors can be existentially quantified as a trait object. This manifests as either Box<Error> or &Error. Indeed, the cause method returns an &Error, which is itself a trait object. We'll revisit the Error trait's utility as a trait object later.\n\nFor now, it suffices to show an example implementing the Error trait. Let's use the error type we defined in the previous section:\n\n\nuse std::io;\nuse std::num;\n\n// We derive `Debug` because all types should probably derive `Debug`.\n// This gives us a reasonable human-readable description of `CliError` values.\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Parse(num::ParseIntError),\n}\n\nThis particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an error converting a string to a number. The error could represent as many error types as you want by adding new variants to the enum definition.\n\nImplementing Error is pretty straight-forward. It's mostly going to be a lot explicit case analysis.\n\nuse std::error;\nuse std::fmt;\n\nimpl fmt::Display for CliError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            // Both underlying errors already impl `Display`, so we defer to\n            // their implementations.\n            CliError::Io(ref err) => write!(f, \"IO error: {}\", err),\n            CliError::Parse(ref err) => write!(f, \"Parse error: {}\", err),\n        }\n    }\n}\n\nimpl error::Error for CliError {\n    fn description(&self) -> &str {\n        // Both underlying errors already impl `Error`, so we defer to their\n        // implementations.\n        match *self {\n            CliError::Io(ref err) => err.description(),\n            CliError::Parse(ref err) => err.description(),\n        }\n    }\n\n    fn cause(&self) -> Option<&error::Error> {\n        match *self {\n            // N.B. Both of these implicitly cast `err` from their concrete\n            // types (either `&io::Error` or `&num::ParseIntError`)\n            // to a trait object `&Error`. This works because both error types\n            // implement `Error`.\n            CliError::Io(ref err) => Some(err),\n            CliError::Parse(ref err) => Some(err),\n        }\n    }\n}\n\n\nWe note that this is a very typical implementation of Error: match on your different error types and satisfy the contracts defined for description and cause.\n\nThe From trait\n\nThe std::convert::From trait is defined in the standard library:\n\n\ntrait From<T> {\n    fn from(T) -> Self;\n}\n\nDeliciously simple, yes? From is very useful because it gives us a generic way to talk about conversion from a particular type T to some other type (in this case, ‚Äúsome other type‚Äù is the subject of the impl, or Self). The crux of From is the set of implementations provided by the standard library.\n\nHere are a few simple examples demonstrating how From works:\n\n\nlet string: String = From::from(\"foo\");\nlet bytes: Vec<u8> = From::from(\"foo\");\nlet cow: ::std::borrow::Cow<str> = From::from(\"foo\");\n\nOK, so From is useful for converting between strings. But what about errors? It turns out, there is one critical impl:\n\nimpl<'a, E: Error + 'a> From<E> for Box<Error + 'a>\n\n\nThis impl says that for any type that impls Error, we can convert it to a trait object Box<Error>. This may not seem terribly surprising, but it is useful in a generic context.\n\nRemember the two errors we were dealing with previously? Specifically, io::Error and num::ParseIntError. Since both impl Error, they work with From:\n\n\nuse std::error::Error;\nuse std::fs;\nuse std::io;\nuse std::num;\n\n// We have to jump through some hoops to actually get error values:\nlet io_err: io::Error = io::Error::last_os_error();\nlet parse_err: num::ParseIntError = \"not a number\".parse::<i32>().unwrap_err();\n\n// OK, here are the conversions:\nlet err1: Box<Error> = From::from(io_err);\nlet err2: Box<Error> = From::from(parse_err);\n\nThere is a really important pattern to recognize here. Both err1 and err2 have the same type. This is because they are existentially quantified types, or trait objects. In particular, their underlying type is erased from the compiler's knowledge, so it truly sees err1 and err2 as exactly the same. Additionally, we constructed err1 and err2 using precisely the same function call: From::from. This is because From::from is overloaded on both its argument and its return type.\n\nThis pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the same type using the same function.\n\nTime to revisit an old friend; the try! macro.\n\nThe real try! macro\n\nPreviously, we presented this definition of try!:\n\n\nmacro_rules! try {\n    ($e:expr) => (match $e {\n        Ok(val) => val,\n        Err(err) => return Err(err),\n    });\n}\n\nThis is not its real definition. Its real definition is in the standard library:\n\n\nmacro_rules! try {\n    ($e:expr) => (match $e {\n        Ok(val) => val,\n        Err(err) => return Err(::std::convert::From::from(err)),\n    });\n}\n\nThere's one tiny but powerful change: the error value is passed through From::from. This makes the try! macro much more powerful because it gives you automatic type conversion for free.\n\nArmed with our more powerful try! macro, let's take a look at code we wrote previously to read a file and convert its contents to an integer:\n\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));\n    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));\n    Ok(2 * n)\n}\n\nEarlier, we promised that we could get rid of the map_err calls. Indeed, all we have to do is pick a type that From works with. As we saw in the previous section, From has an impl that lets it convert any error type into a Box<Error>:\n\n\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, Box<Error>> {\n    let mut file = try!(File::open(file_path));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents));\n    let n = try!(contents.trim().parse::<i32>());\n    Ok(2 * n)\n}\n\nWe are getting very close to ideal error handling. Our code has very little overhead as a result from error handling because the try! macro encapsulates three things simultaneously:\n\nCase analysis.\nControl flow.\nError type conversion.\n\nWhen all three things are combined, we get code that is unencumbered by combinators, calls to unwrap or case analysis.\n\nThere's one little nit left: the Box<Error> type is opaque. If we return a Box<Error> to the caller, the caller can't (easily) inspect underlying error type. The situation is certainly better than String because the caller can call methods like description and cause, but the limitation remains: Box<Error> is opaque. (N.B. This isn't entirely true because Rust does have runtime reflection, which is useful in some scenarios that are beyond the scope of this section.)\n\nIt's time to revisit our custom CliError type and tie everything together.\n\nComposing custom error types\n\nIn the last section, we looked at the real try! macro and how it does automatic type conversion for us by calling From::from on the error value. In particular, we converted errors to Box<Error>, which works, but the type is opaque to callers.\n\nTo fix this, we use the same remedy that we're already familiar with: a custom error type. Once again, here is the code that reads the contents of a file and converts it to an integer:\n\n\nuse std::fs::File;\nuse std::io::{self, Read};\nuse std::num;\nuse std::path::Path;\n\n// We derive `Debug` because all types should probably derive `Debug`.\n// This gives us a reasonable human-readable description of `CliError` values.\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Parse(num::ParseIntError),\n}\n\nfn file_double_verbose<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n    let mut file = try!(File::open(file_path).map_err(CliError::Io));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents).map_err(CliError::Io));\n    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));\n    Ok(2 * n)\n}\n\nNotice that we still have the calls to map_err. Why? Well, recall the definitions of try! and From. The problem is that there is no From impl that allows us to convert from error types like io::Error and num::ParseIntError to our own custom CliError. Of course, it is easy to fix this! Since we defined CliError, we can impl From with it:\n\n\nuse std::io;\nuse std::num;\n\nimpl From<io::Error> for CliError {\n    fn from(err: io::Error) -> CliError {\n        CliError::Io(err)\n    }\n}\n\nimpl From<num::ParseIntError> for CliError {\n    fn from(err: num::ParseIntError) -> CliError {\n        CliError::Parse(err)\n    }\n}\n\nAll these impls are doing is teaching From how to create a CliError from other error types. In our case, construction is as simple as invoking the corresponding value constructor. Indeed, it is typically this easy.\n\nWe can finally rewrite file_double:\n\n\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nfn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n    let mut file = try!(File::open(file_path));\n    let mut contents = String::new();\n    try!(file.read_to_string(&mut contents));\n    let n: i32 = try!(contents.trim().parse());\n    Ok(2 * n)\n}\n\nThe only thing we did here was remove the calls to map_err. They are no longer needed because the try! macro invokes From::from on the error value. This works because we've provided From impls for all the error types that could appear.\n\nIf we modified our file_double function to perform some other operation, say, convert a string to a float, then we'd need to add a new variant to our error type:\n\n\nuse std::io;\nuse std::num;\n\nenum CliError {\n    Io(io::Error),\n    ParseInt(num::ParseIntError),\n    ParseFloat(num::ParseFloatError),\n}\n\nAnd add a new From impl:\n\n\n\nuse std::num;\n\nimpl From<num::ParseFloatError> for CliError {\n    fn from(err: num::ParseFloatError) -> CliError {\n        CliError::ParseFloat(err)\n    }\n}\n\nAnd that's it!\n\nAdvice for library writers\n\nIf your library needs to report custom errors, then you should probably define your own error type. It's up to you whether or not to expose its representation (like ErrorKind) or keep it hidden (like ParseIntError). Regardless of how you do it, it's usually good practice to at least provide some information about the error beyond its String representation. But certainly, this will vary depending on use cases.\n\nAt a minimum, you should probably implement the Error trait. This will give users of your library some minimum flexibility for composing errors. Implementing the Error trait also means that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both fmt::Debug and fmt::Display).\n\nBeyond that, it can also be useful to provide implementations of From on your error types. This allows you (the library author) and your users to compose more detailed errors. For example, csv::Error provides From impls for both io::Error and byteorder::Error.\n\nFinally, depending on your tastes, you may also want to define a Result type alias, particularly if your library defines a single error type. This is used in the standard library for io::Result and fmt::Result.\n\nCase study: A program to read population data\n\nThis section was long, and depending on your background, it might be rather dense. While there is plenty of example code to go along with the prose, most of it was specifically designed to be pedagogical. So, we're going to do something new: a case study.\n\nFor this, we're going to build up a command line program that lets you query world population data. The objective is simple: you give it a location and it will tell you the population. Despite the simplicity, there is a lot that can go wrong!\n\nThe data we'll be using comes from the Data Science Toolkit. I've prepared some data from it for this exercise. You can either grab the world population data (41MB gzip compressed, 145MB uncompressed) or only the US population data (2.2MB gzip compressed, 7.2MB uncompressed).\n\nUp until now, we've kept the code limited to Rust's standard library. For a real task like this though, we'll want to at least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically. For that, we'll use the csv, and rustc-serialize crates.\n\nInitial setup\n\nWe're not going to spend a lot of time on setting up a project with Cargo because it is already covered well in the Cargo section and Cargo's documentation.\n\nTo get started from scratch, run cargo new --bin city-pop and make sure your Cargo.toml looks something like this:\n\n[package]\nname = \"city-pop\"\nversion = \"0.1.0\"\nauthors = [\"Andrew Gallant <jamslam@gmail.com>\"]\n\n[[bin]]\nname = \"city-pop\"\n\n[dependencies]\ncsv = \"0.*\"\nrustc-serialize = \"0.*\"\ngetopts = \"0.*\"\n\n\nYou should already be able to run:\n\ncargo build --release\n./target/release/city-pop\n# Outputs: Hello, world!\n\nArgument parsing\n\nLet's get argument parsing out of the way. We won't go into too much detail on Getopts, but there is some good documentation describing it. The short story is that Getopts generates an argument parser and a help message from a vector of options (The fact that it is a vector is hidden behind a struct and a set of methods). Once the parsing is done, the parser returns a struct that records matches for defined options, and remaining \"free\" arguments. From there, we can get information about the flags, for instance, whether they were passed in, and what arguments they had. Here's our program with the appropriate extern crate statements, and the basic argument setup for Getopts:\n\nextern crate getopts;\nextern crate rustc_serialize;\n\nuse getopts::Options;\nuse std::env;\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let program = &args[0];\n\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m)  => { m }\n        Err(e) => { panic!(e.to_string()) }\n    };\n    if matches.opt_present(\"h\") {\n        print_usage(&program, opts);\n        return;\n    }\n    let data_path = &matches.free[0];\n    let city: &str = &matches.free[1];\n\n    // Do stuff with information.\n}\n\n\nFirst, we get a vector of the arguments passed into our program. We then store the first one, knowing that it is our program's name. Once that's done, we set up our argument flags, in this case a simplistic help message flag. Once we have the argument flags set up, we use Options.parse to parse the argument vector (starting from index one, because index 0 is the program name). If this was successful, we assign matches to the parsed object, if not, we panic. Once past that, we test if the user passed in the help flag, and if so print the usage message. The option help messages are constructed by Getopts, so all we have to do to print the usage message is tell it what we want it to print for the program name and template. If the user has not passed in the help flag, we assign the proper variables to their corresponding arguments.\n\nWriting the logic\n\nWe all write code differently, but error handling is usually the last thing we want to think about. This isn't great for the overall design of a program, but it can be useful for rapid prototyping. Because Rust forces us to be explicit about error handling (by making us call unwrap), it is easy to see which parts of our program can cause errors.\n\nIn this case study, the logic is really simple. All we need to do is parse the CSV data given to us and print out a field in matching rows. Let's do it. (Make sure to add extern crate csv; to the top of your file.)\n\nuse std::fs::File;\n\n// This struct represents the data in each row of the CSV file.\n// Type based decoding absolves us of a lot of the nitty-gritty error\n// handling, like parsing strings as integers or floats.\n#[derive(Debug, RustcDecodable)]\nstruct Row {\n    country: String,\n    city: String,\n    accent_city: String,\n    region: String,\n\n    // Not every row has data for the population, latitude or longitude!\n    // So we express them as `Option` types, which admits the possibility of\n    // absence. The CSV parser will fill in the correct value for us.\n    population: Option<u64>,\n    latitude: Option<f64>,\n    longitude: Option<f64>,\n}\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let program = &args[0];\n\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m)  => { m }\n        Err(e) => { panic!(e.to_string()) }\n    };\n\n    if matches.opt_present(\"h\") {\n        print_usage(&program, opts);\n        return;\n    }\n\n    let data_path = &matches.free[0];\n    let city: &str = &matches.free[1];\n\n    let file = File::open(data_path).unwrap();\n    let mut rdr = csv::Reader::from_reader(file);\n\n    for row in rdr.decode::<Row>() {\n        let row = row.unwrap();\n\n        if row.city == city {\n            println!(\"{}, {}: {:?}\",\n                row.city, row.country,\n                row.population.expect(\"population count\"));\n        }\n    }\n}\n\n\nLet's outline the errors. We can start with the obvious: the three places that unwrap is called:\n\nFile::open can return an io::Error.\ncsv::Reader::decode decodes one record at a time, and decoding a record (look at the Item associated type on the Iterator impl) can produce a csv::Error.\nIf row.population is None, then calling expect will panic.\n\nAre there any others? What if we can't find a matching city? Tools like grep will return an error code, so we probably should too. So we have logic errors specific to our problem, IO errors and CSV parsing errors. We're going to explore two different ways to approach handling these errors.\n\nI'd like to start with Box<Error>. Later, we'll see how defining our own error type can be useful.\n\nError handling with Box<Error>\n\nBox<Error> is nice because it just works. You don't need to define your own error types and you don't need any From implementations. The downside is that since Box<Error> is a trait object, it erases the type, which means the compiler can no longer reason about its underlying type.\n\nPreviously we started refactoring our code by changing the type of our function from T to Result<T, OurErrorType>. In this case, OurErrorType is only Box<Error>. But what's T? And can we add a return type to main?\n\nThe answer to the second question is no, we can't. That means we'll need to write a new function. But what is T? The simplest thing we can do is to return a list of matching Row values as a Vec<Row>. (Better code would return an iterator, but that is left as an exercise to the reader.)\n\nLet's refactor our code into its own function, but keep the calls to unwrap. Note that we opt to handle the possibility of a missing population count by simply ignoring that row.\n\nuse std::path::Path;\n\nstruct Row {\n    // This struct remains unchanged.\n}\n\nstruct PopulationCount {\n    city: String,\n    country: String,\n    // This is no longer an `Option` because values of this type are only\n    // constructed if they have a population count.\n    count: u64,\n}\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n}\n\nfn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {\n    let mut found = vec![];\n    let file = File::open(file_path).unwrap();\n    let mut rdr = csv::Reader::from_reader(file);\n    for row in rdr.decode::<Row>() {\n        let row = row.unwrap();\n        match row.population {\n            None => { } // Skip it.\n            Some(count) => if row.city == city {\n                found.push(PopulationCount {\n                    city: row.city,\n                    country: row.country,\n                    count: count,\n                });\n            },\n        }\n    }\n    found\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let program = &args[0];\n\n    let mut opts = Options::new();\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m)  => { m }\n        Err(e) => { panic!(e.to_string()) }\n    };\n\n    if matches.opt_present(\"h\") {\n        print_usage(&program, opts);\n        return;\n    }\n\n    let data_path = &matches.free[0];\n    let city: &str = &matches.free[1];\n\n    for pop in search(data_path, city) {\n        println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n    }\n}\n\n\n\nWhile we got rid of one use of expect (which is a nicer variant of unwrap), we still should handle the absence of any search results.\n\nTo convert this to proper error handling, we need to do the following:\n\nChange the return type of search to be Result<Vec<PopulationCount>, Box<Error>>.\nUse the try! macro so that errors are returned to the caller instead of panicking the program.\nHandle the error in main.\n\nLet's try it:\n\nuse std::error::Error;\n\n// The rest of the code before this is unchanged.\n\nfn search<P: AsRef<Path>>\n         (file_path: P, city: &str)\n         -> Result<Vec<PopulationCount>, Box<Error>> {\n    let mut found = vec![];\n    let file = try!(File::open(file_path));\n    let mut rdr = csv::Reader::from_reader(file);\n    for row in rdr.decode::<Row>() {\n        let row = try!(row);\n        match row.population {\n            None => { } // Skip it.\n            Some(count) => if row.city == city {\n                found.push(PopulationCount {\n                    city: row.city,\n                    country: row.country,\n                    count: count,\n                });\n            },\n        }\n    }\n    if found.is_empty() {\n        Err(From::from(\"No matching cities with a population were found.\"))\n    } else {\n        Ok(found)\n    }\n}\n\n\nInstead of x.unwrap(), we now have try!(x). Since our function returns a Result<T, E>, the try! macro will return early from the function if an error occurs.\n\nAt the end of search we also convert a plain string to an error type by using the corresponding From impls:\n\n// We are making use of this impl in the code above, since we call `From::from`\n// on a `&'static str`.\nimpl<'a> From<&'a str> for Box<Error>\n\n// But this is also useful when you need to allocate a new string for an\n// error message, usually with `format!`.\nimpl From<String> for Box<Error>\n\n\nSince search now returns a Result<T, E>, main should use case analysis when calling search:\n\n...\n    match search(data_path, city) {\n        Ok(pops) => {\n            for pop in pops {\n                println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n            }\n        }\n        Err(err) => println!(\"{}\", err)\n    }\n...\n\n\nNow that we've seen how to do proper error handling with Box<Error>, let's try a different approach with our own custom error type. But first, let's take a quick break from error handling and add support for reading from stdin.\n\nReading from stdin\n\nIn our program, we accept a single file for input and do one pass over the data. This means we probably should be able to accept input on stdin. But maybe we like the current format too‚Äîso let's have both!\n\nAdding support for stdin is actually quite easy. There are only three things we have to do:\n\nTweak the program arguments so that a single parameter‚Äîthe city‚Äîcan be accepted while the population data is read from stdin.\nModify the program so that an option -f can take the file, if it is not passed into stdin.\nModify the search function to take an optional file path. When None, it should know to read from stdin.\n\nFirst, here's the new usage:\n\nfn print_usage(program: &str, opts: Options) {\n    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <city>\", program)));\n}\n\n\nOf course we need to adapt the argument handling code:\n\n...\n    let mut opts = Options::new();\n    opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n    ...\n    let data_path = matches.opt_str(\"f\");\n\n    let city = if !matches.free.is_empty() {\n        &matches.free[0]\n    } else {\n        print_usage(&program, opts);\n        return;\n    };\n\n    match search(&data_path, city) {\n        Ok(pops) => {\n            for pop in pops {\n                println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n            }\n        }\n        Err(err) => println!(\"{}\", err)\n    }\n...\n\n\nWe've made the user experience a bit nicer by showing the usage message, instead of a panic from an out-of-bounds index, when city, the remaining free argument, is not present.\n\nModifying search is slightly trickier. The csv crate can build a parser out of any type that implements io::Read. But how can we use the same code over both types? There's actually a couple ways we could go about this. One way is to write search such that it is generic on some type parameter R that satisfies io::Read. Another way is to use trait objects:\n\nuse std::io;\n\n// The rest of the code before this is unchanged.\n\nfn search<P: AsRef<Path>>\n         (file_path: &Option<P>, city: &str)\n         -> Result<Vec<PopulationCount>, Box<Error>> {\n    let mut found = vec![];\n    let input: Box<io::Read> = match *file_path {\n        None => Box::new(io::stdin()),\n        Some(ref file_path) => Box::new(try!(File::open(file_path))),\n    };\n    let mut rdr = csv::Reader::from_reader(input);\n    // The rest remains unchanged!\n}\n\nError handling with a custom type\n\nPreviously, we learned how to compose errors using a custom error type. We did this by defining our error type as an enum and implementing Error and From.\n\nSince we have three distinct errors (IO, CSV parsing and not found), let's define an enum with three variants:\n\n#[derive(Debug)]\nenum CliError {\n    Io(io::Error),\n    Csv(csv::Error),\n    NotFound,\n}\n\n\nAnd now for impls on Display and Error:\n\nuse std::fmt;\n\nimpl fmt::Display for CliError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            CliError::Io(ref err) => err.fmt(f),\n            CliError::Csv(ref err) => err.fmt(f),\n            CliError::NotFound => write!(f, \"No matching cities with a \\\n                                             population were found.\"),\n        }\n    }\n}\n\nimpl Error for CliError {\n    fn description(&self) -> &str {\n        match *self {\n            CliError::Io(ref err) => err.description(),\n            CliError::Csv(ref err) => err.description(),\n            CliError::NotFound => \"not found\",\n        }\n    }\n\n    fn cause(&self) -> Option<&Error> {\n        match *self {\n            CliError::Io(ref err) => Some(err),\n            CliError::Csv(ref err) => Some(err),\n            // Our custom error doesn't have an underlying cause,\n            // but we could modify it so that it does.\n            CliError::NotFound => None,\n        }\n    }\n}\n\n\nBefore we can use our CliError type in our search function, we need to provide a couple From impls. How do we know which impls to provide? Well, we'll need to convert from both io::Error and csv::Error to CliError. Those are the only external errors, so we'll only need two From impls for now:\n\nimpl From<io::Error> for CliError {\n    fn from(err: io::Error) -> CliError {\n        CliError::Io(err)\n    }\n}\n\nimpl From<csv::Error> for CliError {\n    fn from(err: csv::Error) -> CliError {\n        CliError::Csv(err)\n    }\n}\n\n\nThe From impls are important because of how try! is defined. In particular, if an error occurs, From::from is called on the error, which in this case, will convert it to our own error type CliError.\n\nWith the From impls done, we only need to make two small tweaks to our search function: the return type and the ‚Äúnot found‚Äù error. Here it is in full:\n\nfn search<P: AsRef<Path>>\n         (file_path: &Option<P>, city: &str)\n         -> Result<Vec<PopulationCount>, CliError> {\n    let mut found = vec![];\n    let input: Box<io::Read> = match *file_path {\n        None => Box::new(io::stdin()),\n        Some(ref file_path) => Box::new(try!(File::open(file_path))),\n    };\n    let mut rdr = csv::Reader::from_reader(input);\n    for row in rdr.decode::<Row>() {\n        let row = try!(row);\n        match row.population {\n            None => { } // Skip it.\n            Some(count) => if row.city == city {\n                found.push(PopulationCount {\n                    city: row.city,\n                    country: row.country,\n                    count: count,\n                });\n            },\n        }\n    }\n    if found.is_empty() {\n        Err(CliError::NotFound)\n    } else {\n        Ok(found)\n    }\n}\n\n\nNo other changes are necessary.\n\nAdding functionality\n\nWriting generic code is great, because generalizing stuff is cool, and it can then be useful later. But sometimes, the juice isn't worth the squeeze. Look at what we just did in the previous step:\n\nDefined a new error type.\nAdded impls for Error, Display and two for From.\n\nThe big downside here is that our program didn't improve a whole lot. There is quite a bit of overhead to representing errors with enums, especially in short programs like this.\n\nOne useful aspect of using a custom error type like we've done here is that the main function can now choose to handle errors differently. Previously, with Box<Error>, it didn't have much of a choice: just print the message. We're still doing that here, but what if we wanted to, say, add a --quiet flag? The --quiet flag should silence any verbose output.\n\nRight now, if the program doesn't find a match, it will output a message saying so. This can be a little clumsy, especially if you intend for the program to be used in shell scripts.\n\nSo let's start by adding the flags. Like before, we need to tweak the usage string and add a flag to the Option variable. Once we've done that, Getopts does the rest:\n\n...\n    let mut opts = Options::new();\n    opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n    opts.optflag(\"q\", \"quiet\", \"Silences errors and warnings.\");\n...\n\n\nNow we only need to implement our ‚Äúquiet‚Äù functionality. This requires us to tweak the case analysis in main:\n\nuse std::process;\n...\n    match search(&data_path, city) {\n        Err(CliError::NotFound) if matches.opt_present(\"q\") => process::exit(1),\n        Err(err) => panic!(\"{}\", err),\n        Ok(pops) => for pop in pops {\n            println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n        }\n    }\n...\n\n\nCertainly, we don't want to be quiet if there was an IO error or if the data failed to parse. Therefore, we use case analysis to check if the error type is NotFound and if --quiet has been enabled. If the search failed, we still quit with an exit code (following grep's convention).\n\nIf we had stuck with Box<Error>, then it would be pretty tricky to implement the --quiet functionality.\n\nThis pretty much sums up our case study. From here, you should be ready to go out into the world and write your own programs and libraries with proper error handling.\n\nThe Short Story\n\nSince this section is long, it is useful to have a quick summary for error handling in Rust. These are some good ‚Äúrules of thumb.\" They are emphatically not commandments. There are probably good reasons to break every one of these heuristics!\n\nIf you're writing short example code that would be overburdened by error handling, it's probably fine to use unwrap (whether that's Result::unwrap, Option::unwrap or preferably Option::expect). Consumers of your code should know to use proper error handling. (If they don't, send them here!)\nIf you're writing a quick 'n' dirty program, don't feel ashamed if you use unwrap. Be warned: if it winds up in someone else's hands, don't be surprised if they are agitated by poor error messages!\nIf you're writing a quick 'n' dirty program and feel ashamed about panicking anyway, then use either a String or a Box<Error> for your error type.\nOtherwise, in a program, define your own error types with appropriate From and Error impls to make the try! macro more ergonomic.\nIf you're writing a library and your code can produce errors, define your own error type and implement the std::error::Error trait. Where appropriate, implement From to make both your library code and the caller's code easier to write. (Because of Rust's coherence rules, callers will not be able to impl From on your error type, so your library should do it.)\nLearn the combinators defined on Option and Result. Using them exclusively can be a bit tiring at times, but I've personally found a healthy mix of try! and combinators to be quite appealing. and_then, map and unwrap_or are my favorites."
  },
  {
    "title": "FFI - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/ffi.html",
    "html": "Foreign Function Interface\nIntroduction\n\nThis guide will use the snappy compression/decompression library as an introduction to writing bindings for foreign code. Rust is currently unable to call directly into a C++ library, but snappy includes a C interface (documented in snappy-c.h).\n\nA note about libc\n\nMany of these examples use the libc crate, which provides various type definitions for C types, among other things. If you‚Äôre trying these examples yourself, you‚Äôll need to add libc to your Cargo.toml:\n\n[dependencies]\nlibc = \"0.2.0\"\n\n\nand add extern crate libc; to your crate root.\n\nCalling foreign functions\n\nThe following is a minimal example of calling a foreign function which will compile if snappy is installed:\n\nextern crate libc;\nuse libc::size_t;\n\n#[link(name = \"snappy\")]\nextern {\n    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n}\n\nfn main() {\n    let x = unsafe { snappy_max_compressed_length(100) };\n    println!(\"max compressed length of a 100 byte buffer: {}\", x);\n}\n\n\nThe extern block is a list of function signatures in a foreign library, in this case with the platform's C ABI. The #[link(...)] attribute is used to instruct the linker to link against the snappy library so the symbols are resolved.\n\nForeign functions are assumed to be unsafe so calls to them need to be wrapped with unsafe {} as a promise to the compiler that everything contained within truly is safe. C libraries often expose interfaces that aren't thread-safe, and almost any function that takes a pointer argument isn't valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of Rust's safe memory model.\n\nWhen declaring the argument types to a foreign function, the Rust compiler cannot check if the declaration is correct, so specifying it correctly is part of keeping the binding correct at runtime.\n\nThe extern block can be extended to cover the entire snappy API:\n\nextern crate libc;\nuse libc::{c_int, size_t};\n\n#[link(name = \"snappy\")]\nextern {\n    fn snappy_compress(input: *const u8,\n                       input_length: size_t,\n                       compressed: *mut u8,\n                       compressed_length: *mut size_t) -> c_int;\n    fn snappy_uncompress(compressed: *const u8,\n                         compressed_length: size_t,\n                         uncompressed: *mut u8,\n                         uncompressed_length: *mut size_t) -> c_int;\n    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n    fn snappy_uncompressed_length(compressed: *const u8,\n                                  compressed_length: size_t,\n                                  result: *mut size_t) -> c_int;\n    fn snappy_validate_compressed_buffer(compressed: *const u8,\n                                         compressed_length: size_t) -> c_int;\n}\n\nCreating a safe interface\n\nThe raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe internal details.\n\nWrapping the functions which expect buffers involves using the slice::raw module to manipulate Rust vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The length is the number of elements currently contained, and the capacity is the total size in elements of the allocated memory. The length is less than or equal to the capacity.\n\npub fn validate_compressed_buffer(src: &[u8]) -> bool {\n    unsafe {\n        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n    }\n}\n\n\nThe validate_compressed_buffer wrapper above makes use of an unsafe block, but it makes the guarantee that calling it is safe for all inputs by leaving off unsafe from the function signature.\n\nThe snappy_compress and snappy_uncompress functions are more complex, since a buffer has to be allocated to hold the output too.\n\nThe snappy_max_compressed_length function can be used to allocate a vector with the maximum required capacity to hold the compressed output. The vector can then be passed to the snappy_compress function as an output parameter. An output parameter is also passed to retrieve the true length after compression for setting the length.\n\npub fn compress(src: &[u8]) -> Vec<u8> {\n    unsafe {\n        let srclen = src.len() as size_t;\n        let psrc = src.as_ptr();\n\n        let mut dstlen = snappy_max_compressed_length(srclen);\n        let mut dst = Vec::with_capacity(dstlen as usize);\n        let pdst = dst.as_mut_ptr();\n\n        snappy_compress(psrc, srclen, pdst, &mut dstlen);\n        dst.set_len(dstlen as usize);\n        dst\n    }\n}\n\n\nDecompression is similar, because snappy stores the uncompressed size as part of the compression format and snappy_uncompressed_length will retrieve the exact buffer size required.\n\npub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n    unsafe {\n        let srclen = src.len() as size_t;\n        let psrc = src.as_ptr();\n\n        let mut dstlen: size_t = 0;\n        snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n\n        let mut dst = Vec::with_capacity(dstlen as usize);\n        let pdst = dst.as_mut_ptr();\n\n        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n            dst.set_len(dstlen as usize);\n            Some(dst)\n        } else {\n            None // SNAPPY_INVALID_INPUT\n        }\n    }\n}\n\n\nThen, we can add some tests to show how to use them.\n\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn valid() {\n        let d = vec![0xde, 0xad, 0xd0, 0x0d];\n        let c: &[u8] = &compress(&d);\n        assert!(validate_compressed_buffer(c));\n        assert!(uncompress(c) == Some(d));\n    }\n\n    #[test]\n    fn invalid() {\n        let d = vec![0, 0, 0, 0];\n        assert!(!validate_compressed_buffer(&d));\n        assert!(uncompress(&d).is_none());\n    }\n\n    #[test]\n    fn empty() {\n        let d = vec![];\n        assert!(!validate_compressed_buffer(&d));\n        assert!(uncompress(&d).is_none());\n        let c = compress(&d);\n        assert!(validate_compressed_buffer(&c));\n        assert!(uncompress(&c) == Some(d));\n    }\n}\n\nDestructors\n\nForeign libraries often hand off ownership of resources to the calling code. When this occurs, we must use Rust's destructors to provide safety and guarantee the release of these resources (especially in the case of panic).\n\nFor more about destructors, see the Drop trait.\n\nCallbacks from C code to Rust functions\n\nSome external libraries require the usage of callbacks to report back their current state or intermediate data to the caller. It is possible to pass functions defined in Rust to an external library. The requirement for this is that the callback function is marked as extern with the correct calling convention to make it callable from C code.\n\nThe callback function can then be sent through a registration call to the C library and afterwards be invoked from there.\n\nA basic example is:\n\nRust code:\n\nextern fn callback(a: i32) {\n    println!(\"I'm called from C with value {0}\", a);\n}\n\n#[link(name = \"extlib\")]\nextern {\n   fn register_callback(cb: extern fn(i32)) -> i32;\n   fn trigger_callback();\n}\n\nfn main() {\n    unsafe {\n        register_callback(callback);\n        trigger_callback(); // Triggers the callback.\n    }\n}\n\n\nC code:\n\ntypedef void (*rust_callback)(int32_t);\nrust_callback cb;\n\nint32_t register_callback(rust_callback callback) {\n    cb = callback;\n    return 1;\n}\n\nvoid trigger_callback() {\n  cb(7); // Will call callback(7) in Rust.\n}\n\n\nIn this example Rust's main() will call trigger_callback() in C, which would, in turn, call back to callback() in Rust.\n\nTargeting callbacks to Rust objects\n\nThe former example showed how a global function can be called from C code. However it is often desired that the callback is targeted to a special Rust object. This could be the object that represents the wrapper for the respective C object.\n\nThis can be achieved by passing a raw pointer to the object down to the C library. The C library can then include the pointer to the Rust object in the notification. This will allow the callback to unsafely access the referenced Rust object.\n\nRust code:\n\n#[repr(C)]\nstruct RustObject {\n    a: i32,\n    // Other members...\n}\n\nextern \"C\" fn callback(target: *mut RustObject, a: i32) {\n    println!(\"I'm called from C with value {0}\", a);\n    unsafe {\n        // Update the value in RustObject with the value received from the callback:\n        (*target).a = a;\n    }\n}\n\n#[link(name = \"extlib\")]\nextern {\n   fn register_callback(target: *mut RustObject,\n                        cb: extern fn(*mut RustObject, i32)) -> i32;\n   fn trigger_callback();\n}\n\nfn main() {\n    // Create the object that will be referenced in the callback:\n    let mut rust_object = Box::new(RustObject { a: 5 });\n\n    unsafe {\n        register_callback(&mut *rust_object, callback);\n        trigger_callback();\n    }\n}\n\n\nC code:\n\ntypedef void (*rust_callback)(void*, int32_t);\nvoid* cb_target;\nrust_callback cb;\n\nint32_t register_callback(void* callback_target, rust_callback callback) {\n    cb_target = callback_target;\n    cb = callback;\n    return 1;\n}\n\nvoid trigger_callback() {\n  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust.\n}\n\nAsynchronous callbacks\n\nIn the previously given examples the callbacks are invoked as a direct reaction to a function call to the external C library. The control over the current thread is switched from Rust to C to Rust for the execution of the callback, but in the end the callback is executed on the same thread that called the function which triggered the callback.\n\nThings get more complicated when the external library spawns its own threads and invokes callbacks from there. In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to use channels (in std::sync::mpsc) to forward data from the C thread that invoked the callback into a Rust thread.\n\nIf an asynchronous callback targets a special object in the Rust address space it is also absolutely necessary that no more callbacks are performed by the C library after the respective Rust object gets destroyed. This can be achieved by unregistering the callback in the object's destructor and designing the library in a way that guarantees that no callback will be performed after deregistration.\n\nLinking\n\nThe link attribute on extern blocks provides the basic building block for instructing rustc how it will link to native libraries. There are two accepted forms of the link attribute today:\n\n#[link(name = \"foo\")]\n#[link(name = \"foo\", kind = \"bar\")]\n\nIn both of these cases, foo is the name of the native library that we're linking to, and in the second case bar is the type of native library that the compiler is linking to. There are currently three known types of native libraries:\n\nDynamic - #[link(name = \"readline\")]\nStatic - #[link(name = \"my_build_dependency\", kind = \"static\")]\nFrameworks - #[link(name = \"CoreFoundation\", kind = \"framework\")]\n\nNote that frameworks are only available on macOS targets.\n\nThe different kind values are meant to differentiate how the native library participates in linkage. From a linkage perspective, the Rust compiler creates two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary). Native dynamic library and framework dependencies are propagated to the final artifact boundary, while static library dependencies are not propagated at all, because the static libraries are integrated directly into the subsequent artifact.\n\nA few examples of how this model can be used are:\n\nA native build dependency. Sometimes some C/C++ glue is needed when writing some Rust code, but distribution of the C/C++ code in a library format is a burden. In this case, the code will be archived into libfoo.a and then the Rust crate would declare a dependency via #[link(name = \"foo\", kind = \"static\")].\n\nRegardless of the flavor of output for the crate, the native static library will be included in the output, meaning that distribution of the native static library is not necessary.\n\nA normal dynamic dependency. Common system libraries (like readline) are available on a large number of systems, and often a static copy of these libraries cannot be found. When this dependency is included in a Rust crate, partial targets (like rlibs) will not link to the library, but when the rlib is included in a final target (like a binary), the native library will be linked in.\n\nOn macOS, frameworks behave with the same semantics as a dynamic library.\n\nUnsafe blocks\n\nSome operations, like dereferencing raw pointers or calling functions that have been marked unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to the compiler that the unsafety does not leak out of the block.\n\nUnsafe functions, on the other hand, advertise it to the world. An unsafe function is written like this:\n\n\nunsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n\nThis function can only be called from an unsafe block or another unsafe function.\n\nAccessing foreign globals\n\nForeign APIs often export a global variable which could do something like track global state. In order to access these variables, you declare them in extern blocks with the static keyword:\n\nextern crate libc;\n\n#[link(name = \"readline\")]\nextern {\n    static rl_readline_version: libc::c_int;\n}\n\nfn main() {\n    println!(\"You have readline version {} installed.\",\n             unsafe { rl_readline_version as i32 });\n}\n\n\nAlternatively, you may need to alter global state provided by a foreign interface. To do this, statics can be declared with mut so we can mutate them.\n\nextern crate libc;\n\nuse std::ffi::CString;\nuse std::ptr;\n\n#[link(name = \"readline\")]\nextern {\n    static mut rl_prompt: *const libc::c_char;\n}\n\nfn main() {\n    let prompt = CString::new(\"[my-awesome-shell] $\").unwrap();\n    unsafe {\n        rl_prompt = prompt.as_ptr();\n\n        println!(\"{:?}\", rl_prompt);\n\n        rl_prompt = ptr::null();\n    }\n}\n\n\nNote that all interaction with a static mut is unsafe, both reading and writing. Dealing with global mutable state requires a great deal of care.\n\nForeign calling conventions\n\nMost foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when calling foreign functions. Some foreign functions, most notably the Windows API, use other calling conventions. Rust provides a way to tell the compiler which convention to use:\n\nextern crate libc;\n\n#[cfg(all(target_os = \"win32\", target_arch = \"x86\"))]\n#[link(name = \"kernel32\")]\n#[allow(non_snake_case)]\nextern \"stdcall\" {\n    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n}\n\n\nThis applies to the entire extern block. The list of supported ABI constraints are:\n\nstdcall\naapcs\ncdecl\nfastcall\nvectorcall This is currently hidden behind the abi_vectorcall gate and is subject to change.\nRust\nrust-intrinsic\nsystem\nC\nwin64\nsysv64\n\nMost of the ABIs in this list are self-explanatory, but the system ABI may seem a little odd. This constraint selects whatever the appropriate ABI is for interoperating with the target's libraries. For example, on win32 with a x86 architecture, this means that the ABI used would be stdcall. On x86_64, however, windows uses the C calling convention, so C would be used. This means that in our previous example, we could have used extern \"system\" { ... } to define a block for all windows systems, not only x86 ones.\n\nInteroperability with foreign code\n\nRust guarantees that the layout of a struct is compatible with the platform's representation in C only if the #[repr(C)] attribute is applied to it. #[repr(C, packed)] can be used to lay out struct members without padding. #[repr(C)] can also be applied to an enum.\n\nRust's owned boxes (Box<T>) use non-nullable pointers as handles which point to the contained object. However, they should not be manually created because they are managed by internal allocators. References can safely be assumed to be non-nullable pointers directly to the type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw pointers (*) if that's needed because the compiler can't make as many assumptions about them.\n\nVectors and strings share the same basic memory layout, and utilities are available in the vec and str modules for working with C APIs. However, strings are not terminated with \\0. If you need a NUL-terminated string for interoperability with C, you should use the CString type in the std::ffi module.\n\nThe libc crate on crates.io includes type aliases and function definitions for the C standard library in the libc module, and Rust links against libc and libm by default.\n\nVariadic functions\n\nIn C, functions can be 'variadic', meaning they accept a variable number of arguments. This can be achieved in Rust by specifying ... within the argument list of a foreign function declaration:\n\nextern {\n    fn foo(x: i32, ...);\n}\n\nfn main() {\n    unsafe {\n        foo(10, 20, 30, 40, 50);\n    }\n}\n\n\nNormal Rust functions can not be variadic:\n\n// This will not compile\n\nfn foo(x: i32, ...) { }\n\nThe \"nullable pointer optimization\"\n\nCertain Rust types are defined to never be null. This includes references (&T, &mut T), boxes (Box<T>), and function pointers (extern \"abi\" fn()). When interfacing with C, pointers that might be null are often used, which would seem to require some messy transmutes and/or unsafe code to handle conversions to/from Rust types. However, the language provides a workaround.\n\nAs a special case, an enum is eligible for the \"nullable pointer optimization\" if it contains exactly two variants, one of which contains no data and the other contains a field of one of the non-nullable types listed above. This means no extra space is required for a discriminant; rather, the empty variant is represented by putting a null value into the non-nullable field. This is called an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible types.\n\nThe most common type that takes advantage of the nullable pointer optimization is Option<T>, where None corresponds to null. So Option<extern \"C\" fn(c_int) -> c_int> is a correct way to represent a nullable function pointer using the C ABI (corresponding to the C type int (*)(int)).\n\nHere is a contrived example. Let's say some C library has a facility for registering a callback, which gets called in certain situations. The callback is passed a function pointer and an integer and it is supposed to run the function with the integer as a parameter. So we have function pointers flying across the FFI boundary in both directions.\n\nextern crate libc;\nuse libc::c_int;\n\nextern \"C\" {\n    /// Registers the callback.\n    fn register(cb: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>, c_int) -> c_int>);\n}\n\n/// This fairly useless function receives a function pointer and an integer\n/// from C, and returns the result of calling the function with the integer.\n/// In case no function is provided, it squares the integer by default.\nextern \"C\" fn apply(process: Option<extern \"C\" fn(c_int) -> c_int>, int: c_int) -> c_int {\n    match process {\n        Some(f) => f(int),\n        None    => int * int\n    }\n}\n\nfn main() {\n    unsafe {\n        register(Some(apply));\n    }\n}\n\n\nAnd the code on the C side looks like this:\n\nvoid register(void (*f)(void (*)(int), int)) {\n    ...\n}\n\n\nNo transmute required!\n\nCalling Rust code from C\n\nYou may wish to compile Rust code in a way so that it can be called from C. This is fairly easy, but requires a few things:\n\n#[no_mangle]\npub extern fn hello_rust() -> *const u8 {\n    \"Hello, world!\\0\".as_ptr()\n}\n\n\nThe extern makes this function adhere to the C calling convention, as discussed above in \"Foreign Calling Conventions\". The no_mangle attribute turns off Rust's name mangling, so that it is easier to link to.\n\nFFI and panics\n\nIt‚Äôs important to be mindful of panic!s when working with FFI. A panic! across an FFI boundary is undefined behavior. If you‚Äôre writing code that may panic, you should run it in a closure with catch_unwind:\n\nuse std::panic::catch_unwind;\n\n#[no_mangle]\npub extern fn oh_no() -> i32 {\n    let result = catch_unwind(|| {\n        panic!(\"Oops!\");\n    });\n    match result {\n        Ok(_) => 0,\n        Err(_) => 1,\n    }\n}\n\nfn main() {}\n\n\nPlease note that catch_unwind will only catch unwinding panics, not those who abort the process. See the documentation of catch_unwind for more information.\n\nRepresenting opaque structs\n\nSometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants. The simplest way is to use a void * argument:\n\nvoid foo(void *arg);\nvoid bar(void *arg);\n\n\nWe can represent this in Rust with the c_void type:\n\nextern crate libc;\n\nextern \"C\" {\n    pub fn foo(arg: *mut libc::c_void);\n    pub fn bar(arg: *mut libc::c_void);\n}\n\n\nThis is a perfectly valid way of handling the situation. However, we can do a bit better. To solve this, some C libraries will instead create a struct, where the details and memory layout of the struct are private. This gives some amount of type safety. These structures are called ‚Äòopaque‚Äô. Here‚Äôs an example, in C:\n\nstruct Foo; /* Foo is a structure, but its contents are not part of the public interface */\nstruct Bar;\nvoid foo(struct Foo *arg);\nvoid bar(struct Bar *arg);\n\n\nTo do this in Rust, let‚Äôs create our own opaque types:\n\n#[repr(C)] pub struct Foo { private: [u8; 0] }\n#[repr(C)] pub struct Bar { private: [u8; 0] }\n\nextern \"C\" {\n    pub fn foo(arg: *mut Foo);\n    pub fn bar(arg: *mut Bar);\n}\n\n\nBy including a private field and no constructor, we create an opaque type that we can‚Äôt instantiate outside of this module. An empty array is both zero-size and compatible with #[repr(C)]. But because our Foo and Bar types are different, we‚Äôll get type safety between the two of them, so we cannot accidentally pass a pointer to Foo to bar()."
  },
  {
    "title": "Choosing your Guarantees - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/choosing-your-guarantees.html",
    "html": "Choosing your Guarantees\n\nOne important feature of Rust is that it lets us control the costs and guarantees of a program.\n\nThere are various ‚Äúwrapper type‚Äù abstractions in the Rust standard library which embody a multitude of trade-offs between cost, ergonomics, and guarantees. Many let one choose between run-time and compile-time enforcement. This section will explain a few selected abstractions in detail.\n\nBefore proceeding, it is highly recommended that one reads about ownership and borrowing in Rust.\n\nBasic pointer types\nBox<T>\n\nBox<T> is an ‚Äúowned‚Äù pointer, or a ‚Äúbox‚Äù. While it can hand out references to the contained data, it is the only owner of the data. In particular, consider the following:\n\n\nlet x = Box::new(1);\nlet y = x;\n// `x` is no longer accessible here.\n\nHere, the box was moved into y. As x no longer owns it, the compiler will no longer allow the programmer to use x after this. A box can similarly be moved out of a function by returning it.\n\nWhen a box (that hasn't been moved) goes out of scope, destructors are run. These destructors take care of deallocating the inner data.\n\nThis is a zero-cost abstraction for dynamic allocation. If you want to allocate some memory on the heap and safely pass around a pointer to that memory, this is ideal. Note that you will only be allowed to share references to this by the regular borrowing rules, checked at compile time.\n\n&T and &mut T\n\nThese are immutable and mutable references respectively. They follow the ‚Äúread-write lock‚Äù pattern, such that one may either have only one mutable reference to some data, or any number of immutable ones, but not both. This guarantee is enforced at compile time, and has no visible cost at runtime. In most cases these two pointer types suffice for sharing cheap references between sections of code.\n\nThese pointers cannot be copied in such a way that they outlive the lifetime associated with them.\n\n*const T and *mut T\n\nThese are C-like raw pointers with no lifetime or ownership attached to them. They point to some location in memory with no other restrictions. The only guarantee that these provide is that they cannot be dereferenced except in code marked unsafe.\n\nThese are useful when building safe, low cost abstractions like Vec<T>, but should be avoided in safe code.\n\nRc<T>\n\nThis is the first wrapper we will cover that has a runtime cost.\n\nRc<T> is a reference counted pointer. In other words, this lets us have multiple \"owning\" pointers to the same data, and the data will be dropped (destructors will be run) when all pointers are out of scope.\n\nInternally, it contains a shared ‚Äúreference count‚Äù (also called ‚Äúrefcount‚Äù), which is incremented each time the Rc is cloned, and decremented each time one of the Rcs goes out of scope. The main responsibility of Rc<T> is to ensure that destructors are called for shared data.\n\nThe internal data here is immutable, and if a cycle of references is created, the data will be leaked. If we want data that doesn't leak when there are cycles, we need a garbage collector.\n\nGuarantees\n\nThe main guarantee provided here is that the data will not be destroyed until all references to it are out of scope.\n\nThis should be used when we wish to dynamically allocate and share some data (read-only) between various portions of your program, where it is not certain which portion will finish using the pointer last. It's a viable alternative to &T when &T is either impossible to statically check for correctness, or creates extremely unergonomic code where the programmer does not wish to spend the development cost of working with.\n\nThis pointer is not thread-safe, and Rust will not let it be sent or shared with other threads. This lets one avoid the cost of atomics in situations where they are unnecessary.\n\nThere is a sister smart pointer to this one, Weak<T>. This is a non-owning, but also non-borrowed, smart pointer. It is also similar to &T, but it is not restricted in lifetime‚Äîa Weak<T> can be held on to forever. However, it is possible that an attempt to access the inner data may fail and return None, since this can outlive the owned Rcs. This is useful for cyclic data structures and other things.\n\nCost\n\nAs far as memory goes, Rc<T> is a single allocation, though it will allocate two extra words (i.e. two usize values) as compared to a regular Box<T> (for \"strong\" and \"weak\" refcounts).\n\nRc<T> has the computational cost of incrementing/decrementing the refcount whenever it is cloned or goes out of scope respectively. Note that a clone will not do a deep copy, rather it will simply increment the inner reference count and return a copy of the Rc<T>.\n\nCell types\n\nCells provide interior mutability. In other words, they contain data which can be manipulated even if the type cannot be obtained in a mutable form (for example, when it is behind an &-ptr or Rc<T>).\n\nThe documentation for the cell module has a pretty good explanation for these.\n\nThese types are generally found in struct fields, but they may be found elsewhere too.\n\nCell<T>\n\nCell<T> is a type that provides zero-cost interior mutability by moving data in and out of the cell. Since the compiler knows that all the data owned by the contained value is on the stack, there's no worry of leaking any data behind references (or worse!) by simply replacing the data.\n\nIt is still possible to violate your own invariants using this wrapper, so be careful when using it. If a field is wrapped in Cell, it's a nice indicator that the chunk of data is mutable and may not stay the same between the time you first read it and when you intend to use it.\n\n\nuse std::cell::Cell;\n\nlet x = Cell::new(1);\nlet y = &x;\nlet z = &x;\nx.set(2);\ny.set(3);\nz.set(4);\nprintln!(\"{}\", x.get());\n\nNote that here we were able to mutate the same value from various immutable references.\n\nThis has the same runtime cost as the following:\n\nlet mut x = 1;\nlet y = &mut x;\nlet z = &mut x;\nx = 2;\n*y = 3;\n*z = 4;\nprintln!(\"{}\", x);\n\n\nbut it has the added benefit of actually compiling successfully.\n\nGuarantees\n\nThis relaxes the ‚Äúno aliasing with mutability‚Äù restriction in places where it's unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your invariants depend on data stored within Cell, you should be careful.\n\nThis is useful for mutating primitives and other types when there is no easy way of doing it in line with the static rules of & and &mut.\n\nCell does not let you obtain interior references to the data, which makes it safe to freely mutate.\n\nCost\n\nThere is no runtime cost to using Cell<T>, however if you are using it to wrap larger structs, it might be worthwhile to instead wrap individual fields in Cell<T> since each write is otherwise a full copy of the struct.\n\nRefCell<T>\n\nRefCell<T> also provides interior mutability, but doesn't move data in and out of the cell.\n\nHowever, it has a runtime cost. RefCell<T> enforces the read-write lock pattern at runtime (it's like a single-threaded mutex), unlike &T/&mut T which do so at compile time. This is done by the borrow() and borrow_mut() functions, which modify an internal reference count and return smart pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when the smart pointers go out of scope. With this system, we can dynamically ensure that there are never any other borrows active when a mutable borrow is active. If the programmer attempts to make such a borrow, the thread will panic.\n\n\nuse std::cell::RefCell;\n\nlet x = RefCell::new(vec![1,2,3,4]);\n{\n    println!(\"{:?}\", *x.borrow())\n}\n\n{\n    let mut my_ref = x.borrow_mut();\n    my_ref.push(1);\n}\n\nSimilar to Cell, this is mainly useful for situations where it's hard or impossible to satisfy the borrow checker. Generally we know that such mutations won't happen in a nested form, but it's good to check.\n\nFor large, complicated programs, it becomes useful to put some things in RefCells to make things simpler. For example, a lot of the maps in the ctxt struct in the Rust compiler internals are inside this wrapper. These are only modified once (during creation, which is not right after initialization) or a couple of times in well-separated places. However, since this struct is pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps impossible) and probably form a soup of &-ptrs which would be hard to extend. On the other hand, the RefCell provides a cheap (not zero-cost) way of safely accessing these. In the future, if someone adds some code that attempts to modify the cell when it's already borrowed, it will cause a (usually deterministic) panic which can be traced back to the offending borrow.\n\nSimilarly, in Servo's DOM there is a lot of mutation, most of which is local to a DOM type, but some of which crisscrosses the DOM and modifies various things. Using RefCell and Cell to guard all mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the places where mutation is actually happening.\n\nNote that RefCell should be avoided if a mostly simple solution is possible with & pointers.\n\nGuarantees\n\nRefCell relaxes the static restrictions preventing aliased mutation, and replaces them with dynamic ones. As such the guarantees have not changed.\n\nCost\n\nRefCell does not allocate, but it contains an additional \"borrow state\" indicator (one word in size) along with the data.\n\nAt runtime each borrow causes a modification/check of the refcount.\n\nSynchronous types\n\nMany of the types above cannot be used in a threadsafe manner. Particularly, Rc<T> and RefCell<T>, which both use non-atomic reference counts (atomic reference counts are those which can be incremented from multiple threads without causing a data race), cannot be used this way. This makes them cheaper to use, but we need thread-safe versions of these too. They exist, in the form of Arc<T> and Mutex<T>/RwLock<T>\n\nNote that the non-threadsafe types cannot be sent between threads, and this is checked at compile time.\n\nThere are many useful wrappers for concurrent programming in the sync module, but only the major ones will be covered below.\n\nArc<T>\n\nArc<T> is a version of Rc<T> that uses an atomic reference count (hence, \"Arc\"). This can be sent freely between threads.\n\nC++'s shared_ptr is similar to Arc, however in the case of C++ the inner data is always mutable. For semantics similar to that from C++, we should use Arc<Mutex<T>>, Arc<RwLock<T>>, or Arc<UnsafeCell<T>>1 (UnsafeCell<T> is a cell type that can be used to hold any data and has no runtime cost, but accessing it requires unsafe blocks). The last one should only be used if we are certain that the usage won't cause any memory unsafety. Remember that writing to a struct is not an atomic operation, and many functions like vec.push() can reallocate internally and cause unsafe behavior, so even monotonicity may not be enough to justify UnsafeCell.\n\n1\n\nArc<UnsafeCell<T>> actually won't compile since UnsafeCell<T> isn't Send or Sync, but we can wrap it in a type and implement Send/Sync for it manually to get Arc<Wrapper<T>> where Wrapper is struct Wrapper<T>(UnsafeCell<T>).\n\nGuarantees\n\nLike Rc, this provides the (thread-safe) guarantee that the destructor for the internal data will be run when the last Arc goes out of scope (barring any cycles).\n\nCost\n\nThis has the added cost of using atomics for changing the refcount (which will happen whenever it is cloned or goes out of scope). When sharing data from an Arc in a single thread, it is preferable to share & pointers whenever possible.\n\nMutex<T> and RwLock<T>\n\nMutex<T> and RwLock<T> provide mutual-exclusion via RAII guards (guards are objects which maintain some state, like a lock, until their destructor is called). For both of these, the mutex is opaque until we call lock() on it, at which point the thread will block until a lock can be acquired, and then a guard will be returned. This guard can be used to access the inner data (mutably), and the lock will be released when the guard goes out of scope.\n\n{\n    let guard = mutex.lock();\n    // `guard` dereferences mutably to the inner type.\n    *guard += 1;\n} // Lock is released when destructor runs.\n\n\nRwLock has the added benefit of being efficient for multiple reads. It is always safe to have multiple readers to shared data as long as there are no writers; and RwLock lets readers acquire a \"read lock\". Such locks can be acquired concurrently and are kept track of via a reference count. Writers must obtain a \"write lock\" which can only be obtained when all readers have gone out of scope.\n\nGuarantees\n\nBoth of these provide safe shared mutability across threads, however they are prone to deadlocks. Some level of additional protocol safety can be obtained via the type system.\n\nCosts\n\nThese use internal atomic-like types to maintain the locks, which are pretty costly (they can block all memory reads across processors till they're done). Waiting on these locks can also be slow when there's a lot of concurrent access happening.\n\nComposition\n\nA common gripe when reading Rust code is with types like Rc<RefCell<Vec<T>>> (or even more complicated compositions of such types). It's not always clear what the composition does, or why the author chose one like this (and when one should be using such a composition in one's own code)\n\nUsually, it's a case of composing together the guarantees that you need, without paying for stuff that is unnecessary.\n\nFor example, Rc<RefCell<T>> is one such composition. Rc<T> itself can't be dereferenced mutably; because Rc<T> provides sharing and shared mutability can lead to unsafe behavior, so we put RefCell<T> inside to get dynamically verified shared mutability. Now we have shared mutable data, but it's shared in a way that there can only be one mutator (and no readers) or multiple readers.\n\nNow, we can take this a step further, and have Rc<RefCell<Vec<T>>> or Rc<Vec<RefCell<T>>>. These are both shareable, mutable vectors, but they're not the same.\n\nWith the former, the RefCell<T> is wrapping the Vec<T>, so the Vec<T> in its entirety is mutable. At the same time, there can only be one mutable borrow of the whole Vec at a given time. This means that your code cannot simultaneously work on different elements of the vector from different Rc handles. However, we are able to push and pop from the Vec<T> at will. This is similar to a &mut Vec<T> with the borrow checking done at runtime.\n\nWith the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus, we can independently borrow separate elements, but we cannot push or pop from the vector. This is similar to a &mut [T]2, but, again, the borrow checking is at runtime.\n\nIn concurrent programs, we have a similar situation with Arc<Mutex<T>>, which provides shared mutability and ownership.\n\nWhen reading code that uses these, go in step by step and look at the guarantees/costs provided.\n\nWhen choosing a composed type, we must do the reverse; figure out which guarantees we want, and at which point of the composition we need them. For example, if there is a choice between Vec<RefCell<T>> and RefCell<Vec<T>>, we should figure out the trade-offs as done above and pick one.\n\n2\n\n&[T] and &mut [T] are slices; they consist of a pointer and a length and can refer to a portion of a vector or array. &mut [T] can have its elements mutated, however its length cannot be touched."
  },
  {
    "title": "Concurrency - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/concurrency.html",
    "html": "Concurrency\n\nConcurrency and parallelism are incredibly important topics in computer science, and are also a hot topic in industry today. Computers are gaining more and more cores, yet many programmers aren't prepared to fully utilize them.\n\nRust's memory safety features also apply to its concurrency story. Even concurrent Rust programs must be memory safe, having no data races. Rust's type system is up to the task, and gives you powerful ways to reason about concurrent code at compile time.\n\nBefore we talk about the concurrency features that come with Rust, it's important to understand something: Rust is low-level enough that the vast majority of this is provided by the standard library, not by the language. This means that if you don't like some aspect of the way Rust handles concurrency, you can implement an alternative way of doing things. mio is a real-world example of this principle in action.\n\nBackground: Send and Sync\n\nConcurrency is difficult to reason about. In Rust, we have a strong, static type system to help us reason about our code. As such, Rust gives us two traits to help us make sense of code that can possibly be concurrent.\n\nSend\n\nThe first trait we're going to talk about is Send. When a type T implements Send, it indicates that something of this type is able to have ownership transferred safely between threads.\n\nThis is important to enforce certain restrictions. For example, if we have a channel connecting two threads, we would want to be able to send some data down the channel and to the other thread. Therefore, we'd ensure that Send was implemented for that type.\n\nIn the opposite way, if we were wrapping a library with FFI that isn't thread-safe, we wouldn't want to implement Send, and so the compiler will help us enforce that it can't leave the current thread.\n\nSync\n\nThe second of these traits is called Sync. When a type T implements Sync, it indicates that something of this type has no possibility of introducing memory unsafety when used from multiple threads concurrently through shared references. This implies that types which don't have interior mutability are inherently Sync, which includes simple primitive types (like u8) and aggregate types containing them.\n\nFor sharing references across threads, Rust provides a wrapper type called Arc<T>. Arc<T> implements Send and Sync if and only if T implements both Send and Sync. For example, an object of type Arc<RefCell<U>> cannot be transferred across threads because RefCell does not implement Sync, consequently Arc<RefCell<U>> would not implement Send.\n\nThese two traits allow you to use the type system to make strong guarantees about the properties of your code under concurrency. Before we demonstrate why, we need to learn how to create a concurrent Rust program in the first place!\n\nThreads\n\nRust's standard library provides a library for threads, which allow you to run Rust code in parallel. Here's a basic example of using std::thread:\n\nuse std::thread;\n\nfn main() {\n    thread::spawn(|| {\n        println!(\"Hello from a thread!\");\n    });\n}\n\n\nThe thread::spawn() method accepts a closure, which is executed in a new thread. It returns a handle to the thread, that can be used to wait for the child thread to finish and extract its result:\n\nuse std::thread;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        \"Hello from a thread!\"\n    });\n\n    println!(\"{}\", handle.join().unwrap());\n}\n\n\nAs closures can capture variables from their environment, we can also try to bring some data into the other thread:\n\nuse std::thread;\n\nfn main() {\n    let x = 1;\n    thread::spawn(|| {\n        println!(\"x is {}\", x);\n    });\n}\n\n\nHowever, this gives us an error:\n\n5:19: 7:6 error: closure may outlive the current function, but it\n                 borrows `x`, which is owned by the current function\n...\n5:19: 7:6 help: to force the closure to take ownership of `x` (and any other referenced variables),\n          use the `move` keyword, as shown:\n      thread::spawn(move || {\n          println!(\"x is {}\", x);\n      });\n\n\nThis is because by default closures capture variables by reference, and thus the closure only captures a reference to x. This is a problem, because the thread may outlive the scope of x, leading to a dangling pointer.\n\nTo fix this, we use a move closure as mentioned in the error message. move closures are explained in depth here; basically they move variables from their environment into themselves.\n\nuse std::thread;\n\nfn main() {\n    let x = 1;\n    thread::spawn(move || {\n        println!(\"x is {}\", x);\n    });\n}\n\n\nMany languages have the ability to execute threads, but it's wildly unsafe. There are entire books about how to prevent errors that occur from shared mutable state. Rust helps out with its type system here as well, by preventing data races at compile time. Let's talk about how you actually share things between threads.\n\nSafe Shared Mutable State\n\nDue to Rust's type system, we have a concept that sounds like a lie: \"safe shared mutable state.\" Many programmers agree that shared mutable state is very, very bad.\n\nSomeone once said this:\n\nShared mutable state is the root of all evil. Most languages attempt to deal with this problem through the 'mutable' part, but Rust deals with it by solving the 'shared' part.\n\nThe same ownership system that helps prevent using pointers incorrectly also helps rule out data races, one of the worst kinds of concurrency bugs.\n\nAs an example, here is a Rust program that would have a data race in many languages. It will not compile:\n\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let mut data = vec![1, 2, 3];\n\n    for i in 0..3 {\n        thread::spawn(move || {\n            data[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nThis gives us an error:\n\n8:17 error: capture of moved value: `data`\n        data[0] += i;\n        ^~~~\n\n\nRust knows this wouldn't be safe! If we had a reference to data in each thread, and the thread takes ownership of the reference, we'd have three owners! data gets moved out of main in the first call to spawn(), so subsequent calls in the loop cannot use this variable.\n\nSo, we need some type that lets us have more than one owning reference to a value. Usually, we'd use Rc<T> for this, which is a reference counted type that provides shared ownership. It has some runtime bookkeeping that keeps track of the number of references to it, hence the \"reference count\" part of its name.\n\nCalling clone() on an Rc<T> will return a new owned reference and bump the internal reference count. We create one of these for each thread:\n\nuse std::thread;\nuse std::time::Duration;\nuse std::rc::Rc;\n\nfn main() {\n    let mut data = Rc::new(vec![1, 2, 3]);\n\n    for i in 0..3 {\n        // Create a new owned reference:\n        let data_ref = data.clone();\n\n        // Use it in a thread:\n        thread::spawn(move || {\n            data_ref[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nThis won't work, however, and will give us the error:\n\n13:9: 13:22 error: the trait bound `alloc::rc::Rc<collections::vec::Vec<i32>> : core::marker::Send`\n            is not satisfied\n...\n13:9: 13:22 note: `alloc::rc::Rc<collections::vec::Vec<i32>>`\n            cannot be sent between threads safely\n\n\nAs the error message mentions, Rc cannot be sent between threads safely. This is because the internal reference count is not maintained in a thread-safe manner and can have a data race.\n\nTo solve this, we'll use Arc<T>, Rust's standard atomic reference count type.\n\nThe Atomic part means Arc<T> can safely be accessed from multiple threads. To do this the compiler guarantees that mutations of the internal count use indivisible operations which can't have data races.\n\nIn essence, Arc<T> is a type that lets us share ownership of data across threads.\n\nuse std::thread;\nuse std::sync::Arc;\nuse std::time::Duration;\n\nfn main() {\n    let mut data = Arc::new(vec![1, 2, 3]);\n\n    for i in 0..3 {\n        let data = data.clone();\n        thread::spawn(move || {\n            data[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nSimilarly to last time, we use clone() to create a new owned handle. This handle is then moved into the new thread.\n\nAnd... still gives us an error.\n\n<anon>:11:24 error: cannot borrow immutable borrowed content as mutable\n<anon>:11                    data[0] += i;\n                             ^~~~\n\n\nArc<T> by default has immutable contents. It allows the sharing of data between threads, but shared mutable data is unsafe‚Äîand when threads are involved‚Äîcan cause data races!\n\nUsually when we wish to make something in an immutable position mutable, we use Cell<T> or RefCell<T> which allow safe mutation via runtime checks or otherwise (see also: Choosing Your Guarantees). However, similar to Rc, these are not thread-safe. If we try using these, we will get an error about these types not being Sync, and the code will fail to compile.\n\nIt looks like we need some type that allows us to safely mutate a shared value across threads, for example a type that can ensure only one thread at a time is able to mutate the value inside it at any one time.\n\nFor that, we can use the Mutex<T> type!\n\nHere's the working version:\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n\n    for i in 0..3 {\n        let data = data.clone();\n        thread::spawn(move || {\n            let mut data = data.lock().unwrap();\n            data[0] += i;\n        });\n    }\n\n    thread::sleep(Duration::from_millis(50));\n}\n\n\nNote that the value of i is bound (copied) to the closure and not shared among the threads.\n\nWe're \"locking\" the mutex here. A mutex (short for \"mutual exclusion\"), as mentioned, only allows one thread at a time to access a value. When we wish to access the value, we use lock() on it. This will \"lock\" the mutex, and no other thread will be able to lock it (and hence, do anything with the value) until we're done with it. If a thread attempts to lock a mutex which is already locked, it will wait until the other thread releases the lock.\n\nThe lock \"release\" here is implicit; when the result of the lock (in this case, data) goes out of scope, the lock is automatically released.\n\nNote that lock method of Mutex has this signature:\n\nfn lock(&self) -> LockResult<MutexGuard<T>>\n\n\nand because Send is not implemented for MutexGuard<T>, the guard cannot cross thread boundaries, ensuring thread-locality of lock acquire and release.\n\nLet's examine the body of the thread more closely:\n\nthread::spawn(move || {\n    let mut data = data.lock().unwrap();\n    data[0] += i;\n});\n\n\nFirst, we call lock(), which acquires the mutex's lock. Because this may fail, it returns a Result<T, E>, and because this is just an example, we unwrap() it to get a reference to the data. Real code would have more robust error handling here. We're then free to mutate it, since we have the lock.\n\nLastly, while the threads are running, we wait on a short timer. But this is not ideal: we may have picked a reasonable amount of time to wait but it's more likely we'll either be waiting longer than necessary or not long enough, depending on just how much time the threads actually take to finish computing when the program runs.\n\nA more precise alternative to the timer would be to use one of the mechanisms provided by the Rust standard library for synchronizing threads with each other. Let's talk about one of them: channels.\n\nChannels\n\nHere's a version of our code that uses channels for synchronization, rather than waiting for a specific time:\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let data = Arc::new(Mutex::new(0));\n\n    // `tx` is the \"transmitter\" or \"sender\".\n    // `rx` is the \"receiver\".\n    let (tx, rx) = mpsc::channel();\n\n    for _ in 0..10 {\n        let (data, tx) = (data.clone(), tx.clone());\n\n        thread::spawn(move || {\n            let mut data = data.lock().unwrap();\n            *data += 1;\n\n            tx.send(()).unwrap();\n        });\n    }\n\n    for _ in 0..10 {\n        rx.recv().unwrap();\n    }\n}\n\n\nWe use the mpsc::channel() method to construct a new channel. We send a simple () down the channel, and then wait for ten of them to come back.\n\nWhile this channel is sending a generic signal, we can send any data that is Send over the channel!\n\nuse std::thread;\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    for i in 0..10 {\n        let tx = tx.clone();\n\n        thread::spawn(move || {\n            let answer = i * i;\n\n            tx.send(answer).unwrap();\n        });\n    }\n\n    for _ in 0..10 {\n        println!(\"{}\", rx.recv().unwrap());\n    }\n}\n\n\nHere we create 10 threads, asking each to calculate the square of a number (i at the time of spawn()), and then send() back the answer over the channel.\n\nPanics\n\nA panic! will crash the currently executing thread. You can use Rust's threads as a simple isolation mechanism:\n\n\nuse std::thread;\n\nlet handle = thread::spawn(move || {\n    panic!(\"oops!\");\n});\n\nlet result = handle.join();\n\nassert!(result.is_err());\n\nThread.join() gives us a Result back, which allows us to check if the thread has panicked or not."
  },
  {
    "title": "Iterators - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/iterators.html",
    "html": "Iterators\n\nLet's talk about loops.\n\nRemember Rust's for loop? Here's an example:\n\n\nfor x in 0..10 {\n    println!(\"{}\", x);\n}\n\nNow that you know more Rust, we can talk in detail about how this works. Ranges (the 0..10) are 'iterators'. An iterator is something that we can call the .next() method on repeatedly, and it gives us a sequence of things.\n\nA range with two dots like 0..10 is inclusive on the left (so it starts at 0) and exclusive on the right (so it ends at 9). A mathematician would write \"[0, 10)\".\n\nLike this:\n\n\nlet mut range = 0..10;\n\nloop {\n    match range.next() {\n        Some(x) => {\n            println!(\"{}\", x);\n        },\n        None => { break }\n    }\n}\n\nWe make a mutable binding to the range, which is our iterator. We then loop, with an inner match. This match is used on the result of range.next(), which gives us a reference to the next value of the iterator. next returns an Option<i32>, in this case, which will be Some(i32) when we have a value and None once we run out. If we get Some(i32), we print it out, and if we get None, we break out of the loop.\n\nThis code sample is basically the same as our for loop version. The for loop is a handy way to write this loop/match/break construct.\n\nfor loops aren't the only thing that uses iterators, however. Writing your own iterator involves implementing the Iterator trait. While doing that is outside of the scope of this guide, Rust provides a number of useful iterators to accomplish various tasks. But first, a few notes about limitations of ranges.\n\nRanges are very primitive, and we often can use better alternatives. Consider the following Rust anti-pattern: using ranges to emulate a C-style for loop. Let‚Äôs suppose you needed to iterate over the contents of a vector. You may be tempted to write this:\n\n\nlet nums = vec![1, 2, 3];\n\nfor i in 0..nums.len() {\n    println!(\"{}\", nums[i]);\n}\n\nThis is strictly worse than using an actual iterator. You can iterate over vectors directly, so write this:\n\n\nlet nums = vec![1, 2, 3];\n\nfor num in &nums {\n    println!(\"{}\", num);\n}\n\nThere are two reasons for this. First, this more directly expresses what we mean. We iterate through the entire vector, rather than iterating through indexes, and then indexing the vector. Second, this version is more efficient: the first version will have extra bounds checking because it used indexing, nums[i]. But since we yield a reference to each element of the vector in turn with the iterator, there's no bounds checking in the second example. This is very common with iterators: we can ignore unnecessary bounds checks, but still know that we're safe.\n\nThere's another detail here that's not 100% clear because of how println! works. num is actually of type &i32. That is, it's a reference to an i32, not an i32 itself. println! handles the dereferencing for us, so we don't see it. This code works fine too:\n\n\nlet nums = vec![1, 2, 3];\n\nfor num in &nums {\n    println!(\"{}\", *num);\n}\n\nNow we're explicitly dereferencing num. Why does &nums give us references? Firstly, because we explicitly asked it to with &. Secondly, if it gave us the data itself, we would have to be its owner, which would involve making a copy of the data and giving us the copy. With references, we're only borrowing a reference to the data, and so it's only passing a reference, without needing to do the move.\n\nSo, now that we've established that ranges are often not what you want, let's talk about what you do want instead.\n\nThere are three broad classes of things that are relevant here: iterators, iterator adaptors, and consumers. Here's some definitions:\n\niterators give you a sequence of values.\niterator adaptors operate on an iterator, producing a new iterator with a different output sequence.\nconsumers operate on an iterator, producing some final set of values.\n\nLet's talk about consumers first, since you've already seen an iterator, ranges.\n\nConsumers\n\nA consumer operates on an iterator, returning some kind of value or values. The most common consumer is collect(). This code doesn't quite compile, but it shows the intention:\n\nlet one_to_one_hundred = (1..101).collect();\n\n\nAs you can see, we call collect() on our iterator. collect() takes as many values as the iterator will give it, and returns a collection of the results. So why won't this compile? Rust can't determine what type of things you want to collect, and so you need to let it know. Here's the version that does compile:\n\n\nlet one_to_one_hundred = (1..101).collect::<Vec<i32>>();\n\nIf you remember, the ::<> syntax allows us to give a type hint that tells the compiler we want a vector of integers. You don't always need to use the whole type, though. Using a _ will let you provide a partial hint:\n\n\nlet one_to_one_hundred = (1..101).collect::<Vec<_>>();\n\nThis says \"Collect into a Vec<T>, please, but infer what the T is for me.\" _ is sometimes called a \"type placeholder\" for this reason.\n\ncollect() is the most common consumer, but there are others too. find() is one:\n\n\nlet greater_than_forty_two = (0..100)\n                             .find(|x| *x > 42);\n\nmatch greater_than_forty_two {\n    Some(_) => println!(\"Found a match!\"),\n    None => println!(\"No match found :(\"),\n}\n\nfind takes a closure, and works on a reference to each element of an iterator. This closure returns true if the element is the element we're looking for, and false otherwise. find returns the first element satisfying the specified predicate. Because we might not find a matching element, find returns an Option rather than the element itself.\n\nAnother important consumer is fold. Here's what it looks like:\n\n\nlet sum = (1..4).fold(0, |sum, x| sum + x);\n\nfold() is a consumer that looks like this: fold(base, |accumulator, element| ...). It takes two arguments: the first is an element called the base. The second is a closure that itself takes two arguments: the first is called the accumulator, and the second is an element. Upon each iteration, the closure is called, and the result is the value of the accumulator on the next iteration. On the first iteration, the base is assigned the value of the accumulator.\n\nOkay, that's a bit confusing. Let's examine the values of all of these things in this iterator:\n\nbase\taccumulator\telement\tclosure result\n0\t0\t1\t1\n0\t1\t2\t3\n0\t3\t3\t6\n\nWe called fold() with these arguments:\n\n\n.fold(0, |sum, x| sum + x);\n\nSo, 0 is our base, sum is our accumulator, and x is our element. On the first iteration, we set sum to 0, and x is the first element of nums, 1. We then add sum and x, which gives us 0 + 1 = 1. On the second iteration, that value becomes our accumulator, sum, and the element is the second element of the array, 2. 1 + 2 = 3, and so that becomes the value of the accumulator for the last iteration. On that iteration, x is the last element, 3, and 3 + 3 = 6, which is our final result for our sum. 1 + 2 + 3 = 6, and that's the result we got.\n\nWhew. fold can be a bit strange the first few times you see it, but once it clicks, you can use it all over the place. Any time you have a list of things, and you want a single result, fold is appropriate.\n\nConsumers are important due to one additional property of iterators we haven't talked about yet: laziness. Let's talk some more about iterators, and you'll see why consumers matter.\n\nIterators\n\nAs we've said before, an iterator is something that we can call the .next() method on repeatedly, and it gives us a sequence of things. Because you need to call the method, this means that iterators can be lazy and not generate all of the values upfront. This code, for example, does not actually generate the numbers 1-99, instead creating a value that merely represents the sequence:\n\n\nlet nums = 1..100;\n\nSince we didn't do anything with the range, it didn't generate the sequence. Let's add the consumer:\n\n\nlet nums = (1..100).collect::<Vec<i32>>();\n\nNow, collect() will require that the range gives it some numbers, and so it will do the work of generating the sequence.\n\nRanges are one of two basic iterators that you'll see. The other is iter(). iter() can turn a vector into a simple iterator that gives you each element in turn:\n\n\nlet nums = vec![1, 2, 3];\n\nfor num in nums.iter() {\n   println!(\"{}\", num);\n}\n\nThese two basic iterators should serve you well. There are some more advanced iterators, including ones that are infinite.\n\nThat's enough about iterators. Iterator adaptors are the last concept we need to talk about with regards to iterators. Let's get to it!\n\nIterator adaptors\n\nIterator adaptors take an iterator and modify it somehow, producing a new iterator. The simplest one is called map:\n\n(1..100).map(|x| x + 1);\n\n\nmap is called upon another iterator, and produces a new iterator where each element reference has the closure it's been given as an argument called on it. So this would give us the numbers from 2-100. Well, almost! If you compile the example, you'll get a warning:\n\nwarning: unused result which must be used: iterator adaptors are lazy and\n         do nothing unless consumed, #[warn(unused_must_use)] on by default\n(1..100).map(|x| x + 1);\n ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nLaziness strikes again! That closure will never execute. This example doesn't print any numbers:\n\n(1..100).map(|x| println!(\"{}\", x));\n\n\nIf you are trying to execute a closure on an iterator for its side effects, use for instead.\n\nThere are tons of interesting iterator adaptors. take(n) will return an iterator over the next n elements of the original iterator. Let's try it out with an infinite iterator:\n\n\nfor i in (1..).take(5) {\n    println!(\"{}\", i);\n}\n\nThis will print\n\n1\n2\n3\n4\n5\n\n\nfilter() is an adapter that takes a closure as an argument. This closure returns true or false. The new iterator filter() produces only the elements that the closure returns true for:\n\n\nfor i in (1..100).filter(|&x| x % 2 == 0) {\n    println!(\"{}\", i);\n}\n\nThis will print all of the even numbers between one and a hundred. (Note that, unlike map, the closure passed to filter is passed a reference to the element instead of the element itself. The filter predicate here uses the &x pattern to extract the integer. The filter closure is passed a reference because it returns true or false instead of the element, so the filter implementation must retain ownership to put the elements into the newly constructed iterator.)\n\nYou can chain all three things together: start with an iterator, adapt it a few times, and then consume the result. Check it out:\n\n\n(1..)\n    .filter(|&x| x % 2 == 0)\n    .filter(|&x| x % 3 == 0)\n    .take(5)\n    .collect::<Vec<i32>>();\n\nThis will give you a vector containing 6, 12, 18, 24, and 30.\n\nThis is just a small taste of what iterators, iterator adaptors, and consumers can help you with. There are a number of really useful iterators, and you can write your own as well. Iterators provide a safe, efficient way to manipulate all kinds of lists. They're a little unusual at first, but if you play with them, you'll get hooked. For a full list of the different iterators and consumers, check out the iterator module documentation."
  },
  {
    "title": "Documentation - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/documentation.html",
    "html": "Documentation\n\nDocumentation is an important part of any software project, and it's first-class in Rust. Let's talk about the tooling Rust gives you to document your project.\n\nAbout rustdoc\n\nThe Rust distribution includes a tool, rustdoc, that generates documentation. rustdoc is also used by Cargo through cargo doc.\n\nDocumentation can be generated in two ways: from source code, and from standalone Markdown files.\n\nDocumenting source code\n\nThe primary way of documenting a Rust project is through annotating the source code. You can use documentation comments for this purpose:\n\n/// Constructs a new `Rc<T>`.\n///\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\npub fn new(value: T) -> Rc<T> {\n    // Implementation goes here.\n}\n\n\nThis code generates documentation that looks like this. I've left the implementation out, with a regular comment in its place.\n\nThe first thing to notice about this annotation is that it uses /// instead of //. The triple slash indicates a documentation comment.\n\nDocumentation comments are written in Markdown.\n\nRust keeps track of these comments, and uses them when generating documentation. This is important when documenting things like enums:\n\n\n/// The `Option` type. See [the module level documentation](index.html) for more.\nenum Option<T> {\n    /// No value\n    None,\n    /// Some value `T`\n    Some(T),\n}\n\nThe above works, but this does not:\n\n/// The `Option` type. See [the module level documentation](index.html) for more.\nenum Option<T> {\n    None, /// No value\n    Some(T), /// Some value `T`\n}\n\n\nYou'll get an error:\n\nhello.rs:4:1: 4:2 error: expected ident, found `}`\nhello.rs:4 }\n           ^\n\n\nThis unfortunate error is correct; documentation comments apply to the thing after them, and there's nothing after that last comment.\n\nWriting documentation comments\n\nAnyway, let's cover each part of this comment in detail:\n\n\n/// Constructs a new `Rc<T>`.\n\nThe first line of a documentation comment should be a short summary of its functionality. One sentence. Just the basics. High level.\n\n\n///\n/// Other details about constructing `Rc<T>`s, maybe describing complicated\n/// semantics, maybe additional options, all kinds of stuff.\n///\n\nOur original example had just a summary line, but if we had more things to say, we could have added more explanation in a new paragraph.\n\nSpecial sections\n\nNext, are special sections. These are indicated with a header, #. There are four kinds of headers that are commonly used. They aren't special syntax, just convention, for now.\n\n\n/// # Panics\n\nUnrecoverable misuses of a function (i.e. programming errors) in Rust are usually indicated by panics, which kill the whole current thread at the very least. If your function has a non-trivial contract like this, that is detected/enforced by panics, documenting it is very important.\n\n\n/// # Errors\n\nIf your function or method returns a Result<T, E>, then describing the conditions under which it returns Err(E) is a nice thing to do. This is slightly less important than Panics, because failure is encoded into the type system, but it's still a good thing to do.\n\n\n/// # Safety\n\nIf your function is unsafe, you should explain which invariants the caller is responsible for upholding.\n\n\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\n\nFourth, Examples. Include one or more examples of using your function or method, and your users will love you for it. These examples go inside of code block annotations, which we'll talk about in a moment, and can have more than one section:\n\n\n/// # Examples\n///\n/// Simple `&str` patterns:\n///\n/// ```\n/// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n/// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n/// ```\n///\n/// More complex patterns with a lambda:\n///\n/// ```\n/// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n/// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n/// ```\nCode block annotations\n\nTo write some Rust code in a comment, use the triple graves:\n\n\n/// ```\n/// println!(\"Hello, world\");\n/// ```\n\nThis will add code highlighting. If you are only showing plain text, put text instead of rust after the triple graves (see below).\n\nDocumentation as tests\n\nLet's discuss our sample example documentation:\n\n\n/// ```\n/// println!(\"Hello, world\");\n/// ```\n\nYou'll notice that you don't need a fn main() or anything here. rustdoc will automatically add a main() wrapper around your code, using heuristics to attempt to put it in the right place. For example:\n\n\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\n\nThis will end up testing:\n\nfn main() {\n    use std::rc::Rc;\n    let five = Rc::new(5);\n}\n\n\nHere's the full algorithm rustdoc uses to preprocess examples:\n\nAny leading #![foo] attributes are left intact as crate attributes.\nSome common allow attributes are inserted, including unused_variables, unused_assignments, unused_mut, unused_attributes, and dead_code. Small examples often trigger these lints.\nIf the example does not contain extern crate, then extern crate <mycrate>; is inserted (note the lack of #[macro_use]).\nFinally, if the example does not contain fn main, the remainder of the text is wrapped in fn main() { your_code }.\n\nThis generated fn main can be a problem! If you have extern crate or a mod statements in the example code that are referred to by use statements, they will fail to resolve unless you include at least fn main() {} to inhibit step 4. #[macro_use] extern crate also does not work except at the crate root, so when testing macros an explicit main is always required. It doesn't have to clutter up your docs, though -- keep reading!\n\nSometimes this algorithm isn't enough, though. For example, all of these code samples with /// we've been talking about? The raw text:\n\n/// Some documentation.\n# fn foo() {}\n\n\nlooks different than the output:\n\n\n/// Some documentation.\n\nYes, that's right: you can add lines that start with #, and they will be hidden from the output, but will be used when compiling your code. You can use this to your advantage. In this case, documentation comments need to apply to some kind of function, so if I want to show you just a documentation comment, I need to add a little function definition below it. At the same time, it's only there to satisfy the compiler, so hiding it makes the example more clear. You can use this technique to explain longer examples in detail, while still preserving the testability of your documentation.\n\nFor example, imagine that we wanted to document this code:\n\n\nlet x = 5;\nlet y = 6;\nprintln!(\"{}\", x + y);\n\nWe might want the documentation to end up looking like this:\n\nFirst, we set x to five:\n\n\nlet x = 5;\n\nNext, we set y to six:\n\n\nlet y = 6;\n\nFinally, we print the sum of x and y:\n\n\nprintln!(\"{}\", x + y);\n\nTo keep each code block testable, we want the whole program in each block, but we don't want the reader to see every line every time. Here's what we put in our source code:\n\n    First, we set `x` to five:\n\n    ```rust\n    let x = 5;\n    # let y = 6;\n    # println!(\"{}\", x + y);\n    ```\n\n    Next, we set `y` to six:\n\n    ```rust\n    # let x = 5;\n    let y = 6;\n    # println!(\"{}\", x + y);\n    ```\n\n    Finally, we print the sum of `x` and `y`:\n\n    ```rust\n    # let x = 5;\n    # let y = 6;\n    println!(\"{}\", x + y);\n    ```\n\n\nBy repeating all parts of the example, you can ensure that your example still compiles, while only showing the parts that are relevant to that part of your explanation.\n\nDocumenting macros\n\nHere‚Äôs an example of documenting a macro:\n\n/// Panic with a given message unless an expression evaluates to true.\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate foo;\n/// # fn main() {\n/// panic_unless!(1 + 1 == 2, ‚ÄúMath is broken.‚Äù);\n/// # }\n/// ```\n///\n/// ```rust,should_panic\n/// # #[macro_use] extern crate foo;\n/// # fn main() {\n/// panic_unless!(true == false, ‚ÄúI‚Äôm broken.‚Äù);\n/// # }\n/// ```\n#[macro_export]\nmacro_rules! panic_unless {\n    ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });\n}\n\n\nYou‚Äôll note three things: we need to add our own extern crate line, so that we can add the #[macro_use] attribute. Second, we‚Äôll need to add our own main() as well (for reasons discussed above). Finally, a judicious use of # to comment out those two things, so they don‚Äôt show up in the output.\n\nAnother case where the use of # is handy is when you want to ignore error handling. Lets say you want the following,\n\n/// use std::io;\n/// let mut input = String::new();\n/// try!(io::stdin().read_line(&mut input));\n\n\nThe problem is that try! returns a Result<T, E> and test functions don't return anything so this will give a mismatched types error.\n\n/// A doc test using try!\n///\n/// ```\n/// use std::io;\n/// # fn foo() -> io::Result<()> {\n/// let mut input = String::new();\n/// try!(io::stdin().read_line(&mut input));\n/// # Ok(())\n/// # }\n/// ```\n\n\nYou can get around this by wrapping the code in a function. This catches and swallows the Result<T, E> when running tests on the docs. This pattern appears regularly in the standard library.\n\nRunning documentation tests\n\nTo run the tests, either:\n\n$ rustdoc --test path/to/my/crate/root.rs\n# or\n$ cargo test\n\n\nThat's right, cargo test tests embedded documentation too. However, cargo test will not test binary crates, only library ones. This is due to the way rustdoc works: it links against the library to be tested, but with a binary, there‚Äôs nothing to link to.\n\nThere are a few more annotations that are useful to help rustdoc do the right thing when testing your code:\n\n\n/// ```rust,ignore\n/// fn foo() {\n/// ```\n\nThe ignore directive tells Rust to ignore your code. This is almost never what you want, as it's the most generic. Instead, consider annotating it with text if it's not code, or using #s to get a working example that only shows the part you care about.\n\n\n/// ```rust,should_panic\n/// assert!(false);\n/// ```\n\nshould_panic tells rustdoc that the code should compile correctly, but not actually pass as a test.\n\n\n/// ```rust,no_run\n/// loop {\n///     println!(\"Hello, world\");\n/// }\n/// ```\n\nThe no_run attribute will compile your code, but not run it. This is important for examples such as \"Here's how to retrieve a web page,\" which you would want to ensure compiles, but might be run in a test environment that has no network access.\n\nDocumenting modules\n\nRust has another kind of doc comment, //!. This comment doesn't document the next item, but the enclosing item. In other words:\n\n\nmod foo {\n    //! This is documentation for the `foo` module.\n    //!\n    //! # Examples\n\n    // ...\n}\n\nThis is where you'll see //! used most often: for module documentation. If you have a module in foo.rs, you'll often open its code and see this:\n\n\n//! A module for using `foo`s.\n//!\n//! The `foo` module contains a lot of useful functionality blah blah blah...\nCrate documentation\n\nCrates can be documented by placing an inner doc comment (//!) at the beginning of the crate root, aka lib.rs:\n\n\n//! This is documentation for the `foo` crate.\n//!\n//! The foo crate is meant to be used for bar.\nDocumentation comment style\n\nCheck out RFC 505 for full conventions around the style and format of documentation.\n\nOther documentation\n\nAll of this behavior works in non-Rust source files too. Because comments are written in Markdown, they're often .md files.\n\nWhen you write documentation in Markdown files, you don't need to prefix the documentation with comments. For example:\n\n\n/// # Examples\n///\n/// ```\n/// use std::rc::Rc;\n///\n/// let five = Rc::new(5);\n/// ```\n\nis:\n\n# Examples\n\n```\nuse std::rc::Rc;\n\nlet five = Rc::new(5);\n```\n\n\nwhen it's in a Markdown file. There is one wrinkle though: Markdown files need to have a title like this:\n\n% The title\n\nThis is the example documentation.\n\n\nThis % line needs to be the very first line of the file.\n\ndoc attributes\n\nAt a deeper level, documentation comments are syntactic sugar for documentation attributes:\n\n\n/// this\n\n#[doc=\"this\"]\n\nare the same, as are these:\n\n\n//! this\n\n#![doc=\"this\"]\n\nYou won't often see this attribute used for writing documentation, but it can be useful when changing some options, or when writing a macro.\n\nRe-exports\n\nrustdoc will show the documentation for a public re-export in both places:\n\nextern crate foo;\n\npub use foo::bar;\n\n\nThis will create documentation for bar both inside the documentation for the crate foo, as well as the documentation for your crate. It will use the same documentation in both places.\n\nThis behavior can be suppressed with no_inline:\n\nextern crate foo;\n\n#[doc(no_inline)]\npub use foo::bar;\n\nMissing documentation\n\nSometimes you want to make sure that every single public thing in your project is documented, especially when you are working on a library. Rust allows you to to generate warnings or errors, when an item is missing documentation. To generate warnings you use warn:\n\n#![warn(missing_docs)]\n\n\nAnd to generate errors you use deny:\n\n#![deny(missing_docs)]\n\n\nThere are cases where you want to disable these warnings/errors to explicitly leave something undocumented. This is done by using allow:\n\n\n#[allow(missing_docs)]\nstruct Undocumented;\n\nYou might even want to hide items from the documentation completely:\n\n\n#[doc(hidden)]\nstruct Hidden;\nControlling HTML\n\nYou can control a few aspects of the HTML that rustdoc generates through the #![doc] version of the attribute:\n\n#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/\")]\n\n\nThis sets a few different options, with a logo, favicon, and a root URL.\n\nConfiguring documentation tests\n\nYou can also configure the way that rustdoc tests your documentation examples through the #![doc(test(..))] attribute.\n\n\n#![doc(test(attr(allow(unused_variables), deny(warnings))))]\n\nThis allows unused variables within the examples, but will fail the test for any other lint warning thrown.\n\nGeneration options\n\nrustdoc also contains a few other options on the command line, for further customization:\n\n--html-in-header FILE: includes the contents of FILE at the end of the <head>...</head> section.\n--html-before-content FILE: includes the contents of FILE directly after <body>, before the rendered content (including the search bar).\n--html-after-content FILE: includes the contents of FILE after all the rendered content.\nSecurity note\n\nThe Markdown in documentation comments is placed without processing into the final webpage. Be careful with literal HTML:\n\n\n/// <script>alert(document.cookie)</script>"
  },
  {
    "title": "Conditional Compilation - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/conditional-compilation.html",
    "html": "Conditional Compilation\n\nRust has a special attribute, #[cfg], which allows you to compile code based on a flag passed to the compiler. It has two forms:\n\n\n#[cfg(foo)]\n\n#[cfg(bar = \"baz\")]\n\nThey also have some helpers:\n\n\n#[cfg(any(unix, windows))]\n\n#[cfg(all(unix, target_pointer_width = \"32\"))]\n\n#[cfg(not(foo))]\n\nThese can nest arbitrarily:\n\n\n#[cfg(any(not(unix), all(target_os=\"macos\", target_arch = \"powerpc\")))]\n\nAs for how to enable or disable these switches, if you‚Äôre using Cargo, they get set in the [features] section of your Cargo.toml:\n\n[features]\n# no features by default\ndefault = []\n\n# Add feature \"foo\" here, then you can use it. \n# Our \"foo\" feature depends on nothing else.\nfoo = []\n\n\nWhen you do this, Cargo passes along a flag to rustc:\n\n--cfg feature=\"${feature_name}\"\n\n\nThe sum of these cfg flags will determine which ones get activated, and therefore, which code gets compiled. Let‚Äôs take this code:\n\n\n#[cfg(feature = \"foo\")]\nmod foo {\n}\n\nIf we compile it with cargo build --features \"foo\", it will send the --cfg feature=\"foo\" flag to rustc, and the output will have the mod foo in it. If we compile it with a regular cargo build, no extra flags get passed on, and so, no foo module will exist.\n\ncfg_attr\n\nYou can also set another attribute based on a cfg variable with cfg_attr:\n\n\n#[cfg_attr(a, b)]\n\nWill be the same as #[b] if a is set by cfg attribute, and nothing otherwise.\n\ncfg!\n\nThe cfg! macro lets you use these kinds of flags elsewhere in your code, too:\n\n\nif cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n    println!(\"Think Different!\");\n}\n\nThese will be replaced by a true or false at compile-time, depending on the configuration settings."
  },
  {
    "title": "The Stack and the Heap - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/the-stack-and-the-heap.html",
    "html": "The Stack and the Heap\n\nAs a systems language, Rust operates at a low level. If you‚Äôre coming from a high-level language, there are some aspects of systems programming that you may not be familiar with. The most important one is how memory works, with a stack and a heap. If you‚Äôre familiar with how C-like languages use stack allocation, this chapter will be a refresher. If you‚Äôre not, you‚Äôll learn about this more general concept, but with a Rust-y focus.\n\nAs with most things, when learning about them, we‚Äôll use a simplified model to start. This lets you get a handle on the basics, without getting bogged down with details which are, for now, irrelevant. The examples we‚Äôll use aren‚Äôt 100% accurate, but are representative for the level we‚Äôre trying to learn at right now. Once you have the basics down, learning more about how allocators are implemented, virtual memory, and other advanced topics will reveal the leaks in this particular abstraction.\n\nMemory management\n\nThese two terms are about memory management. The stack and the heap are abstractions that help you determine when to allocate and deallocate memory.\n\nHere‚Äôs a high-level comparison:\n\nThe stack is very fast, and is where memory is allocated in Rust by default. But the allocation is local to a function call, and is limited in size. The heap, on the other hand, is slower, and is explicitly allocated by your program. But it‚Äôs effectively unlimited in size, and is globally accessible. Note this meaning of heap, which allocates arbitrary-sized blocks of memory in arbitrary order, is quite different from the heap data structure.\n\nThe Stack\n\nLet‚Äôs talk about this Rust program:\n\nfn main() {\n    let x = 42;\n}\n\n\nThis program has one variable binding, x. This memory needs to be allocated from somewhere. Rust ‚Äòstack allocates‚Äô by default, which means that basic values ‚Äògo on the stack‚Äô. What does that mean?\n\nWell, when a function gets called, some memory gets allocated for all of its local variables and some other information. This is called a ‚Äòstack frame‚Äô, and for the purpose of this tutorial, we‚Äôre going to ignore the extra information and only consider the local variables we‚Äôre allocating. So in this case, when main() is run, we‚Äôll allocate a single 32-bit integer for our stack frame. This is automatically handled for you, as you can see; we didn‚Äôt have to write any special Rust code or anything.\n\nWhen the function exits, its stack frame gets deallocated. This happens automatically as well.\n\nThat‚Äôs all there is for this simple program. The key thing to understand here is that stack allocation is very, very fast. Since we know all the local variables we have ahead of time, we can grab the memory all at once. And since we‚Äôll throw them all away at the same time as well, we can get rid of it very fast too.\n\nThe downside is that we can‚Äôt keep values around if we need them for longer than a single function. We also haven‚Äôt talked about what the word, ‚Äòstack‚Äô, means. To do that, we need a slightly more complicated example:\n\nfn foo() {\n    let y = 5;\n    let z = 100;\n}\n\nfn main() {\n    let x = 42;\n\n    foo();\n}\n\n\nThis program has three variables total: two in foo(), one in main(). Just as before, when main() is called, a single integer is allocated for its stack frame. But before we can show what happens when foo() is called, we need to visualize what‚Äôs going on with memory. Your operating system presents a view of memory to your program that‚Äôs pretty simple: a huge list of addresses, from 0 to a large number, representing how much RAM your computer has. For example, if you have a gigabyte of RAM, your addresses go from 0 to 1,073,741,823. That number comes from 230, the number of bytes in a gigabyte. 1\n\n1\n\n‚ÄòGigabyte‚Äô can mean two things: 109, or 230. The IEC standard resolved this by stating that ‚Äògigabyte‚Äô is 109, and ‚Äògibibyte‚Äô is 230. However, very few people use this terminology, and rely on context to differentiate. We follow in that tradition here.\n\nThis memory is kind of like a giant array: addresses start at zero and go up to the final number. So here‚Äôs a diagram of our first stack frame:\n\nAddress\tName\tValue\n0\tx\t42\n\nWe‚Äôve got x located at address 0, with the value 42.\n\nWhen foo() is called, a new stack frame is allocated:\n\nAddress\tName\tValue\n2\tz\t100\n1\ty\t5\n0\tx\t42\n\nBecause 0 was taken by the first frame, 1 and 2 are used for foo()‚Äôs stack frame. It grows upward, the more functions we call. Notice that we are not taking into account the size of each variable (for example, a 32 bit variable would use the memory addresses from 0 to 3, or 4 bytes).\n\nThere are some important things we have to take note of here. The numbers 0, 1, and 2 are all solely for illustrative purposes, and bear no relationship to the address values the computer will use in reality. In particular, the series of addresses are in reality going to be separated by some number of bytes that separate each address, and that separation may even exceed the size of the value being stored.\n\nAfter foo() is over, its frame is deallocated:\n\nAddress\tName\tValue\n0\tx\t42\n\nAnd then, after main(), even this last value goes away. Easy!\n\nIt‚Äôs called a ‚Äòstack‚Äô because it works like a stack of dinner plates: the first plate you put down is the last plate to pick back up. Stacks are sometimes called ‚Äòlast in, first out queues‚Äô for this reason, as the last value you put on the stack is the first one you retrieve from it.\n\nLet‚Äôs try a three-deep example:\n\nfn italic() {\n    let i = 6;\n}\n\nfn bold() {\n    let a = 5;\n    let b = 100;\n    let c = 1;\n\n    italic();\n}\n\nfn main() {\n    let x = 42;\n\n    bold();\n}\n\n\nWe have some kooky function names to make the diagrams clearer.\n\nOkay, first, we call main():\n\nAddress\tName\tValue\n0\tx\t42\n\nNext up, main() calls bold():\n\nAddress\tName\tValue\n3\tc\t1\n2\tb\t100\n1\ta\t5\n0\tx\t42\n\nAnd then bold() calls italic():\n\nAddress\tName\tValue\n4\ti\t6\n3\tc\t1\n2\tb\t100\n1\ta\t5\n0\tx\t42\n\nWhew! Our stack is growing tall.\n\nAfter italic() is over, its frame is deallocated, leaving only bold() and main():\n\nAddress\tName\tValue\n3\tc\t1\n2\tb\t100\n1\ta\t5\n0\tx\t42\n\nAnd then bold() ends, leaving only main():\n\nAddress\tName\tValue\n0\tx\t42\n\nAnd then we‚Äôre done. Getting the hang of it? It‚Äôs like piling up dishes: you add to the top, you take away from the top.\n\nThe Heap\n\nNow, this works pretty well, but not everything can work like this. Sometimes, you need to pass some memory between different functions, or keep it alive for longer than a single function‚Äôs execution. For this, we can use the heap.\n\nIn Rust, you can allocate memory on the heap with the Box<T> type. Here‚Äôs an example:\n\nfn main() {\n    let x = Box::new(5);\n    let y = 42;\n}\n\n\nHere‚Äôs what happens in memory when main() is called:\n\nAddress\tName\tValue\n1\ty\t42\n0\tx\t??????\n\nWe allocate space for two variables on the stack. y is 42, as it always has been, but what about x? Well, x is a Box<i32>, and boxes allocate memory on the heap. The actual value of the box is a structure which has a pointer to ‚Äòthe heap‚Äô. When we start executing the function, and Box::new() is called, it allocates some memory for the heap, and puts 5 there. The memory now looks like this:\n\nAddress\tName\tValue\n(230) - 1\t\t5\n...\t...\t...\n1\ty\t42\n0\tx\t‚Üí (230) - 1\n\nWe have (230) addresses in our hypothetical computer with 1GB of RAM. And since our stack grows from zero, the easiest place to allocate memory is from the other end. So our first value is at the highest place in memory. And the value of the struct at x has a raw pointer to the place we‚Äôve allocated on the heap, so the value of x is (230) - 1, the memory location we‚Äôve asked for.\n\nWe haven‚Äôt really talked too much about what it actually means to allocate and deallocate memory in these contexts. Getting into very deep detail is out of the scope of this tutorial, but what‚Äôs important to point out here is that the heap isn‚Äôt a stack that grows from the opposite end. We‚Äôll have an example of this later in the book, but because the heap can be allocated and freed in any order, it can end up with ‚Äòholes‚Äô. Here‚Äôs a diagram of the memory layout of a program which has been running for a while now:\n\nAddress\tName\tValue\n(230) - 1\t\t5\n(230) - 2\t\t\n(230) - 3\t\t\n(230) - 4\t\t42\n...\t...\t...\n2\tz\t‚Üí (230) - 4\n1\ty\t42\n0\tx\t‚Üí (230) - 1\n\nIn this case, we‚Äôve allocated four things on the heap, but deallocated two of them. There‚Äôs a gap between (230) - 1 and (230) - 4 which isn‚Äôt currently being used. The specific details of how and why this happens depends on what kind of strategy you use to manage the heap. Different programs can use different ‚Äòmemory allocators‚Äô, which are libraries that manage this for you. Rust programs use jemalloc for this purpose.\n\nAnyway, back to our example. Since this memory is on the heap, it can stay alive longer than the function which allocates the box. In this case, however, it doesn‚Äôt.2 When the function is over, we need to free the stack frame for main(). Box<T>, though, has a trick up its sleeve: Drop. The implementation of Drop for Box deallocates the memory that was allocated when it was created. Great! So when x goes away, it first frees the memory allocated on the heap:\n\nAddress\tName\tValue\n1\ty\t42\n0\tx\t??????\n2\n\nWe can make the memory live longer by transferring ownership, sometimes called ‚Äòmoving out of the box‚Äô. More complex examples will be covered later.\n\nAnd then the stack frame goes away, freeing all of our memory.\n\nArguments and borrowing\n\nWe‚Äôve got some basic examples with the stack and the heap going, but what about function arguments and borrowing? Here‚Äôs a small Rust program:\n\nfn foo(i: &i32) {\n    let z = 42;\n}\n\nfn main() {\n    let x = 5;\n    let y = &x;\n\n    foo(y);\n}\n\n\nWhen we enter main(), memory looks like this:\n\nAddress\tName\tValue\n1\ty\t‚Üí 0\n0\tx\t5\n\nx is a plain old 5, and y is a reference to x. So its value is the memory location that x lives at, which in this case is 0.\n\nWhat about when we call foo(), passing y as an argument?\n\nAddress\tName\tValue\n3\tz\t42\n2\ti\t‚Üí 0\n1\ty\t‚Üí 0\n0\tx\t5\n\nStack frames aren‚Äôt only for local bindings, they‚Äôre for arguments too. So in this case, we need to have both i, our argument, and z, our local variable binding. i is a copy of the argument, y. Since y‚Äôs value is 0, so is i‚Äôs.\n\nThis is one reason why borrowing a variable doesn‚Äôt deallocate any memory: the value of a reference is a pointer to a memory location. If we got rid of the underlying memory, things wouldn‚Äôt work very well.\n\nA complex example\n\nOkay, let‚Äôs go through this complex program step-by-step:\n\nfn foo(x: &i32) {\n    let y = 10;\n    let z = &y;\n\n    baz(z);\n    bar(x, z);\n}\n\nfn bar(a: &i32, b: &i32) {\n    let c = 5;\n    let d = Box::new(5);\n    let e = &d;\n\n    baz(e);\n}\n\nfn baz(f: &i32) {\n    let g = 100;\n}\n\nfn main() {\n    let h = 3;\n    let i = Box::new(20);\n    let j = &h;\n\n    foo(j);\n}\n\n\nFirst, we call main():\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWe allocate memory for j, i, and h. i is on the heap, and so has a value pointing there.\n\nNext, at the end of main(), foo() gets called:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nSpace gets allocated for x, y, and z. The argument x has the same value as j, since that‚Äôs what we passed it in. It‚Äôs a pointer to the 0 address, since j points at h.\n\nNext, foo() calls baz(), passing z:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n7\tg\t100\n6\tf\t‚Üí 4\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWe‚Äôve allocated memory for f and g. baz() is very short, so when it‚Äôs over, we get rid of its stack frame:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nNext, foo() calls bar() with x and z:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n(230) - 2\t\t5\n...\t...\t...\n10\te\t‚Üí 9\n9\td\t‚Üí (230) - 2\n8\tc\t5\n7\tb\t‚Üí 4\n6\ta\t‚Üí 0\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWe end up allocating another value on the heap, and so we have to subtract one from (230) - 1. It‚Äôs easier to write that than 1,073,741,822. In any case, we set up the variables as usual.\n\nAt the end of bar(), it calls baz():\n\nAddress\tName\tValue\n(230) - 1\t\t20\n(230) - 2\t\t5\n...\t...\t...\n12\tg\t100\n11\tf\t‚Üí (230) - 2\n10\te\t‚Üí 9\n9\td\t‚Üí (230) - 2\n8\tc\t5\n7\tb\t‚Üí 4\n6\ta\t‚Üí 0\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nWith this, we‚Äôre at our deepest point! Whew! Congrats for following along this far.\n\nAfter baz() is over, we get rid of f and g:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n(230) - 2\t\t5\n...\t...\t...\n10\te\t‚Üí 9\n9\td\t‚Üí (230) - 2\n8\tc\t5\n7\tb\t‚Üí 4\n6\ta\t‚Üí 0\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nNext, we return from bar(). d in this case is a Box<T>, so it also frees what it points to: (230) - 2.\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n5\tz\t‚Üí 4\n4\ty\t10\n3\tx\t‚Üí 0\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nAnd after that, foo() returns:\n\nAddress\tName\tValue\n(230) - 1\t\t20\n...\t...\t...\n2\tj\t‚Üí 0\n1\ti\t‚Üí (230) - 1\n0\th\t3\n\nAnd then, finally, main(), which cleans the rest up. When i is Dropped, it will clean up the last of the heap too.\n\nWhat do other languages do?\n\nMost languages with a garbage collector heap-allocate by default. This means that every value is boxed. There are a number of reasons why this is done, but they‚Äôre out of scope for this tutorial. There are some possible optimizations that don‚Äôt make it true 100% of the time, too. Rather than relying on the stack and Drop to clean up memory, the garbage collector deals with the heap instead.\n\nWhich to use?\n\nSo if the stack is faster and easier to manage, why do we need the heap? A big reason is that Stack-allocation alone means you only have 'Last In First Out (LIFO)' semantics for reclaiming storage. Heap-allocation is strictly more general, allowing storage to be taken from and returned to the pool in arbitrary order, but at a complexity cost.\n\nGenerally, you should prefer stack allocation, and so, Rust stack-allocates by default. The LIFO model of the stack is simpler, at a fundamental level. This has two big impacts: runtime efficiency and semantic impact.\n\nRuntime Efficiency\n\nManaging the memory for the stack is trivial: The machine increments or decrements a single value, the so-called ‚Äústack pointer‚Äù. Managing memory for the heap is non-trivial: heap-allocated memory is freed at arbitrary points, and each block of heap-allocated memory can be of arbitrary size, so the memory manager must generally work much harder to identify memory for reuse.\n\nIf you‚Äôd like to dive into this topic in greater detail, this paper is a great introduction.\n\nSemantic impact\n\nStack-allocation impacts the Rust language itself, and thus the developer‚Äôs mental model. The LIFO semantics is what drives how the Rust language handles automatic memory management. Even the deallocation of a uniquely-owned heap-allocated box can be driven by the stack-based LIFO semantics, as discussed throughout this chapter. The flexibility (i.e. expressiveness) of non LIFO-semantics means that in general the compiler cannot automatically infer at compile-time where memory should be freed; it has to rely on dynamic protocols, potentially from outside the language itself, to drive deallocation (reference counting, as used by Rc<T> and Arc<T>, is one example of this).\n\nWhen taken to the extreme, the increased expressive power of heap allocation comes at the cost of either significant runtime support (e.g. in the form of a garbage collector) or significant programmer effort (in the form of explicit memory management calls that require verification not provided by the Rust compiler)."
  },
  {
    "title": "Testing - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/testing.html",
    "html": "Testing\n\nProgram testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.\n\nEdsger W. Dijkstra, \"The Humble Programmer\" (1972)\n\nLet's talk about how to test Rust code. What we will not be talking about is the right way to test Rust code. There are many schools of thought regarding the right and wrong way to write tests. All of these approaches use the same basic tools, and so we'll show you the syntax for using them.\n\nThe test attribute\n\nAt its simplest, a test in Rust is a function that's annotated with the test attribute. Let's make a new project with Cargo called adder:\n\n$ cargo new adder\n$ cd adder\n\n\nCargo will automatically generate a simple test when you make a new project. Here's the contents of src/lib.rs:\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n    }\n}\n\n\nFor now, let's remove the mod bit, and focus on just the function:\n\n#[test]\nfn it_works() {\n}\n\n\nNote the #[test]. This attribute indicates that this is a test function. It currently has no body. That's good enough to pass! We can run the tests with cargo test:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.15 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nCargo compiled and ran our tests. There are two sets of output here: one for the test we wrote, and another for documentation tests. We'll talk about those later. For now, see this line:\n\ntest it_works ... ok\n\n\nNote the it_works. This comes from the name of our function:\n\nfn it_works() {\n}\n\n\nWe also get a summary line:\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n\nSo why does our do-nothing test pass? Any test which doesn't panic! passes, and any test that does panic! fails. Let's make our test fail:\n\n#[test]\nfn it_works() {\n    assert!(false);\n}\n\n\nassert! is a macro provided by Rust which takes one argument: if the argument is true, nothing happens. If the argument is false, it will panic!. Let's run our tests again:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... FAILED\n\nfailures:\n\n---- it_works stdout ----\n        thread 'it_works' panicked at 'assertion failed: false', src/lib.rs:5\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\n\nfailures:\n    it_works\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n\nerror: test failed\n\n\nRust indicates that our test failed:\n\ntest it_works ... FAILED\n\n\nAnd that's reflected in the summary line:\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n\n\nWe also get a non-zero status code. We can use $? on macOS and Linux:\n\n$ echo $?\n101\n\n\nOn Windows, if you‚Äôre using cmd:\n\n> echo %ERRORLEVEL%\n\n\nAnd if you‚Äôre using PowerShell:\n\n> echo $LASTEXITCODE # the code itself\n> echo $? # a boolean, fail or succeed\n\n\nThis is useful if you want to integrate cargo test into other tooling.\n\nWe can invert our test's failure with another attribute: should_panic:\n\n#[test]\n#[should_panic]\nfn it_works() {\n    assert!(false);\n}\n\n\nThis test will now succeed if we panic! and fail if we complete. Let's try it:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.17 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nRust provides another macro, assert_eq!, that compares two arguments for equality:\n\n#[test]\n#[should_panic]\nfn it_works() {\n    assert_eq!(\"Hello\", \"world\");\n}\n\n\nDoes this test pass or fail? Because of the should_panic attribute, it passes:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.21 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nshould_panic tests can be fragile, as it's hard to guarantee that the test didn't fail for an unexpected reason. To help with this, an optional expected parameter can be added to the should_panic attribute. The test harness will make sure that the failure message contains the provided text. A safer version of the example above would be:\n\n#[test]\n#[should_panic(expected = \"assertion failed\")]\nfn it_works() {\n    assert_eq!(\"Hello\", \"world\");\n}\n\n\nThat's all there is to the basics! Let's write one 'real' test:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[test]\nfn it_works() {\n    assert_eq!(4, add_two(2));\n}\n\n\nThis is a very common use of assert_eq!: call some function with some known arguments and compare it to the expected output.\n\nThe ignore attribute\n\nSometimes a few specific tests can be very time-consuming to execute. These can be disabled by default by using the ignore attribute:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[test]\nfn it_works() {\n    assert_eq!(4, add_two(2));\n}\n\n#[test]\n#[ignore]\nfn expensive_test() {\n    // Code that takes an hour to run...\n}\n\n\nNow we run our tests and see that it_works is run, but expensive_test is not:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.20 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 2 tests\ntest expensive_test ... ignored\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nThe expensive tests can be run explicitly using cargo test -- --ignored:\n\n$ cargo test -- --ignored\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running target/debug/deps/adder-941f01916ca4a642\n\nrunning 1 test\ntest expensive_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nThe --ignored argument is an argument to the test binary, and not to Cargo, which is why the command is cargo test -- --ignored.\n\nThe tests module\n\nThere is one way in which our existing example is not idiomatic: it's missing the tests module. You might have noticed this test module was present in the code that was initially generated with cargo new but was missing from our last example. Let's explain what this does.\n\nThe idiomatic way of writing our example looks like this:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::add_two;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\n\nThere's a few changes here. The first is the introduction of a mod tests with a cfg attribute. The module allows us to group all of our tests together, and to also define helper functions if needed, that don't become a part of the rest of our crate. The cfg attribute only compiles our test code if we're currently trying to run the tests. This can save compile time, and also ensures that our tests are entirely left out of a normal build.\n\nThe second change is the use declaration. Because we're in an inner module, we need to bring the tested function into scope. This can be annoying if you have a large module, and so this is a common use of globs. Let's change our src/lib.rs to make use of it:\n\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\n\nNote the different use line. Now we run our tests:\n\n$ cargo test\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n     Running target/debug/deps/adder-91b3e234d4ed382a\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nIt works!\n\nThe current convention is to use the tests module to hold your \"unit-style\" tests. Anything that tests one small bit of functionality makes sense to go here. But what about \"integration-style\" tests instead? For that, we have the tests directory.\n\nThe tests directory\n\nEach file in tests/*.rs directory is treated as an individual crate. To write an integration test, let's make a tests directory and put a tests/integration_test.rs file inside with this as its contents:\n\nextern crate adder;\n\n#[test]\nfn it_works() {\n    assert_eq!(4, adder::add_two(2));\n}\n\n\nThis looks similar to our previous tests, but slightly different. We now have an extern crate adder at the top. This is because each test in the tests directory is an entirely separate crate, and so we need to import our library. This is also why tests is a suitable place to write integration-style tests: they use the library like any other consumer of it would.\n\nLet's run them:\n\n$ cargo test\n   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n     Running target/debug/deps/adder-91b3e234d4ed382a\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n     Running target/debug/integration_test-68064b69521c828a\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n\n\nNow we have three sections: our previous test is also run, as well as our new one.\n\nCargo will ignore files in subdirectories of the tests/ directory. Therefore shared modules in integrations tests are possible. For example tests/common/mod.rs is not separately compiled by cargo but can be imported in every test with mod common;\n\nThat's all there is to the tests directory. The tests module isn't needed here, since the whole thing is focused on tests.\n\nNote, when building integration tests, cargo will not pass the test attribute to the compiler. It means that all parts in cfg(test) won't be included in the build used in your integration tests.\n\nLet's finally check out that third section: documentation tests.\n\nDocumentation tests\n\nNothing is better than documentation with examples. Nothing is worse than examples that don't actually work, because the code has changed since the documentation has been written. To this end, Rust supports automatically running examples in your documentation (note: this only works in library crates, not binary crates). Here's a fleshed-out src/lib.rs with examples:\n\n//! The `adder` crate provides functions that add numbers to other numbers.\n//!\n//! # Examples\n//!\n//! ```\n//! assert_eq!(4, adder::add_two(2));\n//! ```\n\n/// This function adds two to its argument.\n///\n/// # Examples\n///\n/// ```\n/// use adder::add_two;\n///\n/// assert_eq!(4, add_two(2));\n/// ```\npub fn add_two(a: i32) -> i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\n\nNote the module-level documentation with //! and the function-level documentation with ///. Rust's documentation supports Markdown in comments, and so triple graves mark code blocks. It is conventional to include the # Examples section, exactly like that, with examples following.\n\nLet's run the tests again:\n\n$ cargo test\n   Compiling adder v0.1.0. (file:///home/you/projects/adder)\n     Running target/debug/deps/adder-91b3e234d4ed382a\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n     Running target/debug/integration_test-68064b69521c828a\n\nrunning 1 test\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n\n   Doc-tests adder\n\nrunning 2 tests\ntest add_two_0 ... ok\ntest _0 ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured\n\n\nNow we have all three kinds of tests running! Note the names of the documentation tests: the _0 is generated for the module test, and add_two_0 for the function test. These will auto increment with names like add_two_1 as you add more examples.\n\nWe haven‚Äôt covered all of the details with writing documentation tests. For more, please see the Documentation chapter.\n\nTesting and concurrency\n\nIt is important to note that tests are run concurrently using threads. For this reason, care should be taken to ensure your tests do not depend on each-other, or on any shared state. \"Shared state\" can also include the environment, such as the current working directory, or environment variables.\n\nIf this is an issue it is possible to control this concurrency, either by setting the environment variable RUST_TEST_THREADS, or by passing the argument --test-threads to the tests:\n\n$ RUST_TEST_THREADS=1 cargo test   # Run tests with no concurrency\n...\n$ cargo test -- --test-threads=1   # Same as above\n...\n\nTest output\n\nBy default Rust's test library captures and discards output to standard out/error, e.g. output from println!(). This too can be controlled using the environment or a switch:\n\n$ RUST_TEST_NOCAPTURE=1 cargo test   # Preserve stdout/stderr\n...\n$ cargo test -- --nocapture          # Same as above\n...\n\n\nHowever a better method avoiding capture is to use logging rather than raw output. Rust has a standard logging API, which provides a frontend to multiple logging implementations. This can be used in conjunction with the default env_logger to output any debugging information in a manner that can be controlled at runtime."
  },
  {
    "title": "Effective Rust - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/effective-rust.html",
    "html": "Effective Rust\n\nSo you‚Äôve learned how to write some Rust code. But there‚Äôs a difference between writing any Rust code and writing good Rust code.\n\nThis chapter consists of relatively independent tutorials which show you how to take your Rust to the next level. Common patterns and standard library features will be introduced. Read these sections in any order of your choosing."
  },
  {
    "title": "unsafe - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/unsafe.html",
    "html": "Unsafe\n\nRust‚Äôs main draw is its powerful static guarantees about behavior. But safety checks are conservative by nature: there are some programs that are actually safe, but the compiler is not able to verify this is true. To write these kinds of programs, we need to tell the compiler to relax its restrictions a bit. For this, Rust has a keyword, unsafe. Code using unsafe has fewer restrictions than normal code does.\n\nLet‚Äôs go over the syntax, and then we‚Äôll talk semantics. unsafe is used in four contexts. The first one is to mark a function as unsafe:\n\n\nunsafe fn danger_will_robinson() {\n    // Scary stuff...\n}\n\nAll functions called from FFI must be marked as unsafe, for example. The second use of unsafe is an unsafe block:\n\n\nunsafe {\n    // Scary stuff...\n}\n\nThe third is for unsafe traits:\n\n\nunsafe trait Scary { }\n\nAnd the fourth is for implementing one of those traits:\n\n\nunsafe impl Scary for i32 {}\n\nIt‚Äôs important to be able to explicitly delineate code that may have bugs that cause big problems. If a Rust program segfaults, you can be sure the cause is related to something marked unsafe.\n\nWhat does ‚Äòsafe‚Äô mean?\n\nSafe, in the context of Rust, means ‚Äòdoesn‚Äôt do anything unsafe‚Äô. It‚Äôs also important to know that there are certain behaviors that are probably not desirable in your code, but are expressly not unsafe:\n\nDeadlocks\nLeaks of memory or other resources\nExiting without calling destructors\nInteger overflow\n\nRust cannot prevent all kinds of software problems. Buggy code can and will be written in Rust. These things aren‚Äôt great, but they don‚Äôt qualify as unsafe specifically.\n\nIn addition, the following are all undefined behaviors in Rust, and must be avoided, even when writing unsafe code:\n\nData races\nDereferencing a NULL/dangling raw pointer\nReads of undef (uninitialized) memory\nBreaking the pointer aliasing rules with raw pointers.\n&mut T and &T follow LLVM‚Äôs scoped noalias model, except if the &T contains an UnsafeCell<U>. Unsafe code must not violate these aliasing guarantees.\nMutating an immutable value/reference without UnsafeCell<U>\nInvoking undefined behavior via compiler intrinsics:\nIndexing outside of the bounds of an object with std::ptr::offset (offset intrinsic), with the exception of one byte past the end which is permitted.\nUsing std::ptr::copy_nonoverlapping_memory (memcpy32/memcpy64 intrinsics) on overlapping buffers\nInvalid values in primitive types, even in private fields/locals:\nNULL/dangling references or boxes\nA value other than false (0) or true (1) in a bool\nA discriminant in an enum not included in its type definition\nA value in a char which is a surrogate or above char::MAX\nNon-UTF-8 byte sequences in a str\nUnwinding into Rust from foreign code or unwinding from Rust into foreign code.\nUnsafe Superpowers\n\nIn both unsafe functions and unsafe blocks, Rust will let you do three things that you normally can not do. Just three. Here they are:\n\nAccess or update a static mutable variable.\nDereference a raw pointer.\nCall unsafe functions. This is the most powerful ability.\n\nThat‚Äôs it. It‚Äôs important that unsafe does not, for example, ‚Äòturn off the borrow checker‚Äô. Adding unsafe to some random Rust code doesn‚Äôt change its semantics, it won‚Äôt start accepting anything. But it will let you write things that do break some of the rules.\n\nYou will also encounter the unsafe keyword when writing bindings to foreign (non-Rust) interfaces. You're encouraged to write a safe, native Rust interface around the methods provided by the library.\n\nLet‚Äôs go over the basic three abilities listed, in order.\n\nAccess or update a static mut\n\nRust has a feature called ‚Äòstatic mut‚Äô which allows for mutable global state. Doing so can cause a data race, and as such is inherently not safe. For more details, see the static section of the book.\n\nDereference a raw pointer\n\nRaw pointers let you do arbitrary pointer arithmetic, and can cause a number of different memory safety and security issues. In some senses, the ability to dereference an arbitrary pointer is one of the most dangerous things you can do. For more on raw pointers, see their section of the book.\n\nCall unsafe functions\n\nThis last ability works with both aspects of unsafe: you can only call functions marked unsafe from inside an unsafe block.\n\nThis ability is powerful and varied. Rust exposes some compiler intrinsics as unsafe functions, and some unsafe functions bypass safety checks, trading safety for speed.\n\nI‚Äôll repeat again: even though you can do arbitrary things in unsafe blocks and functions doesn‚Äôt mean you should. The compiler will act as though you‚Äôre upholding its invariants, so be careful!"
  },
  {
    "title": "Raw Pointers - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/raw-pointers.html",
    "html": "Raw Pointers\n\nRust has a number of different smart pointer types in its standard library, but there are two types that are extra-special. Much of Rust‚Äôs safety comes from compile-time checks, but raw pointers don‚Äôt have such guarantees, and are unsafe to use.\n\n*const T and *mut T are called ‚Äòraw pointers‚Äô in Rust. Sometimes, when writing certain kinds of libraries, you‚Äôll need to get around Rust‚Äôs safety guarantees for some reason. In this case, you can use raw pointers to implement your library, while exposing a safe interface for your users. For example, * pointers are allowed to alias, allowing them to be used to write shared-ownership types, and even thread-safe shared memory types (the Rc<T> and Arc<T> types are both implemented entirely in Rust).\n\nHere are some things to remember about raw pointers that are different than other pointer types. They:\n\nare not guaranteed to point to valid memory and are not even guaranteed to be non-NULL (unlike both Box and &);\ndo not have any automatic clean-up, unlike Box, and so require manual resource management;\nare plain-old-data, that is, they don't move ownership, again unlike Box, hence the Rust compiler cannot protect against bugs like use-after-free;\nlack any form of lifetimes, unlike &, and so the compiler cannot reason about dangling pointers; and\nhave no guarantees about aliasing or mutability other than mutation not being allowed directly through a *const T.\nBasics\n\nCreating a raw pointer is perfectly safe:\n\n\nlet x = 5;\nlet raw = &x as *const i32;\n\nlet mut y = 10;\nlet raw_mut = &mut y as *mut i32;\n\nHowever, dereferencing one is not. This won‚Äôt work:\n\nlet x = 5;\nlet raw = &x as *const i32;\n\nprintln!(\"raw points at {}\", *raw);\n\n\nIt gives this error:\n\nerror: dereference of raw pointer requires unsafe function or block [E0133]\n     println!(\"raw points at {}\", *raw);\n                                  ^~~~\n\n\nWhen you dereference a raw pointer, you‚Äôre taking responsibility that it‚Äôs not pointing somewhere that would be incorrect. As such, you need unsafe:\n\n\nlet x = 5;\nlet raw = &x as *const i32;\n\nlet points_at = unsafe { *raw };\n\nprintln!(\"raw points at {}\", points_at);\n\nFor more operations on raw pointers, see their API documentation.\n\nFFI\n\nRaw pointers are useful for FFI: Rust‚Äôs *const T and *mut T are similar to C‚Äôs const T* and T*, respectively. For more about this use, consult the FFI chapter.\n\nReferences and raw pointers\n\nAt runtime, a raw pointer * and a reference pointing to the same piece of data have an identical representation. In fact, an &T reference will implicitly coerce to an *const T raw pointer in safe code and similarly for the mut variants (both coercions can be performed explicitly with, respectively, value as *const T and value as *mut T).\n\nGoing the opposite direction, from *const to a reference &, is not safe. A &T is always valid, and so, at a minimum, the raw pointer *const T has to point to a valid instance of type T. Furthermore, the resulting pointer must satisfy the aliasing and mutability laws of references. The compiler assumes these properties are true for any references, no matter how they are created, and so any conversion from raw pointers is asserting that they hold. The programmer must guarantee this.\n\nThe recommended method for the conversion is:\n\n\n// Explicit cast:\nlet i: u32 = 1;\nlet p_imm: *const u32 = &i as *const u32;\n\n// Implicit coercion:\nlet mut m: u32 = 2;\nlet p_mut: *mut u32 = &mut m;\n\nunsafe {\n    let ref_imm: &u32 = &*p_imm;\n    let ref_mut: &mut u32 = &mut *p_mut;\n}\n\nThe &*x dereferencing style is preferred to using a transmute. The latter is far more powerful than necessary, and the more restricted operation is harder to use incorrectly; for example, it requires that x is a pointer (unlike transmute)."
  },
  {
    "title": "Macros - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/macros.html",
    "html": "Macros\n\nBy now you‚Äôve learned about many of the tools Rust provides for abstracting and reusing code. These units of code reuse have a rich semantic structure. For example, functions have a type signature, type parameters have trait bounds, and overloaded functions must belong to a particular trait.\n\nThis structure means that Rust‚Äôs core abstractions have powerful compile-time correctness checking. But this comes at the price of reduced flexibility. If you visually identify a pattern of repeated code, you may find it‚Äôs difficult or cumbersome to express that pattern as a generic function, a trait, or anything else within Rust‚Äôs semantics.\n\nMacros allow us to abstract at a syntactic level. A macro invocation is shorthand for an \"expanded\" syntactic form. This expansion happens early in compilation, before any static checking. As a result, macros can capture many patterns of code reuse that Rust‚Äôs core abstractions cannot.\n\nThe drawback is that macro-based code can be harder to understand, because fewer of the built-in rules apply. Like an ordinary function, a well-behaved macro can be used without understanding its implementation. However, it can be difficult to design a well-behaved macro! Additionally, compiler errors in macro code are harder to interpret, because they describe problems in the expanded code, not the source-level form that developers use.\n\nThese drawbacks make macros something of a \"feature of last resort\". That‚Äôs not to say that macros are bad; they are part of Rust because sometimes they‚Äôre needed for truly concise, well-abstracted code. Just keep this tradeoff in mind.\n\nDefining a macro\n\nYou may have seen the vec! macro, used to initialize a vector with any number of elements.\n\n\nlet x: Vec<u32> = vec![1, 2, 3];\n\nThis can‚Äôt be an ordinary function, because it takes any number of arguments. But we can imagine it as syntactic shorthand for\n\n\nlet x: Vec<u32> = {\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n};\n\nWe can implement this shorthand, using a macro: 1\n\n1\n\nThe actual definition of vec! in libcollections differs from the one presented here, for reasons of efficiency and reusability.\n\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n\n\nWhoa, that‚Äôs a lot of new syntax! Let‚Äôs break it down.\n\nmacro_rules! vec { ... }\n\n\nThis says we‚Äôre defining a macro named vec, much as fn vec would define a function named vec. In prose, we informally write a macro‚Äôs name with an exclamation point, e.g. vec!. The exclamation point is part of the invocation syntax and serves to distinguish a macro from an ordinary function.\n\nMatching\n\nThe macro is defined through a series of rules, which are pattern-matching cases. Above, we had\n\n( $( $x:expr ),* ) => { ... };\n\n\nThis is like a match expression arm, but the matching happens on Rust syntax trees, at compile time. The semicolon is optional on the last (here, only) case. The \"pattern\" on the left-hand side of => is known as a ‚Äòmatcher‚Äô. These have their own little grammar within the language.\n\nThe matcher $x:expr will match any Rust expression, binding that syntax tree to the ‚Äòmetavariable‚Äô $x. The identifier expr is a ‚Äòfragment specifier‚Äô; the full possibilities are enumerated later in this chapter. Surrounding the matcher with $(...),* will match zero or more expressions, separated by commas.\n\nAside from the special matcher syntax, any Rust tokens that appear in a matcher must match exactly. For example,\n\nmacro_rules! foo {\n    (x => $e:expr) => (println!(\"mode X: {}\", $e));\n    (y => $e:expr) => (println!(\"mode Y: {}\", $e));\n}\n\nfn main() {\n    foo!(y => 3);\n}\n\n\nwill print\n\nmode Y: 3\n\n\nWith\n\nfoo!(z => 3);\n\n\nwe get the compiler error\n\nerror: no rules expected the token `z`\n\nExpansion\n\nThe right-hand side of a macro rule is ordinary Rust syntax, for the most part. But we can splice in bits of syntax captured by the matcher. From the original example:\n\n$(\n    temp_vec.push($x);\n)*\n\n\nEach matched expression $x will produce a single push statement in the macro expansion. The repetition in the expansion proceeds in \"lockstep\" with repetition in the matcher (more on this in a moment).\n\nBecause $x was already declared as matching an expression, we don‚Äôt repeat :expr on the right-hand side. Also, we don‚Äôt include a separating comma as part of the repetition operator. Instead, we have a terminating semicolon within the repeated block.\n\nAnother detail: the vec! macro has two pairs of braces on the right-hand side. They are often combined like so:\n\nmacro_rules! foo {\n    () => {{\n        ...\n    }}\n}\n\n\nThe outer braces are part of the syntax of macro_rules!. In fact, you can use () or [] instead. They simply delimit the right-hand side as a whole.\n\nThe inner braces are part of the expanded syntax. Remember, the vec! macro is used in an expression context. To write an expression with multiple statements, including let-bindings, we use a block. If your macro expands to a single expression, you don‚Äôt need this extra layer of braces.\n\nNote that we never declared that the macro produces an expression. In fact, this is not determined until we use the macro as an expression. With care, you can write a macro whose expansion works in several contexts. For example, shorthand for a data type could be valid as either an expression or a pattern.\n\nRepetition\n\nThe repetition operator follows two principal rules:\n\n$(...)* walks through one \"layer\" of repetitions, for all of the $names it contains, in lockstep, and\neach $name must be under at least as many $(...)*s as it was matched against. If it is under more, it‚Äôll be duplicated, as appropriate.\n\nThis baroque macro illustrates the duplication of variables from outer repetition levels.\n\nmacro_rules! o_O {\n    (\n        $(\n            $x:expr; [ $( $y:expr ),* ]\n        );*\n    ) => {\n        &[ $($( $x + $y ),*),* ]\n    }\n}\n\nfn main() {\n    let a: &[i32]\n        = o_O!(10; [1, 2, 3];\n               20; [4, 5, 6]);\n\n    assert_eq!(a, [11, 12, 13, 24, 25, 26]);\n}\n\n\nThat‚Äôs most of the matcher syntax. These examples use $(...)*, which is a \"zero or more\" match. Alternatively you can write $(...)+ for a \"one or more\" match. Both forms optionally include a separator, which can be any token except + or *.\n\nThis system is based on \"Macro-by-Example\" (PDF link).\n\nHygiene\n\nSome languages implement macros using simple text substitution, which leads to various problems. For example, this C program prints 13 instead of the expected 25.\n\n#define FIVE_TIMES(x) 5 * x\n\nint main() {\n    printf(\"%d\\n\", FIVE_TIMES(2 + 3));\n    return 0;\n}\n\n\nAfter expansion we have 5 * 2 + 3, and multiplication has greater precedence than addition. If you‚Äôve used C macros a lot, you probably know the standard idioms for avoiding this problem, as well as five or six others. In Rust, we don‚Äôt have to worry about it.\n\nmacro_rules! five_times {\n    ($x:expr) => (5 * $x);\n}\n\nfn main() {\n    assert_eq!(25, five_times!(2 + 3));\n}\n\n\nThe metavariable $x is parsed as a single expression node, and keeps its place in the syntax tree even after substitution.\n\nAnother common problem in macro systems is ‚Äòvariable capture‚Äô. Here‚Äôs a C macro using a block with multiple statements.\n\n#define LOG(msg) do { \\\n    int state = get_log_state(); \\\n    if (state > 0) { \\\n        printf(\"log(%d): %s\\n\", state, msg); \\\n    } \\\n} while (0)\n\n\nHere‚Äôs a simple use case that goes terribly wrong:\n\nconst char *state = \"reticulating splines\";\nLOG(state);\n\n\nThis expands to\n\nconst char *state = \"reticulating splines\";\ndo {\n    int state = get_log_state();\n    if (state > 0) {\n        printf(\"log(%d): %s\\n\", state, state);\n    }\n} while (0);\n\n\nThe second variable named state shadows the first one. This is a problem because the print statement should refer to both of them.\n\nThe equivalent Rust macro has the desired behavior.\n\nmacro_rules! log {\n    ($msg:expr) => {{\n        let state: i32 = get_log_state();\n        if state > 0 {\n            println!(\"log({}): {}\", state, $msg);\n        }\n    }};\n}\n\nfn main() {\n    let state: &str = \"reticulating splines\";\n    log!(state);\n}\n\n\nThis works because Rust has a hygienic macro system. Each macro expansion happens in a distinct ‚Äòsyntax context‚Äô, and each variable is tagged with the syntax context where it was introduced. It‚Äôs as though the variable state inside main is painted a different \"color\" from the variable state inside the macro, and therefore they don‚Äôt conflict.\n\nThis also restricts the ability of macros to introduce new bindings at the invocation site. Code such as the following will not work:\n\nmacro_rules! foo {\n    () => (let x = 3;);\n}\n\nfn main() {\n    foo!();\n    println!(\"{}\", x);\n}\n\n\nInstead you need to pass the variable name into the invocation, so that it‚Äôs tagged with the right syntax context.\n\nmacro_rules! foo {\n    ($v:ident) => (let $v = 3;);\n}\n\nfn main() {\n    foo!(x);\n    println!(\"{}\", x);\n}\n\n\nThis holds for let bindings and loop labels, but not for items. So the following code does compile:\n\nmacro_rules! foo {\n    () => (fn x() { });\n}\n\nfn main() {\n    foo!();\n    x();\n}\n\nRecursive macros\n\nA macro‚Äôs expansion can include more macro invocations, including invocations of the very same macro being expanded. These recursive macros are useful for processing tree-structured input, as illustrated by this (simplistic) HTML shorthand:\n\nmacro_rules! write_html {\n    ($w:expr, ) => (());\n\n    ($w:expr, $e:tt) => (write!($w, \"{}\", $e));\n\n    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{\n        write!($w, \"<{}>\", stringify!($tag));\n        write_html!($w, $($inner)*);\n        write!($w, \"</{}>\", stringify!($tag));\n        write_html!($w, $($rest)*);\n    }};\n}\n\nfn main() {\n    use std::fmt::Write;\n    let mut out = String::new();\n\n    write_html!(&mut out,\n        html[\n            head[title[\"Macros guide\"]]\n            body[h1[\"Macros are the best!\"]]\n        ]);\n\n    assert_eq!(out,\n        \"<html><head><title>Macros guide</title></head>\\\n         <body><h1>Macros are the best!</h1></body></html>\");\n}\n\nDebugging macro code\n\nTo see the results of expanding macros, run rustc --pretty expanded. The output represents a whole crate, so you can also feed it back in to rustc, which will sometimes produce better error messages than the original compilation. Note that the --pretty expanded output may have a different meaning if multiple variables of the same name (but different syntax contexts) are in play in the same scope. In this case --pretty expanded,hygiene will tell you about the syntax contexts.\n\nrustc provides two syntax extensions that help with macro debugging. For now, they are unstable and require feature gates.\n\nlog_syntax!(...) will print its arguments to standard output, at compile time, and \"expand\" to nothing.\n\ntrace_macros!(true) will enable a compiler message every time a macro is expanded. Use trace_macros!(false) later in expansion to turn it off.\n\nSyntactic requirements\n\nEven when Rust code contains un-expanded macros, it can be parsed as a full syntax tree. This property can be very useful for editors and other tools that process code. It also has a few consequences for the design of Rust‚Äôs macro system.\n\nOne consequence is that Rust must determine, when it parses a macro invocation, whether the macro stands in for\n\nzero or more items,\nzero or more methods,\nan expression,\na statement, or\na pattern.\n\nA macro invocation within a block could stand for some items, or for an expression / statement. Rust uses a simple rule to resolve this ambiguity. A macro invocation that stands for items must be either\n\ndelimited by curly braces, e.g. foo! { ... }, or\nterminated by a semicolon, e.g. foo!(...);\n\nAnother consequence of pre-expansion parsing is that the macro invocation must consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces must be balanced within a macro invocation. For example, foo!([) is forbidden. This allows Rust to know where the macro invocation ends.\n\nMore formally, the macro invocation body must be a sequence of ‚Äòtoken trees‚Äô. A token tree is defined recursively as either\n\na sequence of token trees surrounded by matching (), [], or {}, or\nany other single token.\n\nWithin a matcher, each metavariable has a ‚Äòfragment specifier‚Äô, identifying which syntactic form it matches.\n\nident: an identifier. Examples: x; foo.\npath: a qualified name. Example: T::SpecialA.\nexpr: an expression. Examples: 2 + 2; if true { 1 } else { 2 }; f(42).\nty: a type. Examples: i32; Vec<(char, String)>; &T.\npat: a pattern. Examples: Some(t); (17, 'a'); _.\nstmt: a single statement. Example: let x = 3.\nblock: a brace-delimited sequence of statements and optionally an expression. Example: { log(error, \"hi\"); return 12; }.\nitem: an item. Examples: fn foo() { }; struct Bar;.\nmeta: a \"meta item\", as found in attributes. Example: cfg(target_os = \"windows\").\ntt: a single token tree.\n\nThere are additional rules regarding the next token after a metavariable:\n\nexpr and stmt variables may only be followed by one of: => , ;\nty and path variables may only be followed by one of: => , = | ; : > [ { as where\npat variables may only be followed by one of: => , = | if in\nOther variables may be followed by any token.\n\nThese rules provide some flexibility for Rust‚Äôs syntax to evolve without breaking existing macros.\n\nThe macro system does not deal with parse ambiguity at all. For example, the grammar $($i:ident)* $e:expr will always fail to parse, because the parser would be forced to choose between parsing $i and parsing $e. Changing the invocation syntax to put a distinctive token in front can solve the problem. In this case, you can write $(I $i:ident)* E $e:expr.\n\nScoping and macro import/export\n\nMacros are expanded at an early stage in compilation, before name resolution. One downside is that scoping works differently for macros, compared to other constructs in the language.\n\nDefinition and expansion of macros both happen in a single depth-first, lexical-order traversal of a crate‚Äôs source. So a macro defined at module scope is visible to any subsequent code in the same module, which includes the body of any subsequent child mod items. If you want to use your macro, which is defined in a different module, you need to use macro_use attribute before using the macro. Let's say our macros are defined in module macros and we would like to use them inside module client. This is the required module definition order:\n\n\n#[macro_use]\nmod macros;\nmod client;\n\nThe opposite order would result in a compilation failure:\n\n\nmod client;\n#[macro_use]\nmod macros;\nerror: cannot find macro `my_macro!` in this scope\n\n\nA macro defined within the body of a single fn, or anywhere else not at module scope, is visible only within that item.\n\nIf a module has the macro_use attribute, its macros are also visible in its parent module after the child‚Äôs mod item. If the parent also has macro_use then the macros will be visible in the grandparent after the parent‚Äôs mod item, and so forth.\n\nThe macro_use attribute can also appear on extern crate. In this context it controls which macros are loaded from the external crate, e.g.\n\n#[macro_use(foo, bar)]\nextern crate baz;\n\n\nIf the attribute is given simply as #[macro_use], all macros are loaded. If there is no #[macro_use] attribute then no macros are loaded. Only macros defined with the #[macro_export] attribute may be loaded.\n\nTo load a crate‚Äôs macros without linking it into the output, use #[no_link] as well.\n\nAn example:\n\nmacro_rules! m1 { () => (()) }\n\n// Visible here: `m1`.\n\nmod foo {\n    // Visible here: `m1`.\n\n    #[macro_export]\n    macro_rules! m2 { () => (()) }\n\n    // Visible here: `m1`, `m2`.\n}\n\n// Visible here: `m1`.\n\nmacro_rules! m3 { () => (()) }\n\n// Visible here: `m1`, `m3`.\n\n#[macro_use]\nmod bar {\n    // Visible here: `m1`, `m3`.\n\n    macro_rules! m4 { () => (()) }\n\n    // Visible here: `m1`, `m3`, `m4`.\n}\n\n// Visible here: `m1`, `m3`, `m4`.\n\n\nWhen this library is loaded with #[macro_use] extern crate, only m2 will be imported.\n\nThe Rust Reference has a listing of macro-related attributes.\n\nThe variable $crate\n\nA further difficulty occurs when a macro is used in multiple crates. Say that mylib defines\n\npub fn increment(x: u32) -> u32 {\n    x + 1\n}\n\n#[macro_export]\nmacro_rules! inc_a {\n    ($x:expr) => ( ::increment($x) )\n}\n\n#[macro_export]\nmacro_rules! inc_b {\n    ($x:expr) => ( ::mylib::increment($x) )\n}\n\n\ninc_a only works within mylib, while inc_b only works outside the library. Furthermore, inc_b will break if the user imports mylib under another name.\n\nRust does not (yet) have a hygiene system for crate references, but it does provide a simple workaround for this problem. Within a macro imported from a crate named foo, the special macro variable $crate will expand to ::foo. By contrast, when a macro is defined and then used in the same crate, $crate will expand to nothing. This means we can write\n\n#[macro_export]\nmacro_rules! inc {\n    ($x:expr) => ( $crate::increment($x) )\n}\n\n\nto define a single macro that works both inside and outside our library. The function name will expand to either ::increment or ::mylib::increment.\n\nTo keep this system simple and correct, #[macro_use] extern crate ... may only appear at the root of your crate, not inside mod.\n\nThe deep end\n\nThe introductory chapter mentioned recursive macros, but it did not give the full story. Recursive macros are useful for another reason: Each recursive invocation gives you another opportunity to pattern-match the macro‚Äôs arguments.\n\nAs an extreme example, it is possible, though hardly advisable, to implement the Bitwise Cyclic Tag automaton within Rust‚Äôs macro system.\n\n\nmacro_rules! bct {\n    // cmd 0:  d ... => ...\n    (0, $($ps:tt),* ; $_d:tt)\n        => (bct!($($ps),*, 0 ; ));\n    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n        => (bct!($($ps),*, 0 ; $($ds),*));\n\n    // cmd 1p:  1 ... => 1 ... p\n    (1, $p:tt, $($ps:tt),* ; 1)\n        => (bct!($($ps),*, 1, $p ; 1, $p));\n    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n\n    // cmd 1p:  0 ... => 0 ...\n    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n        => (bct!($($ps),*, 1, $p ; $($ds),*));\n\n    // Halt on empty data string:\n    ( $($ps:tt),* ; )\n        => (());\n}\n\nExercise: use macros to reduce duplication in the above definition of the bct! macro.\n\nCommon macros\n\nHere are some common macros you‚Äôll see in Rust code.\n\npanic!\n\nThis macro causes the current thread to panic. You can give it a message to panic with:\n\n\npanic!(\"oh no!\");\nvec!\n\nThe vec! macro is used throughout the book, so you‚Äôve probably seen it already. It creates Vec<T>s with ease:\n\n\nlet v = vec![1, 2, 3, 4, 5];\n\nIt also lets you make vectors with repeating values. For example, a hundred zeroes:\n\n\nlet v = vec![0; 100];\nassert! and assert_eq!\n\nThese two macros are used in tests. assert! takes a boolean. assert_eq! takes two values and checks them for equality. true passes, false panic!s. Like this:\n\n\n// A-ok!\n\nassert!(true);\nassert_eq!(5, 3 + 2);\n\n// Nope :(\n\nassert!(5 < 3);\nassert_eq!(5, 3);\ntry!\n\ntry! is used for error handling. It takes something that can return a Result<T, E>, and gives T if it‚Äôs a Ok<T>, and returns with the Err(E) if it‚Äôs that. Like this:\n\n\nuse std::fs::File;\n\nfn foo() -> std::io::Result<()> {\n    let f = try!(File::create(\"foo.txt\"));\n\n    Ok(())\n}\n\nThis is cleaner than doing this:\n\n\nuse std::fs::File;\n\nfn foo() -> std::io::Result<()> {\n    let f = File::create(\"foo.txt\");\n\n    let f = match f {\n        Ok(t) => t,\n        Err(e) => return Err(e),\n    };\n\n    Ok(())\n}\nunreachable!\n\nThis macro is used when you think some code should never execute:\n\n\nif false {\n    unreachable!();\n}\n\nSometimes, the compiler may make you have a different branch that you know will never, ever run. In these cases, use this macro, so that if you end up wrong, you‚Äôll get a panic! about it.\n\n\nlet x: Option<i32> = None;\n\nmatch x {\n    Some(_) => unreachable!(),\n    None => println!(\"I know x is None!\"),\n}\nunimplemented!\n\nThe unimplemented! macro can be used when you‚Äôre trying to get your functions to typecheck, and don‚Äôt want to worry about writing out the body of the function. One example of this situation is implementing a trait with multiple required methods, where you want to tackle one at a time. Define the others as unimplemented! until you‚Äôre ready to write them."
  },
  {
    "title": "Deref coercions - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/deref-coercions.html",
    "html": "Deref coercions\n\nThe standard library provides a special trait, Deref. It‚Äôs normally used to overload *, the dereference operator:\n\nuse std::ops::Deref;\n\nstruct DerefExample<T> {\n    value: T,\n}\n\nimpl<T> Deref for DerefExample<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &self.value\n    }\n}\n\nfn main() {\n    let x = DerefExample { value: 'a' };\n    assert_eq!('a', *x);\n}\n\n\nThis is useful for writing custom pointer types. However, there‚Äôs a language feature related to Deref: ‚Äòderef coercions‚Äô. Here‚Äôs the rule: If you have a type U, and it implements Deref<Target=T>, values of &U will automatically coerce to a &T. Here‚Äôs an example:\n\n\nfn foo(s: &str) {\n    // Borrow a string for a second.\n}\n\n// String implements Deref<Target=str>.\nlet owned = \"Hello\".to_string();\n\n// Therefore, this works:\nfoo(&owned);\n\nUsing an ampersand in front of a value takes a reference to it. So owned is a String, &owned is an &String, and since impl Deref<Target=str> for String, &String will deref to &str, which foo() takes.\n\nThat‚Äôs it. This rule is one of the only places in which Rust does an automatic conversion for you, but it adds a lot of flexibility. For example, the Rc<T> type implements Deref<Target=T>, so this works:\n\n\nuse std::rc::Rc;\n\nfn foo(s: &str) {\n    // Borrow a string for a second.\n}\n\n// String implements Deref<Target=str>.\nlet owned = \"Hello\".to_string();\nlet counted = Rc::new(owned);\n\n// Therefore, this works:\nfoo(&counted);\n\nAll we‚Äôve done is wrap our String in an Rc<T>. But we can now pass the Rc<String> around anywhere we‚Äôd have a String. The signature of foo didn‚Äôt change, but works just as well with either type. This example has two conversions: &Rc<String> to &String and then &String to &str. Rust will do this as many times as possible until the types match.\n\nAnother very common implementation provided by the standard library is:\n\n\nfn foo(s: &[i32]) {\n    // Borrow a slice for a second.\n}\n\n// Vec<T> implements Deref<Target=[T]>.\nlet owned = vec![1, 2, 3];\n\nfoo(&owned);\n\nVectors can Deref to a slice.\n\nDeref and method calls\n\nDeref will also kick in when calling a method. Consider the following example.\n\n\nstruct Foo;\n\nimpl Foo {\n    fn foo(&self) { println!(\"Foo\"); }\n}\n\nlet f = &&Foo;\n\nf.foo();\n\nEven though f is a &&Foo and foo takes &self, this works. That‚Äôs because these things are the same:\n\nf.foo();\n(&f).foo();\n(&&f).foo();\n(&&&&&&&&f).foo();\n\n\nA value of type &&&&&&&&&&&&&&&&Foo can still have methods defined on Foo called, because the compiler will insert as many * operations as necessary to get it right. And since it‚Äôs inserting *s, that uses Deref."
  },
  {
    "title": "Operators and Overloading - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/operators-and-overloading.html",
    "html": "Operators and Overloading\n\nRust allows for a limited form of operator overloading. There are certain operators that are able to be overloaded. To support a particular operator between types, there‚Äôs a specific trait that you can implement, which then overloads the operator.\n\nFor example, the + operator can be overloaded with the Add trait:\n\nuse std::ops::Add;\n\n#[derive(Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point { x: self.x + other.x, y: self.y + other.y }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 1, y: 0 };\n    let p2 = Point { x: 2, y: 3 };\n\n    let p3 = p1 + p2;\n\n    println!(\"{:?}\", p3);\n}\n\n\nIn main, we can use + on our two Points, since we‚Äôve implemented Add<Output=Point> for Point.\n\nThere are a number of operators that can be overloaded this way, and all of their associated traits live in the std::ops module. Check out its documentation for the full list.\n\nImplementing these traits follows a pattern. Let‚Äôs look at Add in more detail:\n\n\npub trait Add<RHS = Self> {\n    type Output;\n\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\nThere‚Äôs three types in total involved here: the type you impl Add for, RHS, which defaults to Self, and Output. For an expression let z = x + y, x is the Self type, y is the RHS, and z is the Self::Output type.\n\n\nimpl Add<i32> for Point {\n    type Output = f64;\n\n    fn add(self, rhs: i32) -> f64 {\n        // Add an i32 to a Point and get an f64.\n    }\n}\n\nwill let you do this:\n\nlet p: Point = // ...\nlet x: f64 = p + 2i32;\n\nUsing operator traits in generic structs\n\nNow that we know how operator traits are defined, we can define our HasArea trait and Square struct from the traits chapter more generically:\n\nuse std::ops::Mul;\n\ntrait HasArea<T> {\n    fn area(&self) -> T;\n}\n\nstruct Square<T> {\n    x: T,\n    y: T,\n    side: T,\n}\n\nimpl<T> HasArea<T> for Square<T>\n        where T: Mul<Output=T> + Copy {\n    fn area(&self) -> T {\n        self.side * self.side\n    }\n}\n\nfn main() {\n    let s = Square {\n        x: 0.0f64,\n        y: 0.0f64,\n        side: 12.0f64,\n    };\n\n    println!(\"Area of s: {}\", s.area());\n}\n\n\nFor HasArea and Square, we declare a type parameter T and replace f64 with it. The impl needs more involved modifications:\n\nimpl<T> HasArea<T> for Square<T>\n        where T: Mul<Output=T> + Copy { ... }\n\n\nThe area method requires that we can multiply the sides, so we declare that type T must implement std::ops::Mul. Like Add, mentioned above, Mul itself takes an Output parameter: since we know that numbers don't change type when multiplied, we also set it to T. T must also support copying, so Rust doesn't try to move self.side into the return value."
  },
  {
    "title": "Unsized Types - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/unsized-types.html",
    "html": "Unsized Types\n\nMost types have a particular size, in bytes, that is knowable at compile time. For example, an i32 is thirty-two bits big, or four bytes. However, there are some types which are useful to express, but do not have a defined size. These are called ‚Äòunsized‚Äô or ‚Äòdynamically sized‚Äô types. One example is [T]. This type represents a certain number of T in sequence. But we don‚Äôt know how many there are, so the size is not known.\n\nRust understands a few of these types, but they have some restrictions. There are three:\n\nWe can only manipulate an instance of an unsized type via a pointer. An &[T] works fine, but a [T] does not.\nVariables and arguments cannot have dynamically sized types.\nOnly the last field in a struct may have a dynamically sized type; the other fields must not. Enum variants must not have dynamically sized types as data.\n\nSo why bother? Well, because [T] can only be used behind a pointer, if we didn‚Äôt have language support for unsized types, it would be impossible to write this:\n\nimpl Foo for str {\n\n\nor\n\nimpl<T> Foo for [T] {\n\n\nInstead, you would have to write:\n\nimpl Foo for &str {\n\n\nMeaning, this implementation would only work for references, and not other types of pointers. With the impl for str, all pointers, including (at some point, there are some bugs to fix first) user-defined custom smart pointers, can use this impl.\n\n?Sized\n\nIf you want to write a function that accepts a dynamically sized type, you can use the special bound syntax, ?Sized:\n\n\nstruct Foo<T: ?Sized> {\n    f: T,\n}\n\nThis ?Sized, read as ‚ÄúT may or may not be Sized‚Äù, which allows us to match both sized and unsized types. All generic type parameters implicitly have the Sized bound, so the ?Sized can be used to opt-out of the implicit bound."
  },
  {
    "title": "Associated Types - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/associated-types.html",
    "html": "Associated Types\n\nAssociated types are a powerful part of Rust‚Äôs type system. They‚Äôre related to the idea of a ‚Äòtype family‚Äô, in other words, grouping multiple types together. That description is a bit abstract, so let‚Äôs dive right into an example. If you want to write a Graph trait, you have two types to be generic over: the node type and the edge type. So you might write a trait, Graph<N, E>, that looks like this:\n\n\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    fn edges(&self, &N) -> Vec<E>;\n    // Etc.\n}\n\nWhile this sort of works, it ends up being awkward. For example, any function that wants to take a Graph as a parameter now also needs to be generic over the Node and Edge types too:\n\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n\n\nOur distance calculation works regardless of our Edge type, so the E stuff in this signature is a distraction.\n\nWhat we really want to say is that a certain Edge and Node type come together to form each kind of Graph. We can do that with associated types:\n\n\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n    // Etc.\n}\n\nNow, our clients can be abstract over a given Graph:\n\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> u32 { ... }\n\n\nNo need to deal with the Edge type here!\n\nLet‚Äôs go over all this in more detail.\n\nDefining associated types\n\nLet‚Äôs build that Graph trait. Here‚Äôs the definition:\n\n\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n\nSimple enough. Associated types use the type keyword, and go inside the body of the trait, with the functions.\n\nThese type declarations work the same way as those for functions. For example, if we wanted our N type to implement Display, so we can print the nodes out, we could do this:\n\n\nuse std::fmt;\n\ntrait Graph {\n    type N: fmt::Display;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\nImplementing associated types\n\nJust like any trait, traits that use associated types use the impl keyword to provide implementations. Here‚Äôs a simple implementation of Graph:\n\n\nstruct Node;\n\nstruct Edge;\n\nstruct MyGraph;\n\nimpl Graph for MyGraph {\n    type N = Node;\n    type E = Edge;\n\n    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n        true\n    }\n\n    fn edges(&self, n: &Node) -> Vec<Edge> {\n        Vec::new()\n    }\n}\n\nThis silly implementation always returns true and an empty Vec<Edge>, but it gives you an idea of how to implement this kind of thing. We first need three structs, one for the graph, one for the node, and one for the edge. If it made more sense to use a different type, that would work as well, we‚Äôre going to use structs for all three here.\n\nNext is the impl line, which is an implementation like any other trait.\n\nFrom here, we use = to define our associated types. The name the trait uses goes on the left of the =, and the concrete type we‚Äôre implementing this for goes on the right. Finally, we use the concrete types in our function declarations.\n\nTrait objects with associated types\n\nThere‚Äôs one more bit of syntax we should talk about: trait objects. If you try to create a trait object from a trait with an associated type, like this:\n\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph>;\n\n\nYou‚Äôll get two errors:\n\nerror: the value of the associated type `E` (from the trait `main::Graph`) must\nbe specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24:44 error: the value of the associated type `N` (from the trait\n`main::Graph`) must be specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nWe can‚Äôt create a trait object like this, because we don‚Äôt know the associated types. Instead, we can write this:\n\n\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n\nThe N=Node syntax allows us to provide a concrete type, Node, for the N type parameter. Same with E=Edge. If we didn‚Äôt provide this constraint, we couldn‚Äôt be sure which impl to match this trait object to."
  },
  {
    "title": "Casting between types - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/casting-between-types.html",
    "html": "Casting Between Types\n\nRust, with its focus on safety, provides two different ways of casting different types between each other. The first, as, is for safe casts. In contrast, transmute allows for arbitrary casting, and is one of the most dangerous features of Rust!\n\nCoercion\n\nCoercion between types is implicit and has no syntax of its own, but can be spelled out with as.\n\nCoercion occurs in let, const, and static statements; in function call arguments; in field values in struct initialization; and in a function result.\n\nThe most common case of coercion is removing mutability from a reference:\n\n&mut T to &T\n\nAn analogous conversion is to remove mutability from a raw pointer:\n\n*mut T to *const T\n\nReferences can also be coerced to raw pointers:\n\n&T to *const T\n\n&mut T to *mut T\n\nCustom coercions may be defined using Deref.\n\nCoercion is transitive.\n\nas\n\nThe as keyword does safe casting:\n\n\nlet x: i32 = 5;\n\nlet y = x as i64;\n\nThere are three major categories of safe cast: explicit coercions, casts between numeric types, and pointer casts.\n\nCasting is not transitive: even if e as U1 as U2 is a valid expression, e as U2 is not necessarily so (in fact it will only be valid if U1 coerces to U2).\n\nExplicit coercions\n\nA cast e as U is valid if e has type T and T coerces to U.\n\nNumeric casts\n\nA cast e as U is also valid in any of the following cases:\n\ne has type T and T and U are any numeric types; numeric-cast\ne is an enum with no data attached to the variants (a \"field-less enumeration\"), and U is an integer type; enum-cast\ne has type bool or char and U is an integer type; prim-int-cast\ne has type u8 and U is char; u8-char-cast\n\nFor example\n\n\nlet one = true as u8;\nlet at_sign = 64 as char;\nlet two_hundred = -56i8 as u8;\n\nThe semantics of numeric casts are:\n\nCasting between two integers of the same size (e.g. i32 -> u32) is a no-op\nCasting from a larger integer to a smaller integer (e.g. u32 -> u8) will truncate\nCasting from a smaller integer to a larger integer (e.g. u8 -> u32) will\nzero-extend if the source is unsigned\nsign-extend if the source is signed\nCasting from a float to an integer will round the float towards zero\nNOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes Inf and NaN. This is a bug and will be fixed.\nCasting from an integer to float will produce the floating point representation of the integer, rounded if necessary (rounding strategy unspecified)\nCasting from an f32 to an f64 is perfect and lossless\nCasting from an f64 to an f32 will produce the closest possible value (rounding strategy unspecified)\nNOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32. This is a bug and will be fixed.\nPointer casts\n\nPerhaps surprisingly, it is safe to cast raw pointers to and from integers, and to cast between pointers to different types subject to some constraints. It is only unsafe to dereference the pointer:\n\n\nlet a = 300 as *const char; // `a` is a pointer to location 300.\nlet b = a as u32;\n\ne as U is a valid pointer cast in any of the following cases:\n\ne has type *T, U has type *U_0, and either U_0: Sized or unsize_kind(T) == unsize_kind(U_0); a ptr-ptr-cast\n\ne has type *T and U is a numeric type, while T: Sized; ptr-addr-cast\n\ne is an integer and U is *U_0, while U_0: Sized; addr-ptr-cast\n\ne has type &[T; n] and U is *const T; array-ptr-cast\n\ne is a function pointer type and U has type *T, while T: Sized; fptr-ptr-cast\n\ne is a function pointer type and U is an integer; fptr-addr-cast\n\ntransmute\n\nas only allows safe casting, and will for example reject an attempt to cast four bytes into a u32:\n\nlet a = [0u8, 0u8, 0u8, 0u8];\n\nlet b = a as u32; // Four u8s makes a u32.\n\n\nThis errors with:\n\nerror: non-scalar cast: `[u8; 4]` as `u32`\nlet b = a as u32; // Four u8s makes a u32.\n        ^~~~~~~~\n\n\nThis is a ‚Äònon-scalar cast‚Äô because we have multiple values here: the four elements of the array. These kinds of casts are very dangerous, because they make assumptions about the way that multiple underlying structures are implemented. For this, we need something more dangerous.\n\nThe transmute function is very simple, but very scary. It tells Rust to treat a value of one type as though it were another type. It does this regardless of the typechecking system, and completely trusts you.\n\nIn our previous example, we know that an array of four u8s represents a u32 properly, and so we want to do the cast. Using transmute instead of as, Rust lets us:\n\nuse std::mem;\n\nfn main() {\n    unsafe {\n        let a = [0u8, 1u8, 0u8, 0u8];\n        let b = mem::transmute::<[u8; 4], u32>(a);\n        println!(\"{}\", b); // 256\n        // Or, more concisely:\n        let c: u32 = mem::transmute(a);\n        println!(\"{}\", c); // 256\n    }\n}\n\n\nWe have to wrap the operation in an unsafe block for this to compile successfully. Technically, only the mem::transmute call itself needs to be in the block, but it's nice in this case to enclose everything related, so you know where to look. In this case, the details about a are also important, and so they're in the block. You'll see code in either style, sometimes the context is too far away, and wrapping all of the code in unsafe isn't a great idea.\n\nWhile transmute does very little checking, it will at least make sure that the types are the same size. This errors:\n\nuse std::mem;\n\nunsafe {\n    let a = [0u8, 0u8, 0u8, 0u8];\n\n    let b = mem::transmute::<[u8; 4], u64>(a);\n}\n\n\nwith:\n\nerror: transmute called with differently sized types: [u8; 4] (32 bits) to u64\n(64 bits)\n\n\nOther than that, you're on your own!"
  },
  {
    "title": "type aliases - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/type-aliases.html",
    "html": "Type Aliases\n\nThe type keyword lets you declare an alias of another type:\n\n\ntype Name = String;\n\nYou can then use this type as if it were a real type:\n\n\ntype Name = String;\n\nlet x: Name = \"Hello\".to_string();\n\nNote, however, that this is an alias, not a new type entirely. In other words, because Rust is strongly typed, you‚Äôd expect a comparison between two different types to fail:\n\nlet x: i32 = 5;\nlet y: i64 = 5;\n\nif x == y {\n   // ...\n}\n\n\nthis gives\n\nerror: mismatched types:\n expected `i32`,\n    found `i64`\n(expected i32,\n    found i64) [E0308]\n     if x == y {\n             ^\n\n\nBut, if we had an alias:\n\n\ntype Num = i32;\n\nlet x: i32 = 5;\nlet y: Num = 5;\n\nif x == y {\n   // ...\n}\n\nThis compiles without error. Values of a Num type are the same as a value of type i32, in every way. You can use tuple struct to really get a new type.\n\nYou can also use type aliases with generics:\n\n\nuse std::result;\n\nenum ConcreteError {\n    Foo,\n    Bar,\n}\n\ntype Result<T> = result::Result<T, ConcreteError>;\n\nThis creates a specialized version of the Result type, which always has a ConcreteError for the E part of Result<T, E>. This is commonly used in the standard library to create custom errors for each subsection. For example, io::Result."
  },
  {
    "title": "Attributes - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/attributes.html",
    "html": "Attributes\n\nDeclarations can be annotated with ‚Äòattributes‚Äô in Rust. They look like this:\n\n\n#[test]\n\nor like this:\n\n\n#![test]\n\nThe difference between the two is the !, which changes what the attribute applies to:\n\n#[foo]\nstruct Foo;\n\nmod bar {\n    #![bar]\n}\n\n\nThe #[foo] attribute applies to the next item, which is the struct declaration. The #![bar] attribute applies to the item enclosing it, which is the mod declaration. Otherwise, they‚Äôre the same. Both change the meaning of the item they‚Äôre attached to somehow.\n\nFor example, consider a function like this:\n\n\n#[test]\nfn check() {\n    assert_eq!(2, 1 + 1);\n}\n\nIt is marked with #[test]. This means it‚Äôs special: when you run tests, this function will execute. When you compile as usual, it won‚Äôt even be included. This function is now a test function.\n\nAttributes may also have additional data:\n\n\n#[inline(always)]\nfn super_fast_fn() {\n\nOr even keys and values:\n\n\n#[cfg(target_os = \"macos\")]\nmod macos_only {\n\nRust attributes are used for a number of different things. There is a full list of attributes in the reference. Currently, you are not allowed to create your own attributes, the Rust compiler defines them."
  },
  {
    "title": "Crates and Modules - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/crates-and-modules.html",
    "html": "Crates and Modules\n\nWhen a project starts getting large, it‚Äôs considered good software engineering practice to split it up into a bunch of smaller pieces, and then fit them together. It is also important to have a well-defined interface, so that some of your functionality is private, and some is public. To facilitate these kinds of things, Rust has a module system.\n\nBasic terminology: Crates and Modules\n\nRust has two distinct terms that relate to the module system: ‚Äòcrate‚Äô and ‚Äòmodule‚Äô. A crate is synonymous with a ‚Äòlibrary‚Äô or ‚Äòpackage‚Äô in other languages. Hence ‚ÄúCargo‚Äù as the name of Rust‚Äôs package management tool: you ship your crates to others with Cargo. Crates can produce an executable or a library, depending on the project.\n\nEach crate has an implicit root module that contains the code for that crate. You can then define a tree of sub-modules under that root module. Modules allow you to partition your code within the crate itself.\n\nAs an example, let‚Äôs make a phrases crate, which will give us various phrases in different languages. To keep things simple, we‚Äôll stick to ‚Äògreetings‚Äô and ‚Äòfarewells‚Äô as two kinds of phrases, and use English and Japanese (Êó•Êú¨Ë™û) as two languages for those phrases to be in. We‚Äôll use this module layout:\n\n                                    +-----------+\n                                +---| greetings |\n                  +---------+   |   +-----------+\n              +---| english |---+\n              |   +---------+   |   +-----------+\n              |                 +---| farewells |\n+---------+   |                     +-----------+\n| phrases |---+\n+---------+   |                     +-----------+\n              |                 +---| greetings |\n              |   +----------+  |   +-----------+\n              +---| japanese |--+\n                  +----------+  |   +-----------+\n                                +---| farewells |\n                                    +-----------+\n\n\nIn this example, phrases is the name of our crate. All of the rest are modules. You can see that they form a tree, branching out from the crate root, which is the root of the tree: phrases itself.\n\nNow that we have a plan, let‚Äôs define these modules in code. To start, generate a new crate with Cargo:\n\n$ cargo new phrases\n$ cd phrases\n\n\nIf you remember, this generates a simple project for us:\n\n$ tree .\n.\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îî‚îÄ‚îÄ src\n    ‚îî‚îÄ‚îÄ lib.rs\n\n1 directory, 2 files\n\n\nsrc/lib.rs is our crate root, corresponding to the phrases in our diagram above.\n\nDefining Modules\n\nTo define each of our modules, we use the mod keyword. Let‚Äôs make our src/lib.rs look like this:\n\n\nmod english {\n    mod greetings {\n    }\n\n    mod farewells {\n    }\n}\n\nmod japanese {\n    mod greetings {\n    }\n\n    mod farewells {\n    }\n}\n\nAfter the mod keyword, you give the name of the module. Module names follow the conventions for other Rust identifiers: lower_snake_case. The contents of each module are within curly braces ({}).\n\nWithin a given mod, you can declare sub-mods. We can refer to sub-modules with double-colon (::) notation: our four nested modules are english::greetings, english::farewells, japanese::greetings, and japanese::farewells. Because these sub-modules are namespaced under their parent module, the names don‚Äôt conflict: english::greetings and japanese::greetings are distinct, even though their names are both greetings.\n\nBecause this crate does not have a main() function, and is called lib.rs, Cargo will build this crate as a library:\n\n$ cargo build\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n$ ls target/debug\nbuild  deps  examples  libphrases-a7448e02a0468eaa.rlib  native\n\n\nlibphrases-<hash>.rlib is the compiled crate. Before we see how to use this crate from another crate, let‚Äôs break it up into multiple files.\n\nMultiple File Crates\n\nIf each crate were just one file, these files would get very large. It‚Äôs often easier to split up crates into multiple files, and Rust supports this in two ways.\n\nInstead of declaring a module like this:\n\nmod english {\n    // Contents of our module go here.\n}\n\n\nWe can instead declare our module like this:\n\nmod english;\n\n\nIf we do that, Rust will expect to find either a english.rs file, or a english/mod.rs file with the contents of our module.\n\nNote that in these files, you don‚Äôt need to re-declare the module: that‚Äôs already been done with the initial mod declaration.\n\nUsing these two techniques, we can break up our crate into two directories and seven files:\n\n$ tree .\n.\n‚îú‚îÄ‚îÄ Cargo.lock\n‚îú‚îÄ‚îÄ Cargo.toml\n‚îú‚îÄ‚îÄ src\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ english\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ farewells.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ greetings.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ japanese\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ farewells.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ greetings.rs\n‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ lib.rs\n‚îî‚îÄ‚îÄ target\n    ‚îî‚îÄ‚îÄ debug\n        ‚îú‚îÄ‚îÄ build\n        ‚îú‚îÄ‚îÄ deps\n        ‚îú‚îÄ‚îÄ examples\n        ‚îú‚îÄ‚îÄ libphrases-a7448e02a0468eaa.rlib\n        ‚îî‚îÄ‚îÄ native\n\n\nsrc/lib.rs is our crate root, and looks like this:\n\nmod english;\nmod japanese;\n\n\nThese two declarations tell Rust to look for\n\neither src/english.rs or src/english/mod.rs, and\neither src/japanese.rs or src/japanese/mod.rs,\n\ndepending on our preference. In this case, because our modules have sub-modules, we‚Äôve chosen the mod.rs approach. Both src/english/mod.rs and src/japanese/mod.rs look like this:\n\nmod greetings;\nmod farewells;\n\n\nAgain, these declarations tell Rust to look for\n\nsrc/english/greetings.rs or src/english/greetings/mod.rs,\nsrc/english/farewells.rs or src/english/farewells/mod.rs,\nsrc/japanese/greetings.rs or src/japanese/greetings/mod.rs,\nand src/japanese/farewells.rs or src/japanese/farewells/mod.rs.\n\nBecause these sub-modules don‚Äôt have their own sub-modules, we‚Äôve chosen to make them src/english/greetings.rs, src/english/farewells.rs, src/japanese/greetings.rs and src/japanese/farewells.rs. Whew!\n\nThe contents of src/english/greetings.rs, src/english/farewells.rs, src/japanese/greetings.rs and src/japanese/farewells.rs are all empty at the moment. Let‚Äôs add some functions.\n\nPut this in src/english/greetings.rs:\n\n\nfn hello() -> String {\n    \"Hello!\".to_string()\n}\n\nPut this in src/english/farewells.rs:\n\n\nfn goodbye() -> String {\n    \"Goodbye.\".to_string()\n}\n\nPut this in src/japanese/greetings.rs:\n\n\nfn hello() -> String {\n    \"„Åì„Çì„Å´„Å°„ÅØ\".to_string()\n}\n\nOf course, you can copy and paste this from this web page, or type something else. It‚Äôs not important that you actually put ‚Äòkonnichiwa‚Äô to learn about the module system.\n\nPut this in src/japanese/farewells.rs:\n\n\nfn goodbye() -> String {\n    \"„Åï„Çà„ÅÜ„Å™„Çâ\".to_string()\n}\n\n(This is ‚ÄòSay≈çnara‚Äô, if you‚Äôre curious.)\n\nNow that we have some functionality in our crate, let‚Äôs try to use it from another crate.\n\nImporting External Crates\n\nWe have a library crate. Let‚Äôs make an executable crate that imports and uses our library.\n\nMake a src/main.rs and put this in it (it won‚Äôt quite compile yet):\n\nextern crate phrases;\n\nfn main() {\n    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n\n    println!(\"Hello in Japanese: {}\", phrases::japanese::greetings::hello());\n    println!(\"Goodbye in Japanese: {}\", phrases::japanese::farewells::goodbye());\n}\n\n\nThe extern crate declaration tells Rust that we need to compile and link to the phrases crate. We can then use phrases‚Äô modules in this one. As we mentioned earlier, you can use double colons to refer to sub-modules and the functions inside of them.\n\n(Note: when importing a crate that has dashes in its name \"like-this\", which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write extern crate like_this;.)\n\nAlso, Cargo assumes that src/main.rs is the crate root of a binary crate, rather than a library crate. Our package now has two crates: src/lib.rs and src/main.rs. This pattern is quite common for executable crates: most functionality is in a library crate, and the executable crate uses that library. This way, other programs can also use the library crate, and it‚Äôs also a nice separation of concerns.\n\nThis doesn‚Äôt quite work yet, though. We get four errors that look similar to this:\n\n$ cargo build\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\nsrc/main.rs:4:38: 4:72 error: function `hello` is private\nsrc/main.rs:4     println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: in expansion of format_args!\n<std macros>:2:25: 2:58 note: expansion site\n<std macros>:1:1: 2:62 note: in expansion of print!\n<std macros>:3:1: 3:54 note: expansion site\n<std macros>:1:1: 3:58 note: in expansion of println!\nphrases/src/main.rs:4:5: 4:76 note: expansion site\n\n\nBy default, everything is private in Rust. Let‚Äôs talk about this in some more depth.\n\nExporting a Public Interface\n\nRust allows you to precisely control which aspects of your interface are public, and so private is the default. To make things public, you use the pub keyword. Let‚Äôs focus on the english module first, so let‚Äôs reduce our src/main.rs to only this:\n\nextern crate phrases;\n\nfn main() {\n    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n}\n\n\nIn our src/lib.rs, let‚Äôs add pub to the english module declaration:\n\npub mod english;\nmod japanese;\n\n\nAnd in our src/english/mod.rs, let‚Äôs make both pub:\n\npub mod greetings;\npub mod farewells;\n\n\nIn our src/english/greetings.rs, let‚Äôs add pub to our fn declaration:\n\npub fn hello() -> String {\n    \"Hello!\".to_string()\n}\n\n\nAnd also in src/english/farewells.rs:\n\npub fn goodbye() -> String {\n    \"Goodbye.\".to_string()\n}\n\n\nNow, our crate compiles, albeit with warnings about not using the japanese functions:\n\n$ cargo run\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\nsrc/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default\nsrc/japanese/greetings.rs:1 fn hello() -> String {\nsrc/japanese/greetings.rs:2     \"„Åì„Çì„Å´„Å°„ÅØ\".to_string()\nsrc/japanese/greetings.rs:3 }\nsrc/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default\nsrc/japanese/farewells.rs:1 fn goodbye() -> String {\nsrc/japanese/farewells.rs:2     \"„Åï„Çà„ÅÜ„Å™„Çâ\".to_string()\nsrc/japanese/farewells.rs:3 }\n     Running `target/debug/phrases`\nHello in English: Hello!\nGoodbye in English: Goodbye.\n\n\npub also applies to structs and their member fields. In keeping with Rust‚Äôs tendency toward safety, simply making a struct public won't automatically make its members public: you must mark the fields individually with pub.\n\nNow that our functions are public, we can use them. Great! However, typing out phrases::english::greetings::hello() is very long and repetitive. Rust has another keyword for importing names into the current scope, so that you can refer to them with shorter names. Let‚Äôs talk about use.\n\nImporting Modules with use\n\nRust has a use keyword, which allows us to import names into our local scope. Let‚Äôs change our src/main.rs to look like this:\n\nextern crate phrases;\n\nuse phrases::english::greetings;\nuse phrases::english::farewells;\n\nfn main() {\n    println!(\"Hello in English: {}\", greetings::hello());\n    println!(\"Goodbye in English: {}\", farewells::goodbye());\n}\n\n\nThe two use lines import each module into the local scope, so we can refer to the functions by a much shorter name. By convention, when importing functions, it‚Äôs considered best practice to import the module, rather than the function directly. In other words, you can do this:\n\nextern crate phrases;\n\nuse phrases::english::greetings::hello;\nuse phrases::english::farewells::goodbye;\n\nfn main() {\n    println!(\"Hello in English: {}\", hello());\n    println!(\"Goodbye in English: {}\", goodbye());\n}\n\n\nBut it is not idiomatic. This is significantly more likely to introduce a naming conflict. In our short program, it‚Äôs not a big deal, but as it grows, it becomes a problem. If we have conflicting names, Rust will give a compilation error. For example, if we made the japanese functions public, and tried to do this:\n\nextern crate phrases;\n\nuse phrases::english::greetings::hello;\nuse phrases::japanese::greetings::hello;\n\nfn main() {\n    println!(\"Hello in English: {}\", hello());\n    println!(\"Hello in Japanese: {}\", hello());\n}\n\n\nRust will give us a compile-time error:\n\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\nsrc/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]\nsrc/main.rs:4 use phrases::japanese::greetings::hello;\n                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nerror: aborting due to previous error\nCould not compile `phrases`.\n\n\nIf we‚Äôre importing multiple names from the same module, we don‚Äôt have to type it out twice. Instead of this:\n\nuse phrases::english::greetings;\nuse phrases::english::farewells;\n\n\nWe can use this shortcut:\n\nuse phrases::english::{greetings, farewells};\n\nRe-exporting with pub use\n\nYou don‚Äôt only use use to shorten identifiers. You can also use it inside of your crate to re-export a function inside another module. This allows you to present an external interface that may not directly map to your internal code organization.\n\nLet‚Äôs look at an example. Modify your src/main.rs to read like this:\n\nextern crate phrases;\n\nuse phrases::english::{greetings,farewells};\nuse phrases::japanese;\n\nfn main() {\n    println!(\"Hello in English: {}\", greetings::hello());\n    println!(\"Goodbye in English: {}\", farewells::goodbye());\n\n    println!(\"Hello in Japanese: {}\", japanese::hello());\n    println!(\"Goodbye in Japanese: {}\", japanese::goodbye());\n}\n\n\nThen, modify your src/lib.rs to make the japanese mod public:\n\npub mod english;\npub mod japanese;\n\n\nNext, make the two functions public, first in src/japanese/greetings.rs:\n\npub fn hello() -> String {\n    \"„Åì„Çì„Å´„Å°„ÅØ\".to_string()\n}\n\n\nAnd then in src/japanese/farewells.rs:\n\npub fn goodbye() -> String {\n    \"„Åï„Çà„ÅÜ„Å™„Çâ\".to_string()\n}\n\n\nFinally, modify your src/japanese/mod.rs to read like this:\n\npub use self::greetings::hello;\npub use self::farewells::goodbye;\n\nmod greetings;\nmod farewells;\n\n\nThe pub use declaration brings the function into scope at this part of our module hierarchy. Because we‚Äôve pub used this inside of our japanese module, we now have a phrases::japanese::hello() function and a phrases::japanese::goodbye() function, even though the code for them lives in phrases::japanese::greetings::hello() and phrases::japanese::farewells::goodbye(). Our internal organization doesn‚Äôt define our external interface.\n\nHere we have a pub use for each function we want to bring into the japanese scope. We could alternatively use the wildcard syntax to include everything from greetings into the current scope: pub use self::greetings::*.\n\nWhat about the self? Well, by default, use declarations are absolute paths, starting from your crate root. self makes that path relative to your current place in the hierarchy instead. There‚Äôs one more special form of use: you can use super:: to reach one level up the tree from your current location. Some people like to think of self as . and super as .., from many shells‚Äô display for the current directory and the parent directory.\n\nOutside of use, paths are relative: foo::bar() refers to a function inside of foo relative to where we are. If that‚Äôs prefixed with ::, as in ::foo::bar(), it refers to a different foo, an absolute path from your crate root.\n\nThis will build and run:\n\n$ cargo run\n   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n     Running `target/debug/phrases`\nHello in English: Hello!\nGoodbye in English: Goodbye.\nHello in Japanese: „Åì„Çì„Å´„Å°„ÅØ\nGoodbye in Japanese: „Åï„Çà„ÅÜ„Å™„Çâ\n\nComplex imports\n\nRust offers several advanced options that can add compactness and convenience to your extern crate and use statements. Here is an example:\n\nextern crate phrases as sayings;\n\nuse sayings::japanese::greetings as ja_greetings;\nuse sayings::japanese::farewells::*;\nuse sayings::english::{self, greetings as en_greetings, farewells as en_farewells};\n\nfn main() {\n    println!(\"Hello in English; {}\", en_greetings::hello());\n    println!(\"And in Japanese: {}\", ja_greetings::hello());\n    println!(\"Goodbye in English: {}\", english::farewells::goodbye());\n    println!(\"Again: {}\", en_farewells::goodbye());\n    println!(\"And in Japanese: {}\", goodbye());\n}\n\n\nWhat's going on here?\n\nFirst, both extern crate and use allow renaming the thing that is being imported. So the crate is still called \"phrases\", but here we will refer to it as \"sayings\". Similarly, the first use statement pulls in the japanese::greetings module from the crate, but makes it available as ja_greetings as opposed to simply greetings. This can help to avoid ambiguity when importing similarly-named items from different places.\n\nThe second use statement uses a star glob to bring in all public symbols from the sayings::japanese::farewells module. As you can see we can later refer to the Japanese goodbye function with no module qualifiers. This kind of glob should be used sparingly. It‚Äôs worth noting that it only imports the public symbols, even if the code doing the globbing is in the same module.\n\nThe third use statement bears more explanation. It's using \"brace expansion\" globbing to compress three use statements into one (this sort of syntax may be familiar if you've written Linux shell scripts before). The uncompressed form of this statement would be:\n\nuse sayings::english;\nuse sayings::english::greetings as en_greetings;\nuse sayings::english::farewells as en_farewells;\n\n\nAs you can see, the curly brackets compress use statements for several items under the same path, and in this context self refers back to that path. Note: The curly brackets cannot be nested or mixed with star globbing."
  },
  {
    "title": "const and static - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/const-and-static.html",
    "html": "const and static\n\nRust has a way of defining constants with the const keyword:\n\n\nconst N: i32 = 5;\n\nUnlike let bindings, you must annotate the type of a const.\n\nConstants live for the entire lifetime of a program. More specifically, constants in Rust have no fixed address in memory. This is because they‚Äôre effectively inlined to each place that they‚Äôre used. References to the same constant are not necessarily guaranteed to refer to the same memory address for this reason.\n\nstatic\n\nRust provides a ‚Äòglobal variable‚Äô sort of facility in static items. They‚Äôre similar to constants, but static items aren‚Äôt inlined upon use. This means that there is only one instance for each value, and it‚Äôs at a fixed location in memory.\n\nHere‚Äôs an example:\n\n\nstatic N: i32 = 5;\n\nUnlike let bindings, you must annotate the type of a static.\n\nStatics live for the entire lifetime of a program, and therefore any reference stored in a static has a 'static lifetime:\n\n\nstatic NAME: &'static str = \"Steve\";\n\nThe type of a static value must be Sync unless the static value is mutable.\n\nMutability\n\nYou can introduce mutability with the mut keyword:\n\n\nstatic mut N: i32 = 5;\n\nBecause this is mutable, one thread could be updating N while another is reading it, causing memory unsafety. As such both accessing and mutating a static mut is unsafe, and so must be done in an unsafe block:\n\n\n\nunsafe {\n    N += 1;\n\n    println!(\"N: {}\", N);\n}\nInitializing\n\nBoth const and static have requirements for giving them a value. They must be given a value that‚Äôs a constant expression. In other words, you cannot use the result of a function call or anything similarly complex or at runtime.\n\nDropping\n\nTypes implementing Drop are allowed in const and static definitions. Constants are inlined where they are used and are dropped accordingly. static values are not dropped.\n\nWhich construct should I use?\n\nAlmost always, if you can choose between the two, choose const. It‚Äôs pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but downstream crates."
  },
  {
    "title": "Closures - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/closures.html",
    "html": "Closures\n\nSometimes it is useful to wrap up a function and free variables for better clarity and reuse. The free variables that can be used come from the enclosing scope and are ‚Äòclosed over‚Äô when used in the function. From this, we get the name ‚Äòclosures‚Äô and Rust provides a really great implementation of them, as we‚Äôll see.\n\nSyntax\n\nClosures look like this:\n\n\nlet plus_one = |x: i32| x + 1;\n\nassert_eq!(2, plus_one(1));\n\nWe create a binding, plus_one, and assign it to a closure. The closure‚Äôs arguments go between the pipes (|), and the body is an expression, in this case, x + 1. Remember that { } is an expression, so we can have multi-line closures too:\n\n\nlet plus_two = |x| {\n    let mut result: i32 = x;\n\n    result += 1;\n    result += 1;\n\n    result\n};\n\nassert_eq!(4, plus_two(2));\n\nYou‚Äôll notice a few things about closures that are a bit different from regular named functions defined with fn. The first is that we did not need to annotate the types of arguments the closure takes or the values it returns. We can:\n\n\nlet plus_one = |x: i32| -> i32 { x + 1 };\n\nassert_eq!(2, plus_one(1));\n\nBut we don‚Äôt have to. Why is this? Basically, it was chosen for ergonomic reasons. While specifying the full type for named functions is helpful with things like documentation and type inference, the full type signatures of closures are rarely documented since they‚Äôre anonymous, and they don‚Äôt cause the kinds of error-at-a-distance problems that inferring named function types can.\n\nThe second is that the syntax is similar, but a bit different. I‚Äôve added spaces here for easier comparison:\n\n\nfn  plus_one_v1   (x: i32) -> i32 { x + 1 }\nlet plus_one_v2 = |x: i32| -> i32 { x + 1 };\nlet plus_one_v3 = |x: i32|          x + 1  ;\n\nSmall differences, but they‚Äôre similar.\n\nClosures and their environment\n\nThe environment for a closure can include bindings from its enclosing scope in addition to parameters and local bindings. It looks like this:\n\n\nlet num = 5;\nlet plus_num = |x: i32| x + num;\n\nassert_eq!(10, plus_num(5));\n\nThis closure, plus_num, refers to a let binding in its scope: num. More specifically, it borrows the binding. If we do something that would conflict with that binding, we get an error. Like this one:\n\nlet mut num = 5;\nlet plus_num = |x: i32| x + num;\n\nlet y = &mut num;\n\n\nWhich errors with:\n\nerror: cannot borrow `num` as mutable because it is also borrowed as immutable\n    let y = &mut num;\n                 ^~~\nnote: previous borrow of `num` occurs here due to use in closure; the immutable\n  borrow prevents subsequent moves or mutable borrows of `num` until the borrow\n  ends\n    let plus_num = |x| x + num;\n                   ^~~~~~~~~~~\nnote: previous borrow ends here\nfn main() {\n    let mut num = 5;\n    let plus_num = |x| x + num;\n\n    let y = &mut num;\n}\n^\n\n\nA verbose yet helpful error message! As it says, we can‚Äôt take a mutable borrow on num because the closure is already borrowing it. If we let the closure go out of scope, we can:\n\n\nlet mut num = 5;\n{\n    let plus_num = |x: i32| x + num;\n\n} // `plus_num` goes out of scope; borrow of `num` ends.\n\nlet y = &mut num;\n\nIf your closure requires it, however, Rust will take ownership and move the environment instead. This doesn‚Äôt work:\n\nlet nums = vec![1, 2, 3];\n\nlet takes_nums = || nums;\n\nprintln!(\"{:?}\", nums);\n\n\nWe get this error:\n\nnote: `nums` moved into closure environment here because it has type\n  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable\nlet takes_nums = || nums;\n                 ^~~~~~~\n\n\nVec<T> has ownership over its contents, and therefore, when we refer to it in our closure, we have to take ownership of nums. It‚Äôs the same as if we‚Äôd passed nums to a function that took ownership of it.\n\nmove closures\n\nWe can force our closure to take ownership of its environment with the move keyword:\n\n\nlet num = 5;\n\nlet owns_num = move |x: i32| x + num;\n\nNow, even though the keyword is move, the variables follow normal move semantics. In this case, 5 implements Copy, and so owns_num takes ownership of a copy of num. So what‚Äôs the difference?\n\n\nlet mut num = 5;\n\n{\n    let mut add_num = |x: i32| num += x;\n\n    add_num(5);\n}\n\nassert_eq!(10, num);\n\nSo in this case, our closure took a mutable reference to num, and then when we called add_num, it mutated the underlying value, as we‚Äôd expect. We also needed to declare add_num as mut too, because we‚Äôre mutating its environment.\n\nIf we change to a move closure, it‚Äôs different:\n\n\nlet mut num = 5;\n\n{\n    let mut add_num = move |x: i32| num += x;\n\n    add_num(5);\n}\n\nassert_eq!(5, num);\n\nWe only get 5. Rather than taking a mutable borrow out on our num, we took ownership of a copy.\n\nAnother way to think about move closures: they give a closure its own stack frame. Without move, a closure may be tied to the stack frame that created it, while a move closure is self-contained. This means that you cannot generally return a non-move closure from a function, for example.\n\nBut before we talk about taking and returning closures, we should talk some more about the way that closures are implemented. As a systems language, Rust gives you tons of control over what your code does, and closures are no different.\n\nClosure implementation\n\nRust‚Äôs implementation of closures is a bit different than other languages. They are effectively syntax sugar for traits. You‚Äôll want to make sure to have read the traits section before this one, as well as the section on trait objects.\n\nGot all that? Good.\n\nThe key to understanding how closures work under the hood is something a bit strange: Using () to call a function, like foo(), is an overloadable operator. From this, everything else clicks into place. In Rust, we use the trait system to overload operators. Calling functions is no different. We have three separate traits to overload with:\n\nFn\nFnMut\nFnOnce\n\nThere are a few differences between these traits, but a big one is self: Fn takes &self, FnMut takes &mut self, and FnOnce takes self. This covers all three kinds of self via the usual method call syntax. But we‚Äôve split them up into three traits, rather than having a single one. This gives us a large amount of control over what kind of closures we can take.\n\nThe || {} syntax for closures is sugar for these three traits. Rust will generate a struct for the environment, impl the appropriate trait, and then use it.\n\nTaking closures as arguments\n\nNow that we know that closures are traits, we already know how to accept and return closures: the same as any other trait!\n\nThis also means that we can choose static vs dynamic dispatch as well. First, let‚Äôs write a function which takes something callable, calls it, and returns the result:\n\n\nfn call_with_one<F>(some_closure: F) -> i32\n    where F: Fn(i32) -> i32 {\n\n    some_closure(1)\n}\n\nlet answer = call_with_one(|x| x + 2);\n\nassert_eq!(3, answer);\n\nWe pass our closure, |x| x + 2, to call_with_one. It does what it suggests: it calls the closure, giving it 1 as an argument.\n\nLet‚Äôs examine the signature of call_with_one in more depth:\n\n\nfn call_with_one<F>(some_closure: F) -> i32\n\nWe take one parameter, and it has the type F. We also return an i32. This part isn‚Äôt interesting. The next part is:\n\n\n    where F: Fn(i32) -> i32 {\n\nBecause Fn is a trait, we can use it as a bound for our generic type. In this case, our closure takes an i32 as an argument and returns an i32, and so the generic bound we use is Fn(i32) -> i32.\n\nThere‚Äôs one other key point here: because we‚Äôre bounding a generic with a trait, this will get monomorphized, and therefore, we‚Äôll be doing static dispatch into the closure. That‚Äôs pretty neat. In many languages, closures are inherently heap allocated, and will always involve dynamic dispatch. In Rust, we can stack allocate our closure environment, and statically dispatch the call. This happens quite often with iterators and their adapters, which often take closures as arguments.\n\nOf course, if we want dynamic dispatch, we can get that too. A trait object handles this case, as usual:\n\n\nfn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n    some_closure(1)\n}\n\nlet answer = call_with_one(&|x| x + 2);\n\nassert_eq!(3, answer);\n\nNow we take a trait object, a &Fn. And we have to make a reference to our closure when we pass it to call_with_one, so we use &||.\n\nA quick note about closures that use explicit lifetimes. Sometimes you might have a closure that takes a reference like so:\n\n\nfn call_with_ref<F>(some_closure:F) -> i32\n    where F: Fn(&i32) -> i32 {\n\n    let value = 0;\n    some_closure(&value)\n}\n\nNormally you can specify the lifetime of the parameter to our closure. We could annotate it on the function declaration:\n\nfn call_with_ref<'a, F>(some_closure:F) -> i32\n    where F: Fn(&'a i32) -> i32 {\n\n\nHowever, this presents a problem in our case. When a function has an explicit lifetime parameter, that lifetime must be at least as long as the entire call to that function. The borrow checker will complain that value doesn't live long enough, because it is only in scope after its declaration inside the function body.\n\nWhat we need is a closure that can borrow its argument only for its own invocation scope, not for the outer function's scope. In order to say that, we can use Higher-Ranked Trait Bounds with the for<...> syntax:\n\nfn call_with_ref<F>(some_closure:F) -> i32\n    where F: for<'a> Fn(&'a i32) -> i32 {\n\n\nThis lets the Rust compiler find the minimum lifetime to invoke our closure and satisfy the borrow checker's rules. Our function then compiles and executes as we expect.\n\n\nfn call_with_ref<F>(some_closure:F) -> i32\n    where F: for<'a> Fn(&'a i32) -> i32 {\n\n    let value = 0;\n    some_closure(&value)\n}\nFunction pointers and closures\n\nA function pointer is kind of like a closure that has no environment. As such, you can pass a function pointer to any function expecting a closure argument, and it will work:\n\n\nfn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n    some_closure(1)\n}\n\nfn add_one(i: i32) -> i32 {\n    i + 1\n}\n\nlet f = add_one;\n\nlet answer = call_with_one(&f);\n\nassert_eq!(2, answer);\n\nIn this example, we don‚Äôt strictly need the intermediate variable f, the name of the function works just fine too:\n\nlet answer = call_with_one(&add_one);\n\nReturning closures\n\nIt‚Äôs very common for functional-style code to return closures in various situations. If you try to return a closure, you may run into an error. At first, it may seem strange, but we‚Äôll figure it out. Here‚Äôs how you‚Äôd probably try to return a closure from a function:\n\nfn factory() -> (Fn(i32) -> i32) {\n    let num = 5;\n\n    |x| x + num\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nThis gives us these long, related errors:\n\nerror: the trait bound `core::ops::Fn(i32) -> i32 : core::marker::Sized` is not satisfied [E0277]\nfn factory() -> (Fn(i32) -> i32) {\n                ^~~~~~~~~~~~~~~~\nnote: `core::ops::Fn(i32) -> i32` does not have a constant size known at compile-time\nfn factory() -> (Fn(i32) -> i32) {\n                ^~~~~~~~~~~~~~~~\nerror: the trait bound `core::ops::Fn(i32) -> i32 : core::marker::Sized` is not satisfied [E0277]\nlet f = factory();\n    ^\nnote: `core::ops::Fn(i32) -> i32` does not have a constant size known at compile-time\nlet f = factory();\n    ^\n\n\nIn order to return something from a function, Rust needs to know what size the return type is. But since Fn is a trait, it could be various things of various sizes: many different types can implement Fn. An easy way to give something a size is to take a reference to it, as references have a known size. So we‚Äôd write this:\n\nfn factory() -> &(Fn(i32) -> i32) {\n    let num = 5;\n\n    |x| x + num\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nBut we get another error:\n\nerror: missing lifetime specifier [E0106]\nfn factory() -> &(Fn(i32) -> i32) {\n                ^~~~~~~~~~~~~~~~~\n\n\nRight. Because we have a reference, we need to give it a lifetime. But our factory() function takes no arguments, so elision doesn‚Äôt kick in here. Then what choices do we have? Try 'static:\n\nfn factory() -> &'static (Fn(i32) -> i32) {\n    let num = 5;\n\n    |x| x + num\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nBut we get another error:\n\nerror: mismatched types:\n expected `&'static core::ops::Fn(i32) -> i32`,\n    found `[closure@<anon>:7:9: 7:20]`\n(expected &-ptr,\n    found closure) [E0308]\n         |x| x + num\n         ^~~~~~~~~~~\n\n\n\nThis error is letting us know that we don‚Äôt have a &'static Fn(i32) -> i32, we have a [closure@<anon>:7:9: 7:20]. Wait, what?\n\nBecause each closure generates its own environment struct and implementation of Fn and friends, these types are anonymous. They exist solely for this closure. So Rust shows them as closure@<anon>, rather than some autogenerated name.\n\nThe error also points out that the return type is expected to be a reference, but what we are trying to return is not. Further, we cannot directly assign a 'static lifetime to an object. So we'll take a different approach and return a ‚Äòtrait object‚Äô by Boxing up the Fn. This almost works:\n\nfn factory() -> Box<Fn(i32) -> i32> {\n    let num = 5;\n\n    Box::new(|x| x + num)\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\n\nThere‚Äôs just one last problem:\n\nerror: closure may outlive the current function, but it borrows `num`,\nwhich is owned by the current function [E0373]\nBox::new(|x| x + num)\n         ^~~~~~~~~~~\n\n\nWell, as we discussed before, closures borrow their environment. And in this case, our environment is based on a stack-allocated 5, the num variable binding. So the borrow has a lifetime of the stack frame. So if we returned this closure, the function call would be over, the stack frame would go away, and our closure is capturing an environment of garbage memory! With one last fix, we can make this work:\n\n\nfn factory() -> Box<Fn(i32) -> i32> {\n    let num = 5;\n\n    Box::new(move |x| x + num)\n}\n\nlet f = factory();\n\nlet answer = f(1);\nassert_eq!(6, answer);\n\nBy making the inner closure a move Fn, we create a new stack frame for our closure. By Boxing it up, we‚Äôve given it a known size, allowing it to escape our stack frame."
  },
  {
    "title": "Universal Function Call Syntax - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/ufcs.html",
    "html": "Universal Function Call Syntax\n\nSometimes, functions can have the same names. Consider this code:\n\n\ntrait Foo {\n    fn f(&self);\n}\n\ntrait Bar {\n    fn f(&self);\n}\n\nstruct Baz;\n\nimpl Foo for Baz {\n    fn f(&self) { println!(\"Baz‚Äôs impl of Foo\"); }\n}\n\nimpl Bar for Baz {\n    fn f(&self) { println!(\"Baz‚Äôs impl of Bar\"); }\n}\n\nlet b = Baz;\n\nIf we were to try to call b.f(), we‚Äôd get an error:\n\nerror: multiple applicable methods in scope [E0034]\nb.f();\n  ^~~\nnote: candidate #1 is defined in an impl of the trait `main::Foo` for the type\n`main::Baz`\n    fn f(&self) { println!(\"Baz‚Äôs impl of Foo\"); }\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: candidate #2 is defined in an impl of the trait `main::Bar` for the type\n`main::Baz`\n    fn f(&self) { println!(\"Baz‚Äôs impl of Bar\"); }\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\nWe need a way to disambiguate which method we need. This feature is called ‚Äòuniversal function call syntax‚Äô, and it looks like this:\n\n\nFoo::f(&b);\nBar::f(&b);\n\nLet‚Äôs break it down.\n\nFoo::\nBar::\n\n\nThese halves of the invocation are the types of the two traits: Foo and Bar. This is what ends up actually doing the disambiguation between the two: Rust calls the one from the trait name you use.\n\nf(&b)\n\n\nWhen we call a method like b.f() using method syntax, Rust will automatically borrow b if f() takes &self. In this case, Rust will not, and so we need to pass an explicit &b.\n\nAngle-bracket Form\n\nThe form of UFCS we just talked about:\n\nTrait::method(args);\n\n\nIs a short-hand. There‚Äôs an expanded form of this that‚Äôs needed in some situations:\n\n<Type as Trait>::method(args);\n\n\nThe <>:: syntax is a means of providing a type hint. The type goes inside the <>s. In this case, the type is Type as Trait, indicating that we want Trait‚Äôs version of method to be called here. The as Trait part is optional if it‚Äôs not ambiguous. Same with the angle brackets, hence the shorter form.\n\nHere‚Äôs an example of using the longer form.\n\ntrait Foo {\n    fn foo() -> i32;\n}\n\nstruct Bar;\n\nimpl Bar {\n    fn foo() -> i32 {\n        20\n    }\n}\n\nimpl Foo for Bar {\n    fn foo() -> i32 {\n        10\n    }\n}\n\nfn main() {\n    assert_eq!(10, <Bar as Foo>::foo());\n    assert_eq!(20, Bar::foo());\n}\n\n\nUsing the angle bracket syntax lets you call the trait method instead of the inherent one."
  },
  {
    "title": "Trait Objects - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/trait-objects.html",
    "html": "Trait Objects\n\nWhen code involves polymorphism, there needs to be a mechanism to determine which specific version is actually run. This is called ‚Äòdispatch‚Äô. There are two major forms of dispatch: static dispatch and dynamic dispatch. While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‚Äòtrait objects‚Äô.\n\nBackground\n\nFor the rest of this chapter, we‚Äôll need a trait and some implementations. Let‚Äôs make a simple one, Foo. It has one method that is expected to return a String.\n\n\ntrait Foo {\n    fn method(&self) -> String;\n}\n\nWe‚Äôll also implement this trait for u8 and String:\n\n\nimpl Foo for u8 {\n    fn method(&self) -> String { format!(\"u8: {}\", *self) }\n}\n\nimpl Foo for String {\n    fn method(&self) -> String { format!(\"string: {}\", *self) }\n}\nStatic dispatch\n\nWe can use this trait to perform static dispatch with trait bounds:\n\nfn do_something<T: Foo>(x: T) {\n    x.method();\n}\n\nfn main() {\n    let x = 5u8;\n    let y = \"Hello\".to_string();\n\n    do_something(x);\n    do_something(y);\n}\n\n\nRust uses ‚Äòmonomorphization‚Äô to perform static dispatch here. This means that Rust will create a special version of do_something() for both u8 and String, and then replace the call sites with calls to these specialized functions. In other words, Rust generates something like this:\n\nfn do_something_u8(x: u8) {\n    x.method();\n}\n\nfn do_something_string(x: String) {\n    x.method();\n}\n\nfn main() {\n    let x = 5u8;\n    let y = \"Hello\".to_string();\n\n    do_something_u8(x);\n    do_something_string(y);\n}\n\n\nThis has a great upside: static dispatch allows function calls to be inlined because the callee is known at compile time, and inlining is the key to good optimization. Static dispatch is fast, but it comes at a tradeoff: ‚Äòcode bloat‚Äô, due to many copies of the same function existing in the binary, one for each type.\n\nFurthermore, compilers aren‚Äôt perfect and may ‚Äúoptimize‚Äù code to become slower. For example, functions inlined too eagerly will bloat the instruction cache (cache rules everything around us). This is part of the reason that #[inline] and #[inline(always)] should be used carefully, and one reason why using a dynamic dispatch is sometimes more efficient.\n\nHowever, the common case is that it is more efficient to use static dispatch, and one can always have a thin statically-dispatched wrapper function that does a dynamic dispatch, but not vice versa, meaning static calls are more flexible. The standard library tries to be statically dispatched where possible for this reason.\n\nDynamic dispatch\n\nRust provides dynamic dispatch through a feature called ‚Äòtrait objects‚Äô. Trait objects, like &Foo or Box<Foo>, are normal values that store a value of any type that implements the given trait, where the precise type can only be known at runtime.\n\nA trait object can be obtained from a pointer to a concrete type that implements the trait by casting it (e.g. &x as &Foo) or coercing it (e.g. using &x as an argument to a function that takes &Foo).\n\nThese trait object coercions and casts also work for pointers like &mut T to &mut Foo and Box<T> to Box<Foo>, but that‚Äôs all at the moment. Coercions and casts are identical.\n\nThis operation can be seen as ‚Äòerasing‚Äô the compiler‚Äôs knowledge about the specific type of the pointer, and hence trait objects are sometimes referred to as ‚Äòtype erasure‚Äô.\n\nComing back to the example above, we can use the same trait to perform dynamic dispatch with trait objects by casting:\n\nfn do_something(x: &Foo) {\n    x.method();\n}\n\nfn main() {\n    let x = 5u8;\n    do_something(&x as &Foo);\n}\n\n\nor by coercing:\n\nfn do_something(x: &Foo) {\n    x.method();\n}\n\nfn main() {\n    let x = \"Hello\".to_string();\n    do_something(&x);\n}\n\n\nA function that takes a trait object is not specialized to each of the types that implements Foo: only one copy is generated, often (but not always) resulting in less code bloat. However, this comes at the cost of requiring slower virtual function calls, and effectively inhibiting any chance of inlining and related optimizations from occurring.\n\nWhy pointers?\n\nRust does not put things behind a pointer by default, unlike many managed languages, so types can have different sizes. Knowing the size of the value at compile time is important for things like passing it as an argument to a function, moving it about on the stack and allocating (and deallocating) space on the heap to store it.\n\nFor Foo, we would need to have a value that could be at least either a String (24 bytes) or a u8 (1 byte), as well as any other type for which dependent crates may implement Foo (any number of bytes at all). There‚Äôs no way to guarantee that this last point can work if the values are stored without a pointer, because those other types can be arbitrarily large.\n\nPutting the value behind a pointer means the size of the value is not relevant when we are tossing a trait object around, only the size of the pointer itself.\n\nRepresentation\n\nThe methods of the trait can be called on a trait object via a special record of function pointers traditionally called a ‚Äòvtable‚Äô (created and managed by the compiler).\n\nTrait objects are both simple and complicated: their core representation and layout is quite straight-forward, but there are some curly error messages and surprising behaviors to discover.\n\nLet‚Äôs start simple, with the runtime representation of a trait object. The std::raw module contains structs with layouts that are the same as the complicated built-in types, including trait objects:\n\n\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n\nThat is, a trait object like &Foo consists of a ‚Äòdata‚Äô pointer and a ‚Äòvtable‚Äô pointer.\n\nThe data pointer addresses the data (of some unknown type T) that the trait object is storing, and the vtable pointer points to the vtable (‚Äòvirtual method table‚Äô) corresponding to the implementation of Foo for T.\n\nA vtable is essentially a struct of function pointers, pointing to the concrete piece of machine code for each method in the implementation. A method call like trait_object.method() will retrieve the correct pointer out of the vtable and then do a dynamic call of it. For example:\n\nstruct FooVtable {\n    destructor: fn(*mut ()),\n    size: usize,\n    align: usize,\n    method: fn(*const ()) -> String,\n}\n\n// u8:\n\nfn call_method_on_u8(x: *const ()) -> String {\n    // The compiler guarantees that this function is only called\n    // with `x` pointing to a u8.\n    let byte: &u8 = unsafe { &*(x as *const u8) };\n\n    byte.method()\n}\n\nstatic Foo_for_u8_vtable: FooVtable = FooVtable {\n    destructor: /* compiler magic */,\n    size: 1,\n    align: 1,\n\n    // Cast to a function pointer:\n    method: call_method_on_u8 as fn(*const ()) -> String,\n};\n\n\n// String:\n\nfn call_method_on_String(x: *const ()) -> String {\n    // The compiler guarantees that this function is only called\n    // with `x` pointing to a String.\n    let string: &String = unsafe { &*(x as *const String) };\n\n    string.method()\n}\n\nstatic Foo_for_String_vtable: FooVtable = FooVtable {\n    destructor: /* compiler magic */,\n    // Values for a 64-bit computer, halve them for 32-bit ones.\n    size: 24,\n    align: 8,\n\n    method: call_method_on_String as fn(*const ()) -> String,\n};\n\n\nThe destructor field in each vtable points to a function that will clean up any resources of the vtable‚Äôs type: for u8 it is trivial, but for String it will free the memory. This is necessary for owning trait objects like Box<Foo>, which need to clean-up both the Box allocation as well as the internal type when they go out of scope. The size and align fields store the size of the erased type, and its alignment requirements.\n\nSuppose we‚Äôve got some values that implement Foo. The explicit form of construction and use of Foo trait objects might look a bit like (ignoring the type mismatches: they‚Äôre all pointers anyway):\n\nlet a: String = \"foo\".to_string();\nlet x: u8 = 1;\n\n// let b: &Foo = &a;\nlet b = TraitObject {\n    // Store the data:\n    data: &a,\n    // Store the methods:\n    vtable: &Foo_for_String_vtable\n};\n\n// let y: &Foo = x;\nlet y = TraitObject {\n    // Store the data:\n    data: &x,\n    // Store the methods:\n    vtable: &Foo_for_u8_vtable\n};\n\n// b.method();\n(b.vtable.method)(b.data);\n\n// y.method();\n(y.vtable.method)(y.data);\n\nObject Safety\n\nNot every trait can be used to make a trait object. For example, vectors implement Clone, but if we try to make a trait object:\n\nlet v = vec![1, 2, 3];\nlet o = &v as &Clone;\n\n\nWe get an error:\n\nerror: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]\nlet o = &v as &Clone;\n        ^~\nnote: the trait cannot require that `Self : Sized`\nlet o = &v as &Clone;\n        ^~\n\n\nThe error says that Clone is not ‚Äòobject-safe‚Äô. Only traits that are object-safe can be made into trait objects. A trait is object-safe if both of these are true:\n\nthe trait does not require that Self: Sized\nall of its methods are object-safe\n\nSo what makes a method object-safe? Each method must require that Self: Sized or all of the following:\n\nmust not have any type parameters\nmust not use Self\n\nWhew! As we can see, almost all of these rules talk about Self. A good intuition is ‚Äúexcept in special circumstances, if your trait‚Äôs method uses Self, it is not object-safe.‚Äù"
  },
  {
    "title": "if let - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/if-let.html",
    "html": "if let\n\nif let permits patterns matching within the condition of an if statement. This allows us to reduce the overhead of certain kinds of pattern matches and express them in a more convenient way.\n\nFor example, let‚Äôs say we have some sort of Option<T>. We want to call a function on it if it‚Äôs Some<T>, but do nothing if it‚Äôs None. That looks like this:\n\n\nmatch option {\n    Some(x) => { foo(x) },\n    None => {},\n}\n\nWe don‚Äôt have to use match here, for example, we could use if:\n\n\nif option.is_some() {\n    let x = option.unwrap();\n    foo(x);\n}\n\nNeither of these options is particularly appealing. We can use if let to do the same thing in a nicer way:\n\n\nif let Some(x) = option {\n    foo(x);\n}\n\nIf a pattern matches successfully, it binds any appropriate parts of the value to the identifiers in the pattern, then evaluates the expression. If the pattern doesn‚Äôt match, nothing happens.\n\nIf you want to do something else when the pattern does not match, you can use else:\n\n\nif let Some(x) = option {\n    foo(x);\n} else {\n    bar();\n}\nwhile let\n\nIn a similar fashion, while let can be used when you want to conditionally loop as long as a value matches a certain pattern. It turns code like this:\n\n\nlet mut v = vec![1, 3, 5, 7, 11];\nloop {\n    match v.pop() {\n        Some(x) =>  println!(\"{}\", x),\n        None => break,\n    }\n}\n\nInto code like this:\n\n\nlet mut v = vec![1, 3, 5, 7, 11];\nwhile let Some(x) = v.pop() {\n    println!(\"{}\", x);\n}"
  },
  {
    "title": "Drop - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/drop.html",
    "html": "Drop\n\nNow that we‚Äôve discussed traits, let‚Äôs talk about a particular trait provided by the Rust standard library, Drop. The Drop trait provides a way to run some code when a value goes out of scope. For example:\n\nstruct HasDrop;\n\nimpl Drop for HasDrop {\n    fn drop(&mut self) {\n        println!(\"Dropping!\");\n    }\n}\n\nfn main() {\n    let x = HasDrop;\n\n    // Do stuff.\n\n} // `x` goes out of scope here.\n\n\nWhen x goes out of scope at the end of main(), the code for Drop will run. Drop has one method, which is also called drop(). It takes a mutable reference to self.\n\nThat‚Äôs it! The mechanics of Drop are very simple, but there are some subtleties. For example, values are dropped in the opposite order they are declared. Here‚Äôs another example:\n\nstruct Firework {\n    strength: i32,\n}\n\nimpl Drop for Firework {\n    fn drop(&mut self) {\n        println!(\"BOOM times {}!!!\", self.strength);\n    }\n}\n\nfn main() {\n    let firecracker = Firework { strength: 1 };\n    let tnt = Firework { strength: 100 };\n}\n\n\nThis will output:\n\nBOOM times 100!!!\nBOOM times 1!!!\n\n\nThe tnt goes off before the firecracker does, because it was declared afterwards. Last in, first out.\n\nSo what is Drop good for? Generally, Drop is used to clean up any resources associated with a struct. For example, the Arc<T> type is a reference-counted type. When Drop is called, it will decrement the reference count, and if the total number of references is zero, will clean up the underlying value."
  },
  {
    "title": "Traits - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/traits.html",
    "html": "Traits\n\nA trait is a language feature that tells the Rust compiler about functionality a type must provide.\n\nRecall the impl keyword, used to call a function with method syntax:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nTraits are similar, except that we first define a trait with a method signature, then implement the trait for a type. In this example, we implement the trait HasArea for Circle:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\ntrait HasArea {\n    fn area(&self) -> f64;\n}\n\nimpl HasArea for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nAs you can see, the trait block looks very similar to the impl block, but we don‚Äôt define a body, only a type signature. When we impl a trait, we use impl Trait for Item, rather than only impl Item.\n\nSelf may be used in a type annotation to refer to an instance of the type implementing this trait passed as a parameter. Self, &Self or &mut Self may be used depending on the level of ownership required.\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\ntrait HasArea {\n    fn area(&self) -> f64;\n\n    fn is_larger(&self, &Self) -> bool;\n}\n\nimpl HasArea for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n\n    fn is_larger(&self, other: &Self) -> bool {\n        self.area() > other.area()\n    }\n}\nTrait bounds on generic functions\n\nTraits are useful because they allow a type to make certain promises about its behavior. Generic functions can exploit this to constrain, or bound, the types they accept. Consider this function, which does not compile:\n\nfn print_area<T>(shape: T) {\n    println!(\"This shape has an area of {}\", shape.area());\n}\n\n\nRust complains:\n\nerror: no method named `area` found for type `T` in the current scope\n\n\nBecause T can be any type, we can‚Äôt be sure that it implements the area method. But we can add a trait bound to our generic T, ensuring that it does:\n\n\nfn print_area<T: HasArea>(shape: T) {\n    println!(\"This shape has an area of {}\", shape.area());\n}\n\nThe syntax <T: HasArea> means ‚Äúany type that implements the HasArea trait.‚Äù Because traits define function type signatures, we can be sure that any type which implements HasArea will have an .area() method.\n\nHere‚Äôs an extended example of how this works:\n\ntrait HasArea {\n    fn area(&self) -> f64;\n}\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl HasArea for Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nstruct Square {\n    x: f64,\n    y: f64,\n    side: f64,\n}\n\nimpl HasArea for Square {\n    fn area(&self) -> f64 {\n        self.side * self.side\n    }\n}\n\nfn print_area<T: HasArea>(shape: T) {\n    println!(\"This shape has an area of {}\", shape.area());\n}\n\nfn main() {\n    let c = Circle {\n        x: 0.0f64,\n        y: 0.0f64,\n        radius: 1.0f64,\n    };\n\n    let s = Square {\n        x: 0.0f64,\n        y: 0.0f64,\n        side: 1.0f64,\n    };\n\n    print_area(c);\n    print_area(s);\n}\n\n\nThis program outputs:\n\nThis shape has an area of 3.141593\nThis shape has an area of 1\n\n\nAs you can see, print_area is now generic, but also ensures that we have passed in the correct types. If we pass in an incorrect type:\n\nprint_area(5);\n\n\nWe get a compile-time error:\n\nerror: the trait bound `_ : HasArea` is not satisfied [E0277]\n\nTrait bounds on generic structs\n\nYour generic structs can also benefit from trait bounds. All you need to do is append the bound when you declare type parameters. Here is a new type Rectangle<T> and its operation is_square():\n\nstruct Rectangle<T> {\n    x: T,\n    y: T,\n    width: T,\n    height: T,\n}\n\nimpl<T: PartialEq> Rectangle<T> {\n    fn is_square(&self) -> bool {\n        self.width == self.height\n    }\n}\n\nfn main() {\n    let mut r = Rectangle {\n        x: 0,\n        y: 0,\n        width: 47,\n        height: 47,\n    };\n\n    assert!(r.is_square());\n\n    r.height = 42;\n    assert!(!r.is_square());\n}\n\n\nis_square() needs to check that the sides are equal, so the sides must be of a type that implements the core::cmp::PartialEq trait:\n\nimpl<T: PartialEq> Rectangle<T> { ... }\n\n\nNow, a rectangle can be defined in terms of any type that can be compared for equality.\n\nHere we defined a new struct Rectangle that accepts numbers of any precision‚Äîreally, objects of pretty much any type‚Äîas long as they can be compared for equality. Could we do the same for our HasArea structs, Square and Circle? Yes, but they need multiplication, and to work with that we need to know more about operator traits.\n\nRules for implementing traits\n\nSo far, we‚Äôve only added trait implementations to structs, but you can implement a trait for any type such as f32:\n\n\ntrait ApproxEqual {\n    fn approx_equal(&self, other: &Self) -> bool;\n}\nimpl ApproxEqual for f32 {\n    fn approx_equal(&self, other: &Self) -> bool {\n        // Appropriate for `self` and `other` being close to 1.0.\n        (self - other).abs() <= ::std::f32::EPSILON\n    }\n}\n\nprintln!(\"{}\", 1.0.approx_equal(&1.00000001));\n\nThis may seem like the Wild West, but there are two restrictions around implementing traits that prevent this from getting out of hand. The first is that if the trait isn‚Äôt defined in your scope, it doesn‚Äôt apply. Here‚Äôs an example: the standard library provides a Write trait which adds extra functionality to Files, for doing file I/O. By default, a File won‚Äôt have its methods:\n\nlet mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn‚Äôt create foo.txt\");\nlet buf = b\"whatever\"; // buf: &[u8; 8], a byte string literal.\nlet result = f.write(buf);\n\n\nHere‚Äôs the error:\n\nerror: type `std::fs::File` does not implement any method in scope named `write`\nlet result = f.write(buf);\n               ^~~~~~~~~~\n\n\nWe need to use the Write trait first:\n\n\nuse std::io::Write;\n\nlet mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn‚Äôt create foo.txt\");\nlet buf = b\"whatever\";\nlet result = f.write(buf);\n\nThis will compile without error.\n\nThis means that even if someone does something bad like add methods to i32, it won‚Äôt affect you, unless you use that trait.\n\nThere‚Äôs one more restriction on implementing traits: either the trait or the type you‚Äôre implementing it for must be defined by you. Or more precisely, one of them must be defined in the same crate as the impl you're writing. For more on Rust's module and package system, see the chapter on crates and modules.\n\nSo, we could implement the HasArea type for i32, because we defined HasArea in our code. But if we tried to implement ToString, a trait provided by Rust, for i32, we could not, because neither the trait nor the type are defined in our crate.\n\nOne last thing about traits: generic functions with a trait bound use ‚Äòmonomorphization‚Äô (mono: one, morph: form), so they are statically dispatched. What‚Äôs that mean? Check out the chapter on trait objects for more details.\n\nMultiple trait bounds\n\nYou‚Äôve seen that you can bound a generic type parameter with a trait:\n\n\nfn foo<T: Clone>(x: T) {\n    x.clone();\n}\n\nIf you need more than one bound, you can use +:\n\n\nuse std::fmt::Debug;\n\nfn foo<T: Clone + Debug>(x: T) {\n    x.clone();\n    println!(\"{:?}\", x);\n}\n\nT now needs to be both Clone as well as Debug.\n\nWhere clause\n\nWriting functions with only a few generic types and a small number of trait bounds isn‚Äôt too bad, but as the number increases, the syntax gets increasingly awkward:\n\n\nuse std::fmt::Debug;\n\nfn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nThe name of the function is on the far left, and the parameter list is on the far right. The bounds are getting in the way.\n\nRust has a solution, and it‚Äôs called a ‚Äòwhere clause‚Äô:\n\nuse std::fmt::Debug;\n\nfn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nfn bar<T, K>(x: T, y: K) where T: Clone, K: Clone + Debug {\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nfn main() {\n    foo(\"Hello\", \"world\");\n    bar(\"Hello\", \"world\");\n}\n\n\nfoo() uses the syntax we showed earlier, and bar() uses a where clause. All you need to do is leave off the bounds when defining your type parameters, and then add where after the parameter list. For longer lists, whitespace can be added:\n\n\nuse std::fmt::Debug;\n\nfn bar<T, K>(x: T, y: K)\n    where T: Clone,\n          K: Clone + Debug {\n\n    x.clone();\n    y.clone();\n    println!(\"{:?}\", y);\n}\n\nThis flexibility can add clarity in complex situations.\n\nwhere is also more powerful than the simpler syntax. For example:\n\n\ntrait ConvertTo<Output> {\n    fn convert(&self) -> Output;\n}\n\nimpl ConvertTo<i64> for i32 {\n    fn convert(&self) -> i64 { *self as i64 }\n}\n\n// Can be called with T == i32.\nfn convert_t_to_i64<T: ConvertTo<i64>>(x: T) -> i64 {\n    x.convert()\n}\n\n// Can be called with T == i64.\nfn convert_i32_to_t<T>(x: i32) -> T\n        // This is using ConvertTo as if it were \"ConvertTo<i64>\".\n        where i32: ConvertTo<T> {\n    x.convert()\n}\n\nThis shows off the additional feature of where clauses: they allow bounds on the left-hand side not only of type parameters T, but also of types (i32 in this case). In this example, i32 must implement ConvertTo<T>. Rather than defining what i32 is (since that's obvious), the where clause here constrains T.\n\nDefault methods\n\nA default method can be added to a trait definition if it is already known how a typical implementor will define a method. For example, is_invalid() is defined as the opposite of is_valid():\n\n\ntrait Foo {\n    fn is_valid(&self) -> bool;\n\n    fn is_invalid(&self) -> bool { !self.is_valid() }\n}\n\nImplementors of the Foo trait need to implement is_valid() but not is_invalid() due to the added default behavior. This default behavior can still be overridden as in:\n\n\nstruct UseDefault;\n\nimpl Foo for UseDefault {\n    fn is_valid(&self) -> bool {\n        println!(\"Called UseDefault.is_valid.\");\n        true\n    }\n}\n\nstruct OverrideDefault;\n\nimpl Foo for OverrideDefault {\n    fn is_valid(&self) -> bool {\n        println!(\"Called OverrideDefault.is_valid.\");\n        true\n    }\n\n    fn is_invalid(&self) -> bool {\n        println!(\"Called OverrideDefault.is_invalid!\");\n        true // Overrides the expected value of `is_invalid()`.\n    }\n}\n\nlet default = UseDefault;\nassert!(!default.is_invalid()); // Prints \"Called UseDefault.is_valid.\"\n\nlet over = OverrideDefault;\nassert!(over.is_invalid()); // Prints \"Called OverrideDefault.is_invalid!\"\nInheritance\n\nSometimes, implementing a trait requires implementing another trait:\n\n\ntrait Foo {\n    fn foo(&self);\n}\n\ntrait FooBar : Foo {\n    fn foobar(&self);\n}\n\nImplementors of FooBar must also implement Foo, like this:\n\n\nstruct Baz;\n\nimpl Foo for Baz {\n    fn foo(&self) { println!(\"foo\"); }\n}\n\nimpl FooBar for Baz {\n    fn foobar(&self) { println!(\"foobar\"); }\n}\n\nIf we forget to implement Foo, Rust will tell us:\n\nerror: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]\n\nDeriving\n\nImplementing traits like Debug and Default repeatedly can become quite tedious. For that reason, Rust provides an attribute that allows you to let Rust automatically implement traits for you:\n\n#[derive(Debug)]\nstruct Foo;\n\nfn main() {\n    println!(\"{:?}\", Foo);\n}\n\n\nHowever, deriving is limited to a certain set of traits:\n\nClone\nCopy\nDebug\nDefault\nEq\nHash\nOrd\nPartialEq\nPartialOrd"
  },
  {
    "title": "Generics - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/generics.html",
    "html": "Generics\n\nSometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics. Generics are called ‚Äòparametric polymorphism‚Äô in type theory, which means that they are types or functions that have multiple forms (‚Äòpoly‚Äô is multiple, ‚Äòmorph‚Äô is form) over a given parameter (‚Äòparametric‚Äô).\n\nAnyway, enough type theory, let‚Äôs check out some generic code. Rust‚Äôs standard library provides a type, Option<T>, that‚Äôs generic:\n\n\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nThe <T> part, which you‚Äôve seen a few times before, indicates that this is a generic data type. Inside the declaration of our enum, wherever we see a T, we substitute that type for the same type used in the generic. Here‚Äôs an example of using Option<T>, with some extra type annotations:\n\n\nlet x: Option<i32> = Some(5);\n\nIn the type declaration, we say Option<i32>. Note how similar this looks to Option<T>. So, in this particular Option, T has the value of i32. On the right-hand side of the binding, we make a Some(T), where T is 5. Since that‚Äôs an i32, the two sides match, and Rust is happy. If they didn‚Äôt match, we‚Äôd get an error:\n\nlet x: Option<f64> = Some(5);\n// error: mismatched types: expected `core::option::Option<f64>`,\n// found `core::option::Option<_>` (expected f64 but found integral variable)\n\n\nThat doesn‚Äôt mean we can‚Äôt make Option<T>s that hold an f64! They have to match up:\n\n\nlet x: Option<i32> = Some(5);\nlet y: Option<f64> = Some(5.0f64);\n\nThis is just fine. One definition, multiple uses.\n\nGenerics don‚Äôt have to only be generic over one type. Consider another type from Rust‚Äôs standard library that‚Äôs similar, Result<T, E>:\n\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nThis type is generic over two types: T and E. By the way, the capital letters can be any letter you‚Äôd like. We could define Result<T, E> as:\n\n\nenum Result<A, Z> {\n    Ok(A),\n    Err(Z),\n}\n\nif we wanted to. Convention says that the first generic parameter should be T, for ‚Äòtype‚Äô, and that we use E for ‚Äòerror‚Äô. Rust doesn‚Äôt care, however.\n\nThe Result<T, E> type is intended to be used to return the result of a computation, and to have the ability to return an error if it didn‚Äôt work out.\n\nGeneric functions\n\nWe can write functions that take generic types with a similar syntax:\n\n\nfn takes_anything<T>(x: T) {\n    // Do something with `x`.\n}\n\nThe syntax has two parts: the <T> says ‚Äúthis function is generic over one type, T‚Äù, and the x: T says ‚Äúx has the type T.‚Äù\n\nMultiple arguments can have the same generic type:\n\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) {\n    // ...\n}\n\nWe could write a version that takes multiple types:\n\n\nfn takes_two_things<T, U>(x: T, y: U) {\n    // ...\n}\nGeneric structs\n\nYou can store a generic type in a struct as well:\n\n\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nlet int_origin = Point { x: 0, y: 0 };\nlet float_origin = Point { x: 0.0, y: 0.0 };\n\nSimilar to functions, the <T> is where we declare the generic parameters, and we then use x: T in the type declaration, too.\n\nWhen you want to add an implementation for the generic struct, you declare the type parameter after the impl:\n\n\nimpl<T> Point<T> {\n    fn swap(&mut self) {\n        std::mem::swap(&mut self.x, &mut self.y);\n    }\n}\n\nSo far you‚Äôve seen generics that take absolutely any type. These are useful in many cases: you‚Äôve already seen Option<T>, and later you‚Äôll meet universal container types like Vec<T>. On the other hand, often you want to trade that flexibility for increased expressive power. Read about trait bounds to see why and how.\n\nResolving ambiguities\n\nMost of the time when generics are involved, the compiler can infer the generic parameters automatically:\n\n\n// v must be a Vec<T> but we don't know what T is yet\nlet mut v = Vec::new();\n// v just got a bool value, so T must be bool!\nv.push(true);\n// Debug-print v\nprintln!(\"{:?}\", v);\n\nSometimes though, the compiler needs a little help. For example, had we omitted the last line, we would get a compile error:\n\nlet v = Vec::new();\n//      ^^^^^^^^ cannot infer type for `T`\n//\n// note: type annotations or generic parameter binding required\nprintln!(\"{:?}\", v);\n\n\nWe can solve this using either a type annotation:\n\n\nlet v: Vec<bool> = Vec::new();\nprintln!(\"{:?}\", v);\n\nor by binding the generic parameter T via the so-called ‚Äòturbofish‚Äô ::<> syntax:\n\n\nlet v = Vec::<bool>::new();\nprintln!(\"{:?}\", v);\n\nThe second approach is useful in situations where we don‚Äôt want to bind the result to a variable. It can also be used to bind generic parameters in functions or methods. See Iterators ¬ß Consumers for an example."
  },
  {
    "title": "Strings - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/strings.html",
    "html": "Strings\n\nStrings are an important concept for any programmer to master. Rust‚Äôs string handling system is a bit different from other languages, due to its systems focus. Any time you have a data structure of variable size, things can get tricky, and strings are a re-sizable data structure. That being said, Rust‚Äôs strings also work differently than in some other systems languages, such as C.\n\nLet‚Äôs dig into the details. A ‚Äòstring‚Äô is a sequence of Unicode scalar values encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid encoding of UTF-8 sequences. Additionally, unlike some systems languages, strings are not NUL-terminated and can contain NUL bytes.\n\nRust has two main types of strings: &str and String. Let‚Äôs talk about &str first. These are called ‚Äòstring slices‚Äô. A string slice has a fixed size, and cannot be mutated. It is a reference to a sequence of UTF-8 bytes.\n\n\nlet greeting = \"Hello there.\"; // greeting: &'static str\n\n\"Hello there.\" is a string literal and its type is &'static str. A string literal is a string slice that is statically allocated, meaning that it‚Äôs saved inside our compiled program, and exists for the entire duration it runs. The greeting binding is a reference to this statically allocated string. Any function expecting a string slice will also accept a string literal.\n\nString literals can span multiple lines. There are two forms. The first will include the newline and the leading spaces:\n\n\nlet s = \"foo\n    bar\";\n\nassert_eq!(\"foo\\n    bar\", s);\n\nThe second, with a \\, trims the spaces and the newline:\n\n\nlet s = \"foo\\\n    bar\";\n\nassert_eq!(\"foobar\", s);\n\nNote that you normally cannot access a str directly, but only through a &str reference. This is because str is an unsized type which requires additional runtime information to be usable. For more information see the chapter on unsized types.\n\nRust has more than only &strs though. A String is a heap-allocated string. This string is growable, and is also guaranteed to be UTF-8. Strings are commonly created by converting from a string slice using the to_string method.\n\n\nlet mut s = \"Hello\".to_string(); // mut s: String\nprintln!(\"{}\", s);\n\ns.push_str(\", world.\");\nprintln!(\"{}\", s);\n\nStrings will coerce into &str with an &:\n\nfn takes_slice(slice: &str) {\n    println!(\"Got: {}\", slice);\n}\n\nfn main() {\n    let s = \"Hello\".to_string();\n    takes_slice(&s);\n}\n\n\nThis coercion does not happen for functions that accept one of &str‚Äôs traits instead of &str. For example, TcpStream::connect has a parameter of type ToSocketAddrs. A &str is okay but a String must be explicitly converted using &*.\n\n\nuse std::net::TcpStream;\n\nTcpStream::connect(\"192.168.0.1:3000\"); // Parameter is of type &str.\n\nlet addr_string = \"192.168.0.1:3000\".to_string();\nTcpStream::connect(&*addr_string); // Convert `addr_string` to &str.\n\nViewing a String as a &str is cheap, but converting the &str to a String involves allocating memory. No reason to do that unless you have to!\n\nIndexing\n\nBecause strings are valid UTF-8, they do not support indexing:\n\nlet s = \"hello\";\n\nprintln!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n\n\nUsually, access to a vector with [] is very fast. But, because each character in a UTF-8 encoded string can be multiple bytes, you have to walk over the string to find the n·µó ∞ letter of a string. This is a significantly more expensive operation, and we don‚Äôt want to be misleading. Furthermore, ‚Äòletter‚Äô isn‚Äôt something defined in Unicode, exactly. We can choose to look at a string as individual bytes, or as codepoints:\n\n\nlet hachiko = \"Âø†Áä¨„Éè„ÉÅÂÖ¨\";\n\nfor b in hachiko.as_bytes() {\n    print!(\"{}, \", b);\n}\n\nprintln!(\"\");\n\nfor c in hachiko.chars() {\n    print!(\"{}, \", c);\n}\n\nprintln!(\"\");\n\nThis prints:\n\n229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,\nÂø†, Áä¨, „Éè, „ÉÅ, ÂÖ¨,\n\n\nAs you can see, there are more bytes than chars.\n\nYou can get something similar to an index like this:\n\n\nlet dog = hachiko.chars().nth(1); // Kinda like `hachiko[1]`.\n\nThis emphasizes that we have to walk from the beginning of the list of chars.\n\nSlicing\n\nYou can get a slice of a string with the slicing syntax:\n\n\nlet dog = \"hachiko\";\nlet hachi = &dog[0..5];\n\nBut note that these are byte offsets, not character offsets. So this will fail at runtime:\n\n\nlet dog = \"Âø†Áä¨„Éè„ÉÅÂÖ¨\";\nlet hachi = &dog[0..2];\n\nwith this error:\n\nthread 'main' panicked at 'byte index 2 is not a char boundary; it is inside 'Âø†'\n(bytes 0..3) of `Âø†Áä¨„Éè„ÉÅÂÖ¨`'\n\nConcatenation\n\nIf you have a String, you can concatenate a &str to the end of it:\n\n\nlet hello = \"Hello \".to_string();\nlet world = \"world!\";\n\nlet hello_world = hello + world;\n\nBut if you have two Strings, you need an &:\n\n\nlet hello = \"Hello \".to_string();\nlet world = \"world!\".to_string();\n\nlet hello_world = hello + &world;\n\nThis is because &String can automatically coerce to a &str. This is a feature called ‚ÄòDeref coercions‚Äô."
  },
  {
    "title": "Method Syntax - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/method-syntax.html",
    "html": "Method Syntax\n\nFunctions are great, but if you want to call a bunch of them on some data, it can be awkward. Consider this code:\n\nbaz(bar(foo));\n\n\nWe would read this left-to-right, and so we see ‚Äòbaz bar foo‚Äô. But this isn‚Äôt the order that the functions would get called in, that‚Äôs inside-out: ‚Äòfoo bar baz‚Äô. Wouldn‚Äôt it be nice if we could do this instead?\n\nfoo.bar().baz();\n\n\nLuckily, as you may have guessed with the leading question, you can! Rust provides the ability to use this ‚Äòmethod call syntax‚Äô via the impl keyword.\n\nMethod calls\n\nHere‚Äôs how it works:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nfn main() {\n    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n    println!(\"{}\", c.area());\n}\n\n\nThis will print 12.566371.\n\nWe‚Äôve made a struct that represents a circle. We then write an impl block, and inside it, define a method, area.\n\nMethods take a special first parameter, of which there are three variants: self, &self, and &mut self. You can think of this first parameter as being the foo in foo.bar(). The three variants correspond to the three kinds of things foo could be: self if it‚Äôs a value on the stack, &self if it‚Äôs a reference, and &mut self if it‚Äôs a mutable reference. Because we took the &self parameter to area, we can use it like any other parameter. Because we know it‚Äôs a Circle, we can access the radius like we would with any other struct.\n\nWe should default to using &self, as you should prefer borrowing over taking ownership, as well as taking immutable references over mutable ones. Here‚Äôs an example of all three variants:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn reference(&self) {\n       println!(\"taking self by reference!\");\n    }\n\n    fn mutable_reference(&mut self) {\n       println!(\"taking self by mutable reference!\");\n    }\n\n    fn takes_ownership(self) {\n       println!(\"taking ownership of self!\");\n    }\n}\n\nYou can use as many impl blocks as you‚Äôd like. The previous example could have also been written like this:\n\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn reference(&self) {\n       println!(\"taking self by reference!\");\n    }\n}\n\nimpl Circle {\n    fn mutable_reference(&mut self) {\n       println!(\"taking self by mutable reference!\");\n    }\n}\n\nimpl Circle {\n    fn takes_ownership(self) {\n       println!(\"taking ownership of self!\");\n    }\n}\nChaining method calls\n\nSo, now we know how to call a method, such as foo.bar(). But what about our original example, foo.bar().baz()? This is called ‚Äòmethod chaining‚Äô. Let‚Äôs look at an example:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n\n    fn grow(&self, increment: f64) -> Circle {\n        Circle { x: self.x, y: self.y, radius: self.radius + increment }\n    }\n}\n\nfn main() {\n    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n    println!(\"{}\", c.area());\n\n    let d = c.grow(2.0).area();\n    println!(\"{}\", d);\n}\n\n\nCheck the return type:\n\n\nfn grow(&self, increment: f64) -> Circle {\n\nWe say we‚Äôre returning a Circle. With this method, we can grow a new Circle to any arbitrary size.\n\nAssociated functions\n\nYou can also define associated functions that do not take a self parameter. Here‚Äôs a pattern that‚Äôs very common in Rust code:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn new(x: f64, y: f64, radius: f64) -> Circle {\n        Circle {\n            x: x,\n            y: y,\n            radius: radius,\n        }\n    }\n}\n\nfn main() {\n    let c = Circle::new(0.0, 0.0, 2.0);\n}\n\n\nThis ‚Äòassociated function‚Äô builds a new Circle for us. Note that associated functions are called with the Struct::function() syntax, rather than the ref.method() syntax. Some other languages call associated functions ‚Äòstatic methods‚Äô.\n\nBuilder Pattern\n\nLet‚Äôs say that we want our users to be able to create Circles, but we will allow them to only set the properties they care about. Otherwise, the x and y attributes will be 0.0, and the radius will be 1.0. Rust doesn‚Äôt have method overloading, named arguments, or variable arguments. We employ the builder pattern instead. It looks like this:\n\nstruct Circle {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl Circle {\n    fn area(&self) -> f64 {\n        std::f64::consts::PI * (self.radius * self.radius)\n    }\n}\n\nstruct CircleBuilder {\n    x: f64,\n    y: f64,\n    radius: f64,\n}\n\nimpl CircleBuilder {\n    fn new() -> CircleBuilder {\n        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }\n    }\n\n    fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {\n        self.x = coordinate;\n        self\n    }\n\n    fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {\n        self.y = coordinate;\n        self\n    }\n\n    fn radius(&mut self, radius: f64) -> &mut CircleBuilder {\n        self.radius = radius;\n        self\n    }\n\n    fn finalize(&self) -> Circle {\n        Circle { x: self.x, y: self.y, radius: self.radius }\n    }\n}\n\nfn main() {\n    let c = CircleBuilder::new()\n                .x(1.0)\n                .y(2.0)\n                .radius(2.0)\n                .finalize();\n\n    println!(\"area: {}\", c.area());\n    println!(\"x: {}\", c.x);\n    println!(\"y: {}\", c.y);\n}\n\n\nWhat we‚Äôve done here is make another struct, CircleBuilder. We‚Äôve defined our builder methods on it. We‚Äôve also defined our area() method on Circle. We also made one more method on CircleBuilder: finalize(). This method creates our final Circle from the builder. Now, we‚Äôve used the type system to enforce our concerns: we can use the methods on CircleBuilder to constrain making Circles in any way we choose."
  },
  {
    "title": "Patterns - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/patterns.html",
    "html": "Patterns\n\nPatterns are quite common in Rust. We use them in variable bindings, match expressions, and other places, too. Let‚Äôs go on a whirlwind tour of all of the things patterns can do!\n\nA quick refresher: you can match against literals directly, and _ acts as an ‚Äòany‚Äô case:\n\n\nlet x = 1;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n\nThis prints one.\n\nIt's possible to create a binding for the value in the any case:\n\n\nlet x = 1;\n\nmatch x {\n    y => println!(\"x: {} y: {}\", x, y),\n}\n\nThis prints:\n\nx: 1 y: 1\n\n\nNote it is an error to have both a catch-all _ and a catch-all binding in the same match block:\n\n\nlet x = 1;\n\nmatch x {\n    y => println!(\"x: {} y: {}\", x, y),\n    _ => println!(\"anything\"), // this causes an error as it is unreachable\n}\n\nThere‚Äôs one pitfall with patterns: like anything that introduces a new binding, they introduce shadowing. For example:\n\n\nlet x = 1;\nlet c = 'c';\n\nmatch c {\n    x => println!(\"x: {} c: {}\", x, c),\n}\n\nprintln!(\"x: {}\", x)\n\nThis prints:\n\nx: c c: c\nx: 1\n\n\nIn other words, x => matches the pattern and introduces a new binding named x. This new binding is in scope for the match arm and takes on the value of c. Notice that the value of x outside the scope of the match has no bearing on the value of x within it. Because we already have a binding named x, this new x shadows it.\n\nMultiple patterns\n\nYou can match multiple patterns with |:\n\n\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n\nThis prints one or two.\n\nDestructuring\n\nIf you have a compound data type, like a struct, you can destructure it inside of a pattern:\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet origin = Point { x: 0, y: 0 };\n\nmatch origin {\n    Point { x, y } => println!(\"({},{})\", x, y),\n}\n\nWe can use : to give a value a different name.\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet origin = Point { x: 0, y: 0 };\n\nmatch origin {\n    Point { x: x1, y: y1 } => println!(\"({},{})\", x1, y1),\n}\n\nIf we only care about some of the values, we don‚Äôt have to give them all names:\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet point = Point { x: 2, y: 3 };\n\nmatch point {\n    Point { x, .. } => println!(\"x is {}\", x),\n}\n\nThis prints x is 2.\n\nYou can do this kind of match on any member, not only the first:\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet point = Point { x: 2, y: 3 };\n\nmatch point {\n    Point { y, .. } => println!(\"y is {}\", y),\n}\n\nThis prints y is 3.\n\nThis ‚Äòdestructuring‚Äô behavior works on any compound data type, like tuples or enums.\n\nIgnoring bindings\n\nYou can use _ in a pattern to disregard the type and value. For example, here‚Äôs a match against a Result<T, E>:\n\n\nmatch some_value {\n    Ok(value) => println!(\"got a value: {}\", value),\n    Err(_) => println!(\"an error occurred\"),\n}\n\nIn the first arm, we bind the value inside the Ok variant to value. But in the Err arm, we use _ to disregard the specific error, and print a general error message.\n\n_ is valid in any pattern that creates a binding. This can be useful to ignore parts of a larger structure:\n\n\nfn coordinate() -> (i32, i32, i32) {\n    // Generate and return some sort of triple tuple.\n}\n\nlet (x, _, z) = coordinate();\n\nHere, we bind the first and last element of the tuple to x and z, but ignore the middle element.\n\nIt‚Äôs worth noting that using _ never binds the value in the first place, which means that the value does not move:\n\n\nlet tuple: (u32, String) = (5, String::from(\"five\"));\n\n// Here, tuple is moved, because the String moved:\nlet (x, _s) = tuple;\n\n// The next line would give \"error: use of partially moved value: `tuple`\".\n// println!(\"Tuple is: {:?}\", tuple);\n\n// However,\n\nlet tuple = (5, String::from(\"five\"));\n\n// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:\nlet (x, _) = tuple;\n\n// That means this works:\nprintln!(\"Tuple is: {:?}\", tuple);\n\nThis also means that any temporary variables will be dropped at the end of the statement:\n\n\n// Here, the String created will be dropped immediately, as it‚Äôs not bound:\n\nlet _ = String::from(\"  hello  \").trim();\n\nYou can also use .. in a pattern to disregard multiple values:\n\n\nenum OptionalTuple {\n    Value(i32, i32, i32),\n    Missing,\n}\n\nlet x = OptionalTuple::Value(5, -2, 3);\n\nmatch x {\n    OptionalTuple::Value(..) => println!(\"Got a tuple!\"),\n    OptionalTuple::Missing => println!(\"No such luck.\"),\n}\n\nThis prints Got a tuple!.\n\nref and ref mut\n\nIf you want to get a reference, use the ref keyword:\n\n\nlet x = 5;\n\nmatch x {\n    ref r => println!(\"Got a reference to {}\", r),\n}\n\nThis prints Got a reference to 5.\n\nHere, the r inside the match has the type &i32. In other words, the ref keyword creates a reference, for use in the pattern. If you need a mutable reference, ref mut will work in the same way:\n\n\nlet mut x = 5;\n\nmatch x {\n    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n}\nRanges\n\nYou can match a range of values with ...:\n\n\nlet x = 1;\n\nmatch x {\n    1 ... 5 => println!(\"one through five\"),\n    _ => println!(\"anything\"),\n}\n\nThis prints one through five.\n\nRanges are mostly used with integers and chars:\n\n\nlet x = 'üíÖ';\n\nmatch x {\n    'a' ... 'j' => println!(\"early letter\"),\n    'k' ... 'z' => println!(\"late letter\"),\n    _ => println!(\"something else\"),\n}\n\nThis prints something else.\n\nBindings\n\nYou can bind values to names with @:\n\n\nlet x = 1;\n\nmatch x {\n    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n    _ => println!(\"anything\"),\n}\n\nThis prints got a range element 1. This is useful when you want to do a complicated match of part of a data structure:\n\n\n#[derive(Debug)]\nstruct Person {\n    name: Option<String>,\n}\n\nlet name = \"Steve\".to_string();\nlet x: Option<Person> = Some(Person { name: Some(name) });\nmatch x {\n    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n    _ => {}\n}\n\nThis prints Some(\"Steve\"): we‚Äôve bound the inner name to a.\n\nIf you use @ with |, you need to make sure the name is bound in each part of the pattern:\n\n\nlet x = 5;\n\nmatch x {\n    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n    _ => println!(\"anything\"),\n}\nGuards\n\nYou can introduce ‚Äòmatch guards‚Äô with if:\n\n\nenum OptionalInt {\n    Value(i32),\n    Missing,\n}\n\nlet x = OptionalInt::Value(5);\n\nmatch x {\n    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n    OptionalInt::Value(..) => println!(\"Got an int!\"),\n    OptionalInt::Missing => println!(\"No such luck.\"),\n}\n\nThis prints Got an int!.\n\nIf you‚Äôre using if with multiple patterns, the if applies to both sides:\n\n\nlet x = 4;\nlet y = false;\n\nmatch x {\n    4 | 5 if y => println!(\"yes\"),\n    _ => println!(\"no\"),\n}\n\nThis prints no, because the if applies to the whole of 4 | 5, and not to only the 5. In other words, the precedence of if behaves like this:\n\n(4 | 5) if y => ...\n\n\nnot this:\n\n4 | (5 if y) => ...\n\nMix and Match\n\nWhew! That‚Äôs a lot of different ways to match things, and they can all be mixed and matched, depending on what you‚Äôre doing:\n\nmatch x {\n    Foo { x: Some(ref name), y: None } => ...\n}\n\n\nPatterns are very powerful. Make good use of them."
  },
  {
    "title": "Match - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/match.html",
    "html": "Match\n\nOften, a simple if/else isn‚Äôt enough, because you have more than two possible options. Also, conditions can get quite complex. Rust has a keyword, match, that allows you to replace complicated if/else groupings with something more powerful. Check it out:\n\n\nlet x = 5;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    4 => println!(\"four\"),\n    5 => println!(\"five\"),\n    _ => println!(\"something else\"),\n}\n\nmatch takes an expression and then branches based on its value. Each ‚Äòarm‚Äô of the branch is of the form val => expression. When the value matches, that arm‚Äôs expression will be evaluated. It‚Äôs called match because of the term ‚Äòpattern matching‚Äô, which match is an implementation of. There‚Äôs a separate section on patterns that covers all the patterns that are possible here.\n\nOne of the many advantages of match is it enforces ‚Äòexhaustiveness checking‚Äô. For example if we remove the last arm with the underscore _, the compiler will give us an error:\n\nerror: non-exhaustive patterns: `_` not covered\n\n\nRust is telling us that we forgot some value. The compiler infers from x that it can have any 32bit integer value; for example -2,147,483,648 to 2,147,483,647. The _ acts as a 'catch-all', and will catch all possible values that aren't specified in an arm of match. As you can see in the previous example, we provide match arms for integers 1-5, if x is 6 or any other value, then it is caught by _.\n\nmatch is also an expression, which means we can use it on the right-hand side of a let binding or directly where an expression is used:\n\n\nlet x = 5;\n\nlet number = match x {\n    1 => \"one\",\n    2 => \"two\",\n    3 => \"three\",\n    4 => \"four\",\n    5 => \"five\",\n    _ => \"something else\",\n};\n\nSometimes it‚Äôs a nice way of converting something from one type to another; in this example the integers are converted to String.\n\nMatching on enums\n\nAnother important use of the match keyword is to process the possible variants of an enum:\n\n\nenum Message {\n    Quit,\n    ChangeColor(i32, i32, i32),\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n\nfn quit() { /* ... */ }\nfn change_color(r: i32, g: i32, b: i32) { /* ... */ }\nfn move_cursor(x: i32, y: i32) { /* ... */ }\n\nfn process_message(msg: Message) {\n    match msg {\n        Message::Quit => quit(),\n        Message::ChangeColor(r, g, b) => change_color(r, g, b),\n        Message::Move { x, y: new_name_for_y } => move_cursor(x, new_name_for_y),\n        Message::Write(s) => println!(\"{}\", s),\n    };\n}\n\nAgain, the Rust compiler checks exhaustiveness, so it demands that you have a match arm for every variant of the enum. If you leave one off, it will give you a compile-time error unless you use _ or provide all possible arms.\n\nUnlike the previous uses of match, you can‚Äôt use the normal if statement to do this. You can use the if let statement, which can be seen as an abbreviated form of match."
  },
  {
    "title": "Enums - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/enums.html",
    "html": "Enums\n\nAn enum in Rust is a type that represents data that is one of several possible variants. Each variant in the enum can optionally have data associated with it:\n\n\nenum Message {\n    Quit,\n    ChangeColor(i32, i32, i32),\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n\nThe syntax for defining variants resembles the syntaxes used to define structs: you can have variants with no data (like unit-like structs), variants with named data, and variants with unnamed data (like tuple structs). Unlike separate struct definitions, however, an enum is a single type. A value of the enum can match any of the variants. For this reason, an enum is sometimes called a ‚Äòsum type‚Äô: the set of possible values of the enum is the sum of the sets of possible values for each variant.\n\nWe use the :: syntax to use the name of each variant: they‚Äôre scoped by the name of the enum itself. This allows both of these to work:\n\n\nlet x: Message = Message::Move { x: 3, y: 4 };\n\nenum BoardGameTurn {\n    Move { squares: i32 },\n    Pass,\n}\n\nlet y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };\n\nBoth variants are named Move, but since they‚Äôre scoped to the name of the enum, they can both be used without conflict.\n\nA value of an enum type contains information about which variant it is, in addition to any data associated with that variant. This is sometimes referred to as a ‚Äòtagged union‚Äô, since the data includes a ‚Äòtag‚Äô indicating what type it is. The compiler uses this information to enforce that you‚Äôre accessing the data in the enum safely. For instance, you can‚Äôt simply try to destructure a value as if it were one of the possible variants:\n\nfn process_color_change(msg: Message) {\n    let Message::ChangeColor(r, g, b) = msg; // This causes a compile-time error.\n}\n\n\nNot supporting these operations may seem rather limiting, but it‚Äôs a limitation which we can overcome. There are two ways: by implementing equality ourselves, or by pattern matching variants with match expressions, which you‚Äôll learn in the next section. We don‚Äôt know enough about Rust to implement equality yet, but we‚Äôll find out in the traits section.\n\nConstructors as functions\n\nAn enum constructor can also be used like a function. For example:\n\n\nlet m = Message::Write(\"Hello, world\".to_string());\n\nis the same as\n\n\nfn foo(x: String) -> Message {\n    Message::Write(x)\n}\n\nlet x = foo(\"Hello, world\".to_string());\n\nThis is not immediately useful to us, but when we get to closures, we‚Äôll talk about passing functions as arguments to other functions. For example, with iterators, we can do this to convert a vector of Strings into a vector of Message::Writes:\n\n\n\nlet v = vec![\"Hello\".to_string(), \"World\".to_string()];\n\nlet v1: Vec<Message> = v.into_iter().map(Message::Write).collect();"
  },
  {
    "title": "Structs - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/structs.html",
    "html": "Structs\n\nstructs are a way of creating more complex data types. For example, if we were doing calculations involving coordinates in 2D space, we would need both an x and a y value:\n\n\nlet origin_x = 0;\nlet origin_y = 0;\n\nA struct lets us combine these two into a single, unified datatype with x and y as field labels:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let origin = Point { x: 0, y: 0 }; // origin: Point\n\n    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n}\n\n\nThere‚Äôs a lot going on here, so let‚Äôs break it down. We declare a struct with the struct keyword, and then with a name. By convention, structs begin with a capital letter and are camel cased: PointInSpace, not Point_In_Space.\n\nWe can create an instance of our struct via let, as usual, but we use a key: value style syntax to set each field. The order doesn‚Äôt need to be the same as in the original declaration.\n\nFinally, because fields have names, we can access them through dot notation: origin.x.\n\nThe values in structs are immutable by default, like other bindings in Rust. Use mut to make them mutable:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    point.x = 5;\n\n    println!(\"The point is at ({}, {})\", point.x, point.y);\n}\n\n\nThis will print The point is at (5, 0).\n\nRust does not support field mutability at the language level, so you cannot write something like this:\n\nstruct Point {\n    mut x: i32, // This causes an error.\n    y: i32,\n}\n\n\nMutability is a property of the binding, not of the structure itself. If you‚Äôre used to field-level mutability, this may seem strange at first, but it significantly simplifies things. It even lets you make things mutable on a temporary basis:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    point.x = 5;\n\n    let point = point; // `point` is now immutable.\n\n    point.y = 6; // This causes an error.\n}\n\n\nYour structure can still contain &mut references, which will let you do some kinds of mutation:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nstruct PointRef<'a> {\n    x: &'a mut i32,\n    y: &'a mut i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    {\n        let r = PointRef { x: &mut point.x, y: &mut point.y };\n\n        *r.x = 5;\n        *r.y = 6;\n    }\n\n    assert_eq!(5, point.x);\n    assert_eq!(6, point.y);\n}\n\n\nInitialization of a data structure (struct, enum, union) can be simplified when fields of the data structure are initialized with variables of the same names as the fields.\n\n#[derive(Debug)]\nstruct Person<'a> {\n    name: &'a str,\n    age: u8\n}\n\nfn main() {\n    // Create struct with field init shorthand\n    let name = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n\n    // Debug-print struct\n    println!(\"{:?}\", peter);\n}\n\nUpdate syntax\n\nA struct can include .. to indicate that you want to use a copy of some other struct for some of the values. For example:\n\n\nstruct Point3d {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet mut point = Point3d { x: 0, y: 0, z: 0 };\npoint = Point3d { y: 1, .. point };\n\nThis gives point a new y, but keeps the old x and z values. It doesn‚Äôt have to be the same struct either, you can use this syntax when making new ones, and it will copy the values you don‚Äôt specify:\n\n\nlet origin = Point3d { x: 0, y: 0, z: 0 };\nlet point = Point3d { z: 1, x: 2, .. origin };\nTuple structs\n\nRust has another data type that‚Äôs like a hybrid between a tuple and a struct, called a ‚Äòtuple struct‚Äô. Tuple structs have a name, but their fields don't. They are declared with the struct keyword, and then with a name followed by a tuple:\n\n\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n\nHere, black and origin are not the same type, even though they contain the same values.\n\nThe members of a tuple struct may be accessed by dot notation or destructuring let, just like regular tuples:\n\n\nlet black_r = black.0;\nlet Point(_, origin_y, origin_z) = origin;\n\nPatterns like Point(_, origin_y, origin_z) are also used in match expressions.\n\nOne case when a tuple struct is very useful is when it has only one element. We call this the ‚Äònewtype‚Äô pattern, because it allows you to create a new type that is distinct from its contained value and also expresses its own semantic meaning:\n\n\nstruct Inches(i32);\n\nlet length = Inches(10);\n\nlet Inches(integer_length) = length;\nprintln!(\"length is {} inches\", integer_length);\n\nAs above, you can extract the inner integer type through a destructuring let. In this case, the let Inches(integer_length) assigns 10 to integer_length. We could have used dot notation to do the same thing:\n\n\nlet integer_length = length.0;\n\nIt's always possible to use a struct instead of a tuple struct, and can be clearer. We could write Color and Point like this instead:\n\n\nstruct Color {\n    red: i32,\n    blue: i32,\n    green: i32,\n}\n\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nGood names are important, and while values in a tuple struct can be referenced with dot notation as well, a struct gives us actual names, rather than positions.\n\nUnit-like structs\n\nYou can define a struct with no members at all:\n\nstruct Electron {} // Use empty braces...\nstruct Proton;     // ...or just a semicolon.\n\n// Use the same notation when creating an instance.\nlet x = Electron {};\nlet y = Proton;\nlet z = Electron; // Error\n\n\nSuch a struct is called ‚Äòunit-like‚Äô because it resembles the empty tuple, (), sometimes called ‚Äòunit‚Äô. Like a tuple struct, it defines a new type.\n\nThis is rarely useful on its own (although sometimes it can serve as a marker type), but in combination with other features, it can become useful. For instance, a library may ask you to create a structure that implements a certain trait to handle events. If you don‚Äôt have any data you need to store in the structure, you can create a unit-like struct."
  },
  {
    "title": "Mutability - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/mutability.html",
    "html": "Mutability\n\nMutability, the ability to change something, works a bit differently in Rust than in other languages. The first aspect of mutability is its non-default status:\n\nlet x = 5;\nx = 6; // Error!\n\n\nWe can introduce mutability with the mut keyword:\n\n\nlet mut x = 5;\n\nx = 6; // No problem!\n\nThis is a mutable variable binding. When a binding is mutable, it means you‚Äôre allowed to change what the binding points to. So in the above example, it‚Äôs not so much that the value at x is changing, but that the binding changed from one i32 to another.\n\nYou can also create a reference to it, using &x, but if you want to use the reference to change it, you will need a mutable reference:\n\n\nlet mut x = 5;\nlet y = &mut x;\n\ny is an immutable binding to a mutable reference, which means that you can‚Äôt bind 'y' to something else (y = &mut z), but y can be used to bind x to something else (*y = 5). A subtle distinction.\n\nOf course, if you need both:\n\n\nlet mut x = 5;\nlet mut y = &mut x;\n\nNow y can be bound to another value, and the value it‚Äôs referencing can be changed.\n\nIt‚Äôs important to note that mut is part of a pattern, so you can do things like this:\n\n\nlet (mut x, y) = (5, 6);\n\nfn foo(mut x: i32) {\n\nNote that here, the x is mutable, but not the y.\n\nInterior vs. Exterior Mutability\n\nHowever, when we say something is ‚Äòimmutable‚Äô in Rust, that doesn‚Äôt mean that it‚Äôs not able to be changed: we are referring to its ‚Äòexterior mutability‚Äô that in this case is immutable. Consider, for example, Arc<T>:\n\n\nuse std::sync::Arc;\n\nlet x = Arc::new(5);\nlet y = x.clone();\n\nWhen we call clone(), the Arc<T> needs to update the reference count. Yet we‚Äôve not used any muts here, x is an immutable binding, and we didn‚Äôt take &mut 5 or anything. So what gives?\n\nTo understand this, we have to go back to the core of Rust‚Äôs guiding philosophy, memory safety, and the mechanism by which Rust guarantees it, the ownership system, and more specifically, borrowing:\n\nYou may have one or the other of these two kinds of borrows, but not both at the same time:\n\none or more references (&T) to a resource,\nexactly one mutable reference (&mut T).\n\nSo, that‚Äôs the real definition of ‚Äòimmutability‚Äô: is this safe to have two pointers to? In Arc<T>‚Äôs case, yes: the mutation is entirely contained inside the structure itself. It‚Äôs not user facing. For this reason, it hands out &T with clone(). If it handed out &mut Ts, though, that would be a problem.\n\nOther types, like the ones in the std::cell module, have the opposite: interior mutability. For example:\n\n\nuse std::cell::RefCell;\n\nlet x = RefCell::new(42);\n\nlet y = x.borrow_mut();\n\nRefCell hands out &mut references to what‚Äôs inside of it with the borrow_mut() method. Isn‚Äôt that dangerous? What if we do:\n\nuse std::cell::RefCell;\n\nlet x = RefCell::new(42);\n\nlet y = x.borrow_mut();\nlet z = x.borrow_mut();\n\n\nThis will in fact panic, at runtime. This is what RefCell does: it enforces Rust‚Äôs borrowing rules at runtime, and panic!s if they‚Äôre violated. This allows us to get around another aspect of Rust‚Äôs mutability rules. Let‚Äôs talk about it first.\n\nField-level mutability\n\nMutability is a property of either a borrow (&mut) or a binding (let mut). This means that, for example, you cannot have a struct with some fields mutable and some immutable:\n\nstruct Point {\n    x: i32,\n    mut y: i32, // Nope.\n}\n\n\nThe mutability of a struct is in its binding:\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet mut a = Point { x: 5, y: 6 };\n\na.x = 10;\n\nlet b = Point { x: 5, y: 6 };\n\nb.x = 10; // Error: cannot assign to immutable field `b.x`.\n\n\nHowever, by using Cell<T>, you can emulate field-level mutability:\n\n\nuse std::cell::Cell;\n\nstruct Point {\n    x: i32,\n    y: Cell<i32>,\n}\n\nlet point = Point { x: 5, y: Cell::new(6) };\n\npoint.y.set(7);\n\nprintln!(\"y: {:?}\", point.y);\n\nThis will print y: Cell { value: 7 }. We‚Äôve successfully updated y."
  },
  {
    "title": "Lifetimes - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/lifetimes.html",
    "html": "Lifetimes\n\nThis is the last of three sections presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:\n\nownership, the key concept\nborrowing, and their associated feature ‚Äòreferences‚Äô\nlifetimes, which you‚Äôre reading now\n\nThese three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.\n\nMeta\n\nBefore we get to the details, two important notes about the ownership system.\n\nRust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is done at compile time. You do not pay any run-time cost for any of these features.\n\nHowever, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.\n\nWith that in mind, let‚Äôs learn about lifetimes.\n\nLifetimes\n\nLending out a reference to a resource that someone else owns can be complicated. For example, imagine this set of operations:\n\nI acquire a handle to some kind of resource.\nI lend you a reference to the resource.\nI decide I‚Äôm done with the resource, and deallocate it, while you still have your reference.\nYou decide to use the resource.\n\nUh oh! Your reference is pointing to an invalid resource. This is called a dangling pointer or ‚Äòuse after free‚Äô, when the resource is memory. A small example of such a situation would be:\n\nlet r;              // Introduce reference: `r`.\n{\n    let i = 1;      // Introduce scoped value: `i`.\n    r = &i;         // Store reference of `i` in `r`.\n}                   // `i` goes out of scope and is dropped.\n\nprintln!(\"{}\", r);  // `r` still refers to `i`.\n\n\nTo fix this, we have to make sure that step four never happens after step three. In the small example above the Rust compiler is able to report the issue as it can see the lifetimes of the various values in the function.\n\nWhen we have a function that takes arguments by reference the situation becomes more complex. Consider the following example:\n\nfn skip_prefix(line: &str, prefix: &str) -> &str {\n    // ...\n}\n\nlet line = \"lang:en=Hello World!\";\nlet lang = \"en\";\n\nlet v;\n{\n    let p = format!(\"lang:{}=\", lang);  // -+ `p` comes into scope.\n    v = skip_prefix(line, p.as_str());  //  |\n}                                       // -+ `p` goes out of scope.\nprintln!(\"{}\", v);\n\n\nHere we have a function skip_prefix which takes two &str references as parameters and returns a single &str reference. We call it by passing in references to line and p: Two variables with different lifetimes. Now the safety of the println!-line depends on whether the reference returned by skip_prefix function references the still living line or the already dropped p string.\n\nBecause of the above ambiguity, Rust will refuse to compile the example code. To get it to compile we need to tell the compiler more about the lifetimes of the references. This can be done by making the lifetimes explicit in the function declaration:\n\n\nfn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {\n    // ...\n}\n\nLet's examine the changes without going too deep into the syntax for now - we'll get to that later. The first change was adding the <'a, 'b> after the method name. This introduces two lifetime parameters: 'a and 'b. Next, each reference in the function signature was associated with one of the lifetime parameters by adding the lifetime name after the &. This tells the compiler how the lifetimes between different references are related.\n\nAs a result the compiler is now able to deduce that the return value of skip_prefix has the same lifetime as the line parameter, which makes the v reference safe to use even after the p goes out of scope in the original example.\n\nIn addition to the compiler being able to validate the usage of skip_prefix return value, it can also ensure that the implementation follows the contract established by the function declaration. This is useful especially when you are implementing traits that are introduced later in the book.\n\nNote It's important to understand that lifetime annotations are descriptive, not prescriptive. This means that how long a reference is valid is determined by the code, not by the annotations. The annotations, however, give information about lifetimes to the compiler that uses them to check the validity of references. The compiler can do so without annotations in simple cases, but needs the programmer's support in complex scenarios.\n\nSyntax\n\nThe 'a reads ‚Äòthe lifetime a‚Äô. Technically, every reference has some lifetime associated with it, but the compiler lets you elide (i.e. omit, see \"Lifetime Elision\" below) them in common cases. Before we get to that, though, let‚Äôs look at a short example with explicit lifetimes:\n\nfn bar<'a>(...)\n\n\nWe previously talked a little about function syntax, but we didn‚Äôt discuss the <>s after a function‚Äôs name. A function can have ‚Äògeneric parameters‚Äô between the <>s, of which lifetimes are one kind. We‚Äôll discuss other kinds of generics later in the book, but for now, let‚Äôs focus on the lifetimes aspect.\n\nWe use <> to declare our lifetimes. This says that bar has one lifetime, 'a. If we had two reference parameters with different lifetimes, it would look like this:\n\nfn bar<'a, 'b>(...)\n\n\nThen in our parameter list, we use the lifetimes we‚Äôve named:\n\n...(x: &'a i32)\n\n\nIf we wanted a &mut reference, we‚Äôd do this:\n\n...(x: &'a mut i32)\n\n\nIf you compare &mut i32 to &'a mut i32, they‚Äôre the same, it‚Äôs that the lifetime 'a has snuck in between the & and the mut i32. We read &mut i32 as ‚Äòa mutable reference to an i32‚Äô and &'a mut i32 as ‚Äòa mutable reference to an i32 with the lifetime 'a‚Äô.\n\nIn structs\n\nYou‚Äôll also need explicit lifetimes when working with structs that contain references:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n    let f = Foo { x: y };\n\n    println!(\"{}\", f.x);\n}\n\n\nAs you can see, structs can also have lifetimes. In a similar way to functions,\n\n\nstruct Foo<'a> {\n\ndeclares a lifetime, and\n\n\nx: &'a i32,\n\nuses it. So why do we need a lifetime here? We need to ensure that any reference to a Foo cannot outlive the reference to an i32 it contains.\n\nimpl blocks\n\nLet‚Äôs implement a method on Foo:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nimpl<'a> Foo<'a> {\n    fn x(&self) -> &'a i32 { self.x }\n}\n\nfn main() {\n    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n    let f = Foo { x: y };\n\n    println!(\"x is: {}\", f.x());\n}\n\n\nAs you can see, we need to declare a lifetime for Foo in the impl line. We repeat 'a twice, like on functions: impl<'a> defines a lifetime 'a, and Foo<'a> uses it.\n\nMultiple lifetimes\n\nIf you have multiple references, you can use the same lifetime multiple times:\n\n\nfn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str {\n\nThis says that x and y both are alive for the same scope, and that the return value is also alive for that scope. If you wanted x and y to have different lifetimes, you can use multiple lifetime parameters:\n\n\nfn x_or_y<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {\n\nIn this example, x and y have different valid scopes, but the return value has the same lifetime as x.\n\nThinking in scopes\n\nA way to think about lifetimes is to visualize the scope that a reference is valid for. For example:\n\nfn main() {\n    let y = &5;     // -+ `y` comes into scope.\n                    //  |\n    // Stuff...     //  |\n                    //  |\n}                   // -+ `y` goes out of scope.\n\n\nAdding in our Foo:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let y = &5;           // -+ `y` comes into scope.\n    let f = Foo { x: y }; // -+ `f` comes into scope.\n                          //  |\n    // Stuff...           //  |\n                          //  |\n}                         // -+ `f` and `y` go out of scope.\n\n\nOur f lives within the scope of y, so everything works. What if it didn‚Äôt? This code won‚Äôt work:\n\nstruct Foo<'a> {\n    x: &'a i32,\n}\n\nfn main() {\n    let x;                    // -+ `x` comes into scope.\n                              //  |\n    {                         //  |\n        let y = &5;           // ---+ `y` comes into scope.\n        let f = Foo { x: y }; // ---+ `f` comes into scope.\n        x = &f.x;             //  | | This causes an error.\n    }                         // ---+ `f` and y go out of scope.\n                              //  |\n    println!(\"{}\", x);        //  |\n}                             // -+ `x` goes out of scope.\n\n\nWhew! As you can see here, the scopes of f and y are smaller than the scope of x. But when we do x = &f.x, we make x a reference to something that‚Äôs about to go out of scope.\n\nNamed lifetimes are a way of giving these scopes a name. Giving something a name is the first step towards being able to talk about it.\n\n'static\n\nThe lifetime named ‚Äòstatic‚Äô is a special lifetime. It signals that something has the lifetime of the entire program. Most Rust programmers first come across 'static when dealing with strings:\n\n\nlet x: &'static str = \"Hello, world.\";\n\nString literals have the type &'static str because the reference is always alive: they are baked into the data segment of the final binary. Another example are globals:\n\n\nstatic FOO: i32 = 5;\nlet x: &'static i32 = &FOO;\n\nThis adds an i32 to the data segment of the binary, and x is a reference to it.\n\nLifetime Elision\n\nRust supports powerful local type inference in the bodies of functions, but it deliberately does not perform any reasoning about types for item signatures. However, for ergonomic reasons, a very restricted secondary inference algorithm called ‚Äúlifetime elision‚Äù does apply when judging lifetimes. Lifetime elision is concerned solely with inferring lifetime parameters using three easily memorizable and unambiguous rules. This means lifetime elision acts as a shorthand for writing an item signature, while not hiding away the actual types involved as full local inference would if applied to it.\n\nWhen talking about lifetime elision, we use the terms input lifetime and output lifetime. An input lifetime is a lifetime associated with a parameter of a function, and an output lifetime is a lifetime associated with the return value of a function. For example, this function has an input lifetime:\n\nfn foo<'a>(bar: &'a str)\n\n\nThis one has an output lifetime:\n\nfn foo<'a>() -> &'a str\n\n\nThis one has a lifetime in both positions:\n\nfn foo<'a>(bar: &'a str) -> &'a str\n\n\nHere are the three rules:\n\nEach elided lifetime in a function‚Äôs arguments becomes a distinct lifetime parameter.\n\nIf there is exactly one input lifetime, elided or not, that lifetime is assigned to all elided lifetimes in the return values of that function.\n\nIf there are multiple input lifetimes, but one of them is &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n\nOtherwise, it is an error to elide an output lifetime.\n\nExamples\n\nHere are some examples of functions with elided lifetimes. We‚Äôve paired each example of an elided lifetime with its expanded form.\n\nfn print(s: &str); // elided\nfn print<'a>(s: &'a str); // expanded\n\nfn debug(lvl: u32, s: &str); // elided\nfn debug<'a>(lvl: u32, s: &'a str); // expanded\n\n\nIn the preceding example, lvl doesn‚Äôt need a lifetime because it‚Äôs not a reference (&). Only things relating to references (such as a struct which contains a reference) need lifetimes.\n\nfn substr(s: &str, until: u32) -> &str; // elided\nfn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n\nfn get_str() -> &str; // ILLEGAL, no inputs\n\nfn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\nfn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is ambiguous\n\nfn get_mut(&mut self) -> &mut T; // elided\nfn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n\nfn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command; // elided\nfn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded\n\nfn new(buf: &mut [u8]) -> BufWriter; // elided\nfn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>; // expanded\n"
  },
  {
    "title": "References and Borrowing - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/references-and-borrowing.html",
    "html": "References and Borrowing\n\nThis is the second of three sections presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:\n\nownership, the key concept\nborrowing, which you‚Äôre reading now\nlifetimes, an advanced concept of borrowing\n\nThese three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.\n\nMeta\n\nBefore we get to the details, two important notes about the ownership system.\n\nRust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is done at compile time. You do not pay any run-time cost for any of these features.\n\nHowever, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.\n\nWith that in mind, let‚Äôs learn about borrowing.\n\nBorrowing\n\nAt the end of the ownership section, we had a nasty function that looked like this:\n\n\nfn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n    // Do stuff with `v1` and `v2`.\n\n    // Hand back ownership, and the result of our function.\n    (v1, v2, 42)\n}\n\nlet v1 = vec![1, 2, 3];\nlet v2 = vec![1, 2, 3];\n\nlet (v1, v2, answer) = foo(v1, v2);\n\nThis is not idiomatic Rust, however, as it doesn‚Äôt take advantage of borrowing. Here‚Äôs the first step:\n\n\nfn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n    // Do stuff with `v1` and `v2`.\n\n    // Return the answer.\n    42\n}\n\nlet v1 = vec![1, 2, 3];\nlet v2 = vec![1, 2, 3];\n\nlet answer = foo(&v1, &v2);\n\n// We can use `v1` and `v2` here!\n\nA more concrete example:\n\nfn main() {\n    // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed.\n    fn sum_vec(v: &Vec<i32>) -> i32 {\n        v.iter().fold(0, |a, &b| a + b)\n    }\n    // Borrow two vectors and sum them.\n    // This kind of borrowing does not allow mutation through the borrowed reference.\n    fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n        // Do stuff with `v1` and `v2`.\n        let s1 = sum_vec(v1);\n        let s2 = sum_vec(v2);\n        // Return the answer.\n        s1 + s2\n    }\n\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![4, 5, 6];\n\n    let answer = foo(&v1, &v2);\n    println!(\"{}\", answer);\n}\n\n\nInstead of taking Vec<i32>s as our arguments, we take a reference: &Vec<i32>. And instead of passing v1 and v2 directly, we pass &v1 and &v2. We call the &T type a ‚Äòreference‚Äô, and rather than owning the resource, it borrows ownership. A binding that borrows something does not deallocate the resource when it goes out of scope. This means that after the call to foo(), we can use our original bindings again.\n\nReferences are immutable, like bindings. This means that inside of foo(), the vectors can‚Äôt be changed at all:\n\nfn foo(v: &Vec<i32>) {\n     v.push(5);\n}\n\nlet v = vec![];\n\nfoo(&v);\n\n\nwill give us this error:\n\nerror: cannot borrow immutable borrowed content `*v` as mutable\nv.push(5);\n^\n\n\nPushing a value mutates the vector, and so we aren‚Äôt allowed to do it.\n\n&mut references\n\nThere‚Äôs a second kind of reference: &mut T. A ‚Äòmutable reference‚Äô allows you to mutate the resource you‚Äôre borrowing. For example:\n\n\nlet mut x = 5;\n{\n    let y = &mut x;\n    *y += 1;\n}\nprintln!(\"{}\", x);\n\nThis will print 6. We make y a mutable reference to x, then add one to the thing y points at. You‚Äôll notice that x had to be marked mut as well. If it wasn‚Äôt, we couldn‚Äôt take a mutable borrow to an immutable value.\n\nYou'll also notice we added an asterisk (*) in front of y, making it *y, this is because y is a &mut reference. You'll need to use asterisks to access the contents of a reference as well.\n\nOtherwise, &mut references are like references. There is a large difference between the two, and how they interact, though. You can tell something is fishy in the above example, because we need that extra scope, with the { and }. If we remove them, we get an error:\n\nerror: cannot borrow `x` as immutable because it is also borrowed as mutable\n    println!(\"{}\", x);\n                   ^\nnote: previous borrow of `x` occurs here; the mutable borrow prevents\nsubsequent moves, borrows, or modification of `x` until the borrow ends\n        let y = &mut x;\n                     ^\nnote: previous borrow ends here\nfn main() {\n\n}\n^\n\n\nAs it turns out, there are rules.\n\nThe Rules\n\nHere are the rules for borrowing in Rust:\n\nFirst, any borrow must last for a scope no greater than that of the owner. Second, you may have one or the other of these two kinds of borrows, but not both at the same time:\n\none or more references (&T) to a resource,\nexactly one mutable reference (&mut T).\n\nYou may notice that this is very similar to, though not exactly the same as, the definition of a data race:\n\nThere is a ‚Äòdata race‚Äô when two or more pointers access the same memory location at the same time, where at least one of them is writing, and the operations are not synchronized.\n\nWith references, you may have as many as you‚Äôd like, since none of them are writing. However, as we can only have one &mut at a time, it is impossible to have a data race. This is how Rust prevents data races at compile time: we‚Äôll get errors if we break the rules.\n\nWith this in mind, let‚Äôs consider our example again.\n\nThinking in scopes\n\nHere‚Äôs the code:\n\nfn main() {\n    let mut x = 5;\n    let y = &mut x;\n\n    *y += 1;\n\n    println!(\"{}\", x);\n}\n\n\nThis code gives us this error:\n\nerror: cannot borrow `x` as immutable because it is also borrowed as mutable\n    println!(\"{}\", x);\n                   ^\n\n\nThis is because we‚Äôve violated the rules: we have a &mut T pointing to x, and so we aren‚Äôt allowed to create any &Ts. It's one or the other. The note hints at how to think about this problem:\n\nnote: previous borrow ends here\nfn main() {\n\n}\n^\n\n\nIn other words, the mutable borrow is held through the rest of our example. What we want is for the mutable borrow by y to end so that the resource can be returned to the owner, x. x can then provide an immutable borrow to println!. In Rust, borrowing is tied to the scope that the borrow is valid for. And our scopes look like this:\n\nfn main() {\n    let mut x = 5;\n\n    let y = &mut x;    // -+ &mut borrow of `x` starts here.\n                       //  |\n    *y += 1;           //  |\n                       //  |\n    println!(\"{}\", x); // -+ - Try to borrow `x` here.\n}                      // -+ &mut borrow of `x` ends here.\n                       \n\n\nThe scopes conflict: we can‚Äôt make an &x while y is in scope.\n\nSo when we add the curly braces:\n\n\nlet mut x = 5;\n\n{\n    let y = &mut x; // -+ &mut borrow starts here.\n    *y += 1;        //  |\n}                   // -+ ... and ends here.\n\nprintln!(\"{}\", x);  // <- Try to borrow `x` here.\n\nThere‚Äôs no problem. Our mutable borrow goes out of scope before we create an immutable one. So scope is the key to seeing how long a borrow lasts for.\n\nIssues borrowing prevents\n\nWhy have these restrictive rules? Well, as we noted, these rules prevent data races. What kinds of issues do data races cause? Here are a few.\n\nIterator invalidation\n\nOne example is ‚Äòiterator invalidation‚Äô, which happens when you try to mutate a collection that you‚Äôre iterating over. Rust‚Äôs borrow checker prevents this from happening:\n\n\nlet mut v = vec![1, 2, 3];\n\nfor i in &v {\n    println!(\"{}\", i);\n}\n\nThis prints out one through three. As we iterate through the vector, we‚Äôre only given references to the elements. And v is itself borrowed as immutable, which means we can‚Äôt change it while we‚Äôre iterating:\n\nlet mut v = vec![1, 2, 3];\n\nfor i in &v {\n    println!(\"{}\", i);\n    v.push(34);\n}\n\n\nHere‚Äôs the error:\n\nerror: cannot borrow `v` as mutable because it is also borrowed as immutable\n    v.push(34);\n    ^\nnote: previous borrow of `v` occurs here; the immutable borrow prevents\nsubsequent moves or mutable borrows of `v` until the borrow ends\nfor i in &v {\n          ^\nnote: previous borrow ends here\nfor i in &v {\n    println!(‚Äú{}‚Äù, i);\n    v.push(34);\n}\n^\n\n\nWe can‚Äôt modify v because it‚Äôs borrowed by the loop.\n\nUse after free\n\nReferences must not live longer than the resource they refer to. Rust will check the scopes of your references to ensure that this is true.\n\nIf Rust didn‚Äôt check this property, we could accidentally use a reference which was invalid. For example:\n\nlet y: &i32;\n{\n    let x = 5;\n    y = &x;\n}\n\nprintln!(\"{}\", y);\n\n\nWe get this error:\n\nerror: `x` does not live long enough\n    y = &x;\n         ^\nnote: reference must be valid for the block suffix following statement 0 at\n2:16...\nlet y: &i32;\n{\n    let x = 5;\n    y = &x;\n}\n\nnote: ...but borrowed value is only valid for the block suffix following\nstatement 0 at 4:18\n    let x = 5;\n    y = &x;\n}\n\n\nIn other words, y is only valid for the scope where x exists. As soon as x goes away, it becomes invalid to refer to it. As such, the error says that the borrow ‚Äòdoesn‚Äôt live long enough‚Äô because it‚Äôs not valid for the right amount of time.\n\nThe same problem occurs when the reference is declared before the variable it refers to. This is because resources within the same scope are freed in the opposite order they were declared:\n\nlet y: &i32;\nlet x = 5;\ny = &x;\n\nprintln!(\"{}\", y);\n\n\nWe get this error:\n\nerror: `x` does not live long enough\ny = &x;\n     ^\nnote: reference must be valid for the block suffix following statement 0 at\n2:16...\n    let y: &i32;\n    let x = 5;\n    y = &x;\n\n    println!(\"{}\", y);\n}\n\nnote: ...but borrowed value is only valid for the block suffix following\nstatement 1 at 3:14\n    let x = 5;\n    y = &x;\n\n    println!(\"{}\", y);\n}\n\n\nIn the above example, y is declared before x, meaning that y lives longer than x, which is not allowed."
  },
  {
    "title": "Ownership - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/ownership.html",
    "html": "Ownership\n\nThis is the first of three sections presenting Rust‚Äôs ownership system. This is one of Rust‚Äôs most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:\n\nownership, which you‚Äôre reading now\nborrowing, and their associated feature ‚Äòreferences‚Äô\nlifetimes, an advanced concept of borrowing\n\nThese three chapters are related, and in order. You‚Äôll need all three to fully understand the ownership system.\n\nMeta\n\nBefore we get to the details, two important notes about the ownership system.\n\nRust has a focus on safety and speed. It accomplishes these goals through many ‚Äòzero-cost abstractions‚Äô, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we‚Äôll talk about in this guide is done at compile time. You do not pay any run-time cost for any of these features.\n\nHowever, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‚Äòfighting with the borrow checker‚Äô, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer‚Äôs mental model of how ownership should work doesn‚Äôt match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.\n\nWith that in mind, let‚Äôs learn about ownership.\n\nOwnership\n\nVariable bindings have a property in Rust: they ‚Äòhave ownership‚Äô of what they‚Äôre bound to. This means that when a binding goes out of scope, Rust will free the bound resources. For example:\n\n\nfn foo() {\n    let v = vec![1, 2, 3];\n}\n\nWhen v comes into scope, a new vector is created on the stack, and it allocates space on the heap for its elements. When v goes out of scope at the end of foo(), Rust will clean up everything related to the vector, even the heap-allocated memory. This happens deterministically, at the end of the scope.\n\nWe covered vectors in the previous chapter; we use them here as an example of a type that allocates space on the heap at runtime. They behave like arrays, except their size may change by push()ing more elements onto them.\n\nVectors have a generic type Vec<T>, so in this example v will have type Vec<i32>. We'll cover generics in detail in a later chapter.\n\nMove semantics\n\nThere‚Äôs some more subtlety here, though: Rust ensures that there is exactly one binding to any given resource. For example, if we have a vector, we can assign it to another binding:\n\n\nlet v = vec![1, 2, 3];\n\nlet v2 = v;\n\nBut, if we try to use v afterwards, we get an error:\n\nlet v = vec![1, 2, 3];\n\nlet v2 = v;\n\nprintln!(\"v[0] is: {}\", v[0]);\n\n\nIt looks like this:\n\nerror: use of moved value: `v`\nprintln!(\"v[0] is: {}\", v[0]);\n                        ^\n\n\nA similar thing happens if we define a function which takes ownership, and try to use something after we‚Äôve passed it as an argument:\n\nfn take(v: Vec<i32>) {\n    // What happens here isn‚Äôt important.\n}\n\nlet v = vec![1, 2, 3];\n\ntake(v);\n\nprintln!(\"v[0] is: {}\", v[0]);\n\n\nSame error: ‚Äòuse of moved value‚Äô. When we transfer ownership to something else, we say that we‚Äôve ‚Äòmoved‚Äô the thing we refer to. You don‚Äôt need some sort of special annotation here, it‚Äôs the default thing that Rust does.\n\nThe details\n\nThe reason that we cannot use a binding after we‚Äôve moved it is subtle, but important.\n\nWhen we write code like this:\n\n\nlet x = 10;\n\nRust allocates memory for an integer i32 on the stack, copies the bit pattern representing the value of 10 to the allocated memory and binds the variable name x to this memory region for future reference.\n\nNow consider the following code fragment:\n\n\nlet v = vec![1, 2, 3];\n\nlet mut v2 = v;\n\nThe first line allocates memory for the vector object v on the stack like it does for x above. But in addition to that it also allocates some memory on the heap for the actual data ([1, 2, 3]). Rust copies the address of this heap allocation to an internal pointer, which is part of the vector object placed on the stack (let's call it the data pointer).\n\nIt is worth pointing out (even at the risk of stating the obvious) that the vector object and its data live in separate memory regions instead of being a single contiguous memory allocation (due to reasons we will not go into at this point of time). These two parts of the vector (the one on the stack and one on the heap) must agree with each other at all times with regards to things like the length, capacity, etc.\n\nWhen we move v to v2, Rust actually does a bitwise copy of the vector object v into the stack allocation represented by v2. This shallow copy does not create a copy of the heap allocation containing the actual data. Which means that there would be two pointers to the contents of the vector both pointing to the same memory allocation on the heap. It would violate Rust‚Äôs safety guarantees by introducing a data race if one could access both v and v2 at the same time.\n\nFor example if we truncated the vector to just two elements through v2:\n\n\nv2.truncate(2);\n\nand v were still accessible we'd end up with an invalid vector since v would not know that the heap data has been truncated. Now, the part of the vector v on the stack does not agree with the corresponding part on the heap. v still thinks there are three elements in the vector and will happily let us access the non existent element v[2] but as you might already know this is a recipe for disaster. Especially because it might lead to a segmentation fault or worse allow an unauthorized user to read from memory to which they don't have access.\n\nThis is why Rust forbids using v after we‚Äôve done the move.\n\nIt‚Äôs also important to note that optimizations may remove the actual copy of the bytes on the stack, depending on circumstances. So it may not be as inefficient as it initially seems.\n\nCopy types\n\nWe‚Äôve established that when ownership is transferred to another binding, you cannot use the original binding. However, there‚Äôs a trait that changes this behavior, and it‚Äôs called Copy. We haven‚Äôt discussed traits yet, but for now, you can think of them as an annotation to a particular type that adds extra behavior. For example:\n\n\nlet v = 1;\n\nlet v2 = v;\n\nprintln!(\"v is: {}\", v);\n\nIn this case, v is an i32, which implements the Copy trait. This means that, just like a move, when we assign v to v2, a copy of the data is made. But, unlike a move, we can still use v afterward. This is because an i32 has no pointers to data somewhere else, copying it is a full copy.\n\nAll primitive types implement the Copy trait and their ownership is therefore not moved like one would assume, following the ‚Äòownership rules‚Äô. To give an example, the two following snippets of code only compile because the i32 and bool types implement the Copy trait.\n\nfn main() {\n    let a = 5;\n\n    let _y = double(a);\n    println!(\"{}\", a);\n}\n\nfn double(x: i32) -> i32 {\n    x * 2\n}\n\nfn main() {\n    let a = true;\n\n    let _y = change_truth(a);\n    println!(\"{}\", a);\n}\n\nfn change_truth(x: bool) -> bool {\n    !x\n}\n\n\nIf we had used types that do not implement the Copy trait, we would have gotten a compile error because we tried to use a moved value.\n\nerror: use of moved value: `a`\nprintln!(\"{}\", a);\n               ^\n\n\nWe will discuss how to make your own types Copy in the traits section.\n\nMore than ownership\n\nOf course, if we had to hand ownership back with every function we wrote:\n\n\nfn foo(v: Vec<i32>) -> Vec<i32> {\n    // Do stuff with `v`.\n\n    // Hand back ownership.\n    v\n}\n\nThis would get very tedious. It gets worse the more things we want to take ownership of:\n\n\nfn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n    // Do stuff with `v1` and `v2`.\n\n    // Hand back ownership, and the result of our function.\n    (v1, v2, 42)\n}\n\nlet v1 = vec![1, 2, 3];\nlet v2 = vec![1, 2, 3];\n\nlet (v1, v2, answer) = foo(v1, v2);\n\nUgh! The return type, return line, and calling the function gets way more complicated.\n\nLuckily, Rust offers a feature which helps us solve this problem. It‚Äôs called borrowing and is the topic of the next section!"
  },
  {
    "title": "Vectors - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/vectors.html",
    "html": "Vectors\n\nA ‚Äòvector‚Äô is a dynamic or ‚Äògrowable‚Äô array, implemented as the standard library type Vec<T>. The T means that we can have vectors of any type (see the chapter on generics for more). Vectors always allocate their data on the heap. You can create them with the vec! macro:\n\n\nlet v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>\n\n(Notice that unlike the println! macro we‚Äôve used in the past, we use square brackets [] with vec! macro. Rust allows you to use either in either situation, this is just convention.)\n\nThere‚Äôs an alternate form of vec! for repeating an initial value:\n\n\nlet v = vec![0; 10]; // A vector of ten zeroes.\n\nVectors store their contents as contiguous arrays of T on the heap. This means that they must be able to know the size of T at compile time (that is, how many bytes are needed to store a T?). The size of some things can't be known at compile time. For these you'll have to store a pointer to that thing: thankfully, the Box type works perfectly for this.\n\nAccessing elements\n\nTo get the value at a particular index in the vector, we use []s:\n\n\nlet v = vec![1, 2, 3, 4, 5];\n\nprintln!(\"The third element of v is {}\", v[2]);\n\nThe indices count from 0, so the third element is v[2].\n\nIt‚Äôs also important to note that you must index with the usize type:\n\nlet v = vec![1, 2, 3, 4, 5];\n\nlet i: usize = 0;\nlet j: i32 = 0;\n\n// Works:\nv[i];\n\n// Doesn‚Äôt:\nv[j];\n\n\nIndexing with a non-usize type gives an error that looks like this:\n\nerror: the trait bound `collections::vec::Vec<_> : core::ops::Index<i32>`\nis not satisfied [E0277]\nv[j];\n^~~~\nnote: the type `collections::vec::Vec<_>` cannot be indexed by `i32`\nerror: aborting due to previous error\n\n\nThere‚Äôs a lot of punctuation in that message, but the core of it makes sense: you cannot index with an i32.\n\nOut-of-bounds Access\n\nIf you try to access an index that doesn‚Äôt exist:\n\nlet v = vec![1, 2, 3];\nprintln!(\"Item 7 is {}\", v[7]);\n\n\nthen the current thread will panic with a message like this:\n\nthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 7'\n\n\nIf you want to handle out-of-bounds errors without panicking, you can use methods like get or get_mut that return None when given an invalid index:\n\n\nlet v = vec![1, 2, 3];\nmatch v.get(7) {\n    Some(x) => println!(\"Item 7 is {}\", x),\n    None => println!(\"Sorry, this vector is too short.\")\n}\nIterating\n\nOnce you have a vector, you can iterate through its elements with for. There are three versions:\n\n\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n\nNote: You cannot use the vector again once you have iterated by taking ownership of the vector. You can iterate the vector multiple times by taking a reference to the vector whilst iterating. For example, the following code does not compile.\n\nlet v = vec![1, 2, 3, 4, 5];\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n}\n\n\nWhereas the following works perfectly,\n\n\nlet v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"This is a reference to {}\", i);\n}\n\nfor i in &v {\n    println!(\"This is a reference to {}\", i);\n}\n\nVectors have many more useful methods, which you can read about in their API documentation."
  },
  {
    "title": "Loops - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/loops.html",
    "html": "Loops\n\nRust currently provides three approaches to performing some kind of iterative activity. They are: loop, while and for. Each approach has its own set of uses.\n\nloop\n\nThe infinite loop is the simplest form of loop available in Rust. Using the keyword loop, Rust provides a way to loop indefinitely until some terminating statement is reached. Rust's infinite loops look like this:\n\nloop {\n    println!(\"Loop forever!\");\n}\n\nwhile\n\nRust also has a while loop. It looks like this:\n\n\nlet mut x = 5; // mut x: i32\nlet mut done = false; // mut done: bool\n\nwhile !done {\n    x += x - 3;\n\n    println!(\"{}\", x);\n\n    if x % 5 == 0 {\n        done = true;\n    }\n}\n\nwhile loops are the correct choice when you‚Äôre not sure how many times you need to loop.\n\nIf you need an infinite loop, you may be tempted to write this:\n\nwhile true {\n\n\nHowever, loop is far better suited to handle this case:\n\nloop {\n\n\nRust‚Äôs control-flow analysis treats this construct differently than a while true, since we know that it will always loop. In general, the more information we can give to the compiler, the better it can do with safety and code generation, so you should always prefer loop when you plan to loop infinitely.\n\nfor\n\nThe for loop is used to loop a particular number of times. Rust‚Äôs for loops work a bit differently than in other systems languages, however. Rust‚Äôs for loop doesn‚Äôt look like this ‚ÄúC-style‚Äù for loop:\n\nfor (x = 0; x < 10; x++) {\n    printf( \"%d\\n\", x );\n}\n\n\nInstead, it looks like this:\n\n\nfor x in 0..10 {\n    println!(\"{}\", x); // x: i32\n}\n\nIn slightly more abstract terms,\n\nfor var in expression {\n    code\n}\n\n\nThe expression is an item that can be converted into an iterator using IntoIterator. The iterator gives back a series of elements, one element per iteration of the loop. That value is then bound to the name var, which is valid for the loop body. Once the body is over, the next value is fetched from the iterator, and we loop another time. When there are no more values, the for loop is over.\n\nIn our example, 0..10 is an expression that takes a start and an end position, and gives an iterator over those values. The upper bound is exclusive, though, so our loop will print 0 through 9, not 10.\n\nRust does not have the ‚ÄúC-style‚Äù for loop on purpose. Manually controlling each element of the loop is complicated and error prone, even for experienced C developers.\n\nEnumerate\n\nWhen you need to keep track of how many times you have already looped, you can use the .enumerate() function.\n\nOn ranges:\n\nfor (index, value) in (5..10).enumerate() {\n    println!(\"index = {} and value = {}\", index, value);\n}\n\nOutputs:\n\nindex = 0 and value = 5\nindex = 1 and value = 6\nindex = 2 and value = 7\nindex = 3 and value = 8\nindex = 4 and value = 9\n\n\nDon't forget to add the parentheses around the range.\n\nOn iterators:\n\nlet lines = \"hello\\nworld\".lines();\n\nfor (linenumber, line) in lines.enumerate() {\n    println!(\"{}: {}\", linenumber, line);\n}\n\nOutputs:\n\n0: hello\n1: world\n\nEnding iteration early\n\nLet‚Äôs take a look at that while loop we had earlier:\n\n\nlet mut x = 5;\nlet mut done = false;\n\nwhile !done {\n    x += x - 3;\n\n    println!(\"{}\", x);\n\n    if x % 5 == 0 {\n        done = true;\n    }\n}\n\nWe had to keep a dedicated mut boolean variable binding, done, to know when we should exit out of the loop. Rust has two keywords to help us with modifying iteration: break and continue.\n\nIn this case, we can write the loop in a better way with break:\n\n\nlet mut x = 5;\n\nloop {\n    x += x - 3;\n\n    println!(\"{}\", x);\n\n    if x % 5 == 0 { break; }\n}\n\nWe now loop forever with loop and use break to break out early. Issuing an explicit return statement will also serve to terminate the loop early.\n\ncontinue is similar, but instead of ending the loop, it goes to the next iteration. This will only print the odd numbers:\n\n\nfor x in 0..10 {\n    if x % 2 == 0 { continue; }\n\n    println!(\"{}\", x);\n}\nLoop labels\n\nYou may also encounter situations where you have nested loops and need to specify which one your break or continue statement is for. Like most other languages, Rust's break or continue apply to the innermost loop. In a situation where you would like to break or continue for one of the outer loops, you can use labels to specify which loop the break or continue statement applies to.\n\nIn the example below, we continue to the next iteration of outer loop when x is even, while we continue to the next iteration of inner loop when y is even. So it will execute the println! when both x and y are odd.\n\n\n'outer: for x in 0..10 {\n    'inner: for y in 0..10 {\n        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.\n        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.\n        println!(\"x: {}, y: {}\", x, y);\n    }\n}"
  },
  {
    "title": "if - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/if.html",
    "html": "if\n\nRust‚Äôs take on if is not particularly complex, but it‚Äôs much more like the if you‚Äôll find in a dynamically typed language than in a more traditional systems language. So let‚Äôs talk about it, to make sure you grasp the nuances.\n\nif is a specific form of a more general concept, the ‚Äòbranch‚Äô, whose name comes from a branch in a tree: a decision point, where depending on a choice, multiple paths can be taken.\n\nIn the case of if, there is one choice that leads down two paths:\n\n\nlet x = 5;\n\nif x == 5 {\n    println!(\"x is five!\");\n}\n\nIf we changed the value of x to something else, this line would not print. More specifically, if the expression after the if evaluates to true, then the block is executed. If it‚Äôs false, then it is not.\n\nIf you want something to happen in the false case, use an else:\n\n\nlet x = 5;\n\nif x == 5 {\n    println!(\"x is five!\");\n} else {\n    println!(\"x is not five :(\");\n}\n\nIf there is more than one case, use an else if:\n\n\nlet x = 5;\n\nif x == 5 {\n    println!(\"x is five!\");\n} else if x == 6 {\n    println!(\"x is six!\");\n} else {\n    println!(\"x is not five or six :(\");\n}\n\nThis is all pretty standard. However, you can also do this:\n\n\nlet x = 5;\n\nlet y = if x == 5 {\n    10\n} else {\n    15\n}; // y: i32\n\nWhich we can (and probably should) write like this:\n\n\nlet x = 5;\n\nlet y = if x == 5 { 10 } else { 15 }; // y: i32\n\nThis works because if is an expression. The value of the expression is the value of the last expression in whichever branch was chosen. An if without an else always results in () as the value."
  },
  {
    "title": "Comments - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/comments.html",
    "html": "Comments\n\nNow that we have some functions, it‚Äôs a good idea to learn about comments. Comments are notes that you leave to other programmers to help explain things about your code. The compiler mostly ignores them.\n\nRust has two kinds of comments that you should care about: line comments and doc comments.\n\n\n// Line comments are anything after ‚Äò//‚Äô and extend to the end of the line.\n\nlet x = 5; // This is also a line comment.\n\n// If you have a long explanation for something, you can put line comments next\n// to each other. Put a space between the // and your comment so that it‚Äôs\n// more readable.\n\nThe other kind of comment is a doc comment. Doc comments use /// instead of //, and support Markdown notation inside:\n\n\n/// Adds one to the number given.\n///\n/// # Examples\n///\n/// ```\n/// let five = 5;\n///\n/// assert_eq!(6, add_one(5));\n/// # fn add_one(x: i32) -> i32 {\n/// #     x + 1\n/// # }\n/// ```\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nThere is another style of doc comment, //!, to comment containing items (e.g. crates, modules or functions), instead of the items following it. Commonly used inside crates root (lib.rs) or modules root (mod.rs):\n\n//! # The Rust Standard Library\n//!\n//! The Rust Standard Library provides the essential runtime\n//! functionality for building portable Rust software.\n\n\nWhen writing doc comments, providing some examples of usage is very, very helpful. You‚Äôll notice we‚Äôve used a new macro here: assert_eq!. This compares two values, and panic!s if they‚Äôre not equal to each other. It‚Äôs very helpful in documentation. There‚Äôs another macro, assert!, which panic!s if the value passed to it is false.\n\nYou can use the rustdoc tool to generate HTML documentation from these doc comments, and also to run the code examples as tests!"
  },
  {
    "title": "Primitive Types - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/primitive-types.html",
    "html": "Primitive Types\n\nThe Rust language has a number of types that are considered ‚Äòprimitive‚Äô. This means that they‚Äôre built-in to the language. Rust is structured in such a way that the standard library also provides a number of useful types built on top of these ones, as well, but these are the most primitive.\n\nBooleans\n\nRust has a built-in boolean type, named bool. It has two values, true and false:\n\n\nlet x = true;\n\nlet y: bool = false;\n\nA common use of booleans is in if conditionals.\n\nYou can find more documentation for bools in the standard library documentation.\n\nchar\n\nThe char type represents a single Unicode scalar value. You can create chars with a single tick: (')\n\n\nlet x = 'x';\nlet two_hearts = 'üíï';\n\nUnlike some other languages, this means that Rust‚Äôs char is not a single byte, but four.\n\nYou can find more documentation for chars in the standard library documentation.\n\nNumeric types\n\nRust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.\n\nThese types consist of two parts: the category, and the size. For example, u16 is an unsigned type with sixteen bits of size. More bits lets you have bigger numbers.\n\nIf a number literal has nothing to cause its type to be inferred, it defaults:\n\n\nlet x = 42; // `x` has type `i32`.\n\nlet y = 1.0; // `y` has type `f64`.\n\nHere‚Äôs a list of the different numeric types, with links to their documentation in the standard library:\n\ni8\ni16\ni32\ni64\nu8\nu16\nu32\nu64\nisize\nusize\nf32\nf64\n\nLet‚Äôs go over them by category:\n\nSigned and Unsigned\n\nInteger types come in two varieties: signed and unsigned. To understand the difference, let‚Äôs consider a number with four bits of size. A signed, four-bit number would let you store numbers from -8 to +7. Signed numbers use ‚Äútwo‚Äôs complement representation‚Äù. An unsigned four bit number, since it does not need to store negatives, can store values from 0 to +15.\n\nUnsigned types use a u for their category, and signed types use i. The i is for ‚Äòinteger‚Äô. So u8 is an eight-bit unsigned number, and i8 is an eight-bit signed number.\n\nFixed-size types\n\nFixed-size types have a specific number of bits in their representation. Valid bit sizes are 8, 16, 32, and 64. So, u32 is an unsigned, 32-bit integer, and i64 is a signed, 64-bit integer.\n\nVariable-size types\n\nRust also provides types whose particular size depends on the underlying machine architecture. Their range is sufficient to express the size of any collection, so these types have ‚Äòsize‚Äô as the category. They come in signed and unsigned varieties which account for two types: isize and usize.\n\nFloating-point types\n\nRust also has two floating point types: f32 and f64. These correspond to IEEE-754 single and double precision numbers.\n\nArrays\n\nLike many programming languages, Rust has list types to represent a sequence of things. The most basic is the array, a fixed-size list of elements of the same type. By default, arrays are immutable.\n\n\nlet a = [1, 2, 3]; // a: [i32; 3]\nlet mut m = [1, 2, 3]; // m: [i32; 3]\n\nArrays have type [T; N]. We‚Äôll talk about this T notation in the generics section. The N is a compile-time constant, for the length of the array.\n\nThere‚Äôs a shorthand for initializing each element of an array to the same value. In this example, each element of a will be initialized to 0:\n\n\nlet a = [0; 20]; // a: [i32; 20]\n\nYou can get the number of elements in an array a with a.len():\n\n\nlet a = [1, 2, 3];\n\nprintln!(\"a has {} elements\", a.len());\n\nYou can access a particular element of an array with subscript notation:\n\n\nlet names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n\nprintln!(\"The second name is: {}\", names[1]);\n\nSubscripts start at zero, like in most programming languages, so the first name is names[0] and the second name is names[1]. The above example prints The second name is: Brian. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.\n\nYou can find more documentation for arrays in the standard library documentation.\n\nSlices\n\nA ‚Äòslice‚Äô is a reference to (or ‚Äúview‚Äù into) another data structure. They are useful for allowing safe, efficient access to a portion of an array without copying. For example, you might want to reference only one line of a file read into memory. By nature, a slice is not created directly, but from an existing variable binding. Slices have a defined length, and can be mutable or immutable.\n\nInternally, slices are represented as a pointer to the beginning of the data and a length.\n\nSlicing syntax\n\nYou can use a combo of & and [] to create a slice from various things. The & indicates that slices are similar to references, which we will cover in detail later in this section. The []s, with a range, let you define the length of the slice:\n\n\nlet a = [0, 1, 2, 3, 4];\nlet complete = &a[..]; // A slice containing all of the elements in `a`.\nlet middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.\n\nSlices have type &[T]. We‚Äôll talk about that T when we cover generics.\n\nYou can find more documentation for slices in the standard library documentation.\n\nstr\n\nRust‚Äôs str type is the most primitive string type. As an unsized type, it‚Äôs not very useful by itself, but becomes useful when placed behind a reference, like &str. We'll elaborate further when we cover Strings and references.\n\nYou can find more documentation for str in the standard library documentation.\n\nTuples\n\nA tuple is an ordered list of fixed size. Like this:\n\n\nlet x = (1, \"hello\");\n\nThe parentheses and commas form this two-length tuple. Here‚Äôs the same code, but with the type annotated:\n\n\nlet x: (i32, &str) = (1, \"hello\");\n\nAs you can see, the type of a tuple looks like the tuple, but with each position having a type name rather than the value. Careful readers will also note that tuples are heterogeneous: we have an i32 and a &str in this tuple. In systems programming languages, strings are a bit more complex than in other languages. For now, read &str as a string slice, and we‚Äôll learn more soon.\n\nYou can assign one tuple into another, if they have the same contained types and arity. Tuples have the same arity when they have the same length.\n\n\nlet mut x = (1, 2); // x: (i32, i32)\nlet y = (2, 3); // y: (i32, i32)\n\nx = y;\n\nYou can access the fields in a tuple through a destructuring let. Here‚Äôs an example:\n\n\nlet (x, y, z) = (1, 2, 3);\n\nprintln!(\"x is {}\", x);\n\nRemember before when I said the left-hand side of a let statement was more powerful than assigning a binding? Here we are. We can put a pattern on the left-hand side of the let, and if it matches up to the right-hand side, we can assign multiple bindings at once. In this case, let ‚Äúdestructures‚Äù or ‚Äúbreaks up‚Äù the tuple, and assigns the bits to three bindings.\n\nThis pattern is very powerful, and we‚Äôll see it repeated more later.\n\nYou can disambiguate a single-element tuple from a value in parentheses with a comma:\n\n\n(0,); // A single-element tuple.\n(0); // A zero in parentheses.\nTuple Indexing\n\nYou can also access fields of a tuple with indexing syntax:\n\n\nlet tuple = (1, 2, 3);\n\nlet x = tuple.0;\nlet y = tuple.1;\nlet z = tuple.2;\n\nprintln!(\"x is {}\", x);\n\nLike array indexing, it starts at zero, but unlike array indexing, it uses a ., rather than []s.\n\nYou can find more documentation for tuples in the standard library documentation.\n\nFunctions\n\nFunctions also have a type! They look like this:\n\n\nfn foo(x: i32) -> i32 { x }\n\nlet x: fn(i32) -> i32 = foo;\n\nIn this case, x is a ‚Äòfunction pointer‚Äô to a function that takes an i32 and returns an i32."
  },
  {
    "title": "Functions - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/functions.html",
    "html": "Functions\n\nEvery Rust program has at least one function, the main function:\n\nfn main() {\n}\n\n\nThis is the simplest possible function declaration. As we mentioned before, fn says ‚Äòthis is a function‚Äô, followed by the name, some parentheses because this function takes no arguments, and then some curly braces to indicate the body. Here‚Äôs a function named foo:\n\n\nfn foo() {\n}\n\nSo, what about taking arguments? Here‚Äôs a function that prints a number:\n\n\nfn print_number(x: i32) {\n    println!(\"x is: {}\", x);\n}\n\nHere‚Äôs a complete program that uses print_number:\n\nfn main() {\n    print_number(5);\n}\n\nfn print_number(x: i32) {\n    println!(\"x is: {}\", x);\n}\n\n\nAs you can see, function arguments work very similar to let declarations: you add a type to the argument name, after a colon.\n\nHere‚Äôs a complete program that adds two numbers together and prints them:\n\nfn main() {\n    print_sum(5, 6);\n}\n\nfn print_sum(x: i32, y: i32) {\n    println!(\"sum is: {}\", x + y);\n}\n\n\nYou separate arguments with a comma, both when you call the function, as well as when you declare it.\n\nUnlike let, you must declare the types of function arguments. This does not work:\n\nfn print_sum(x, y) {\n    println!(\"sum is: {}\", x + y);\n}\n\n\nYou get this error:\n\nexpected one of `!`, `:`, or `@`, found `)`\nfn print_sum(x, y) {\n\n\nThis is a deliberate design decision. While full-program inference is possible, languages which have it, like Haskell, often suggest that documenting your types explicitly is a best-practice. We agree that forcing functions to declare types while allowing for inference inside of function bodies is a wonderful sweet spot between full inference and no inference.\n\nWhat about returning a value? Here‚Äôs a function that adds one to an integer:\n\n\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nRust functions return exactly one value, and you declare the type after an ‚Äòarrow‚Äô, which is a dash (-) followed by a greater-than sign (>). The last line of a function determines what it returns. You‚Äôll note the lack of a semicolon here. If we added it in:\n\nfn add_one(x: i32) -> i32 {\n    x + 1;\n}\n\n\nWe would get an error:\n\nerror: not all control paths return a value\nfn add_one(x: i32) -> i32 {\n     x + 1;\n}\n\nhelp: consider removing this semicolon:\n     x + 1;\n          ^\n\n\nThis reveals two interesting things about Rust: it is an expression-based language, and semicolons are different from semicolons in other ‚Äòcurly brace and semicolon‚Äô-based languages. These two things are related.\n\nExpressions vs. Statements\n\nRust is primarily an expression-based language. There are only two kinds of statements, and everything else is an expression.\n\nSo what's the difference? Expressions return a value, and statements do not. That‚Äôs why we end up with ‚Äònot all control paths return a value‚Äô here: the statement x + 1; doesn‚Äôt return a value. There are two kinds of statements in Rust: ‚Äòdeclaration statements‚Äô and ‚Äòexpression statements‚Äô. Everything else is an expression. Let‚Äôs talk about declaration statements first.\n\nIn some languages, variable bindings can be written as expressions, not statements. Like Ruby:\n\nx = y = 5\n\n\nIn Rust, however, using let to introduce a binding is not an expression. The following will produce a compile-time error:\n\nlet x = (let y = 5); // Expected identifier, found keyword `let`.\n\n\nThe compiler is telling us here that it was expecting to see the beginning of an expression, and a let can only begin a statement, not an expression.\n\nNote that assigning to an already-bound variable (e.g. y = 5) is still an expression, although its value is not particularly useful. Unlike other languages where an assignment evaluates to the assigned value (e.g. 5 in the previous example), in Rust the value of an assignment is an empty tuple () because the assigned value can have only one owner, and any other returned value would be too surprising:\n\n\nlet mut y = 5;\n\nlet x = (y = 6);  // `x` has the value `()`, not `6`.\n\nThe second kind of statement in Rust is the expression statement. Its purpose is to turn any expression into a statement. In practical terms, Rust's grammar expects statements to follow other statements. This means that you use semicolons to separate expressions from each other. This means that Rust looks a lot like most other languages that require you to use semicolons at the end of every line, and you will see semicolons at the end of almost every line of Rust code you see.\n\nWhat is this exception that makes us say \"almost\"? You saw it already, in this code:\n\n\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n\nOur function claims to return an i32, but with a semicolon, it would return () instead. Rust realizes this probably isn‚Äôt what we want, and suggests removing the semicolon in the error we saw before.\n\nEarly returns\n\nBut what about early returns? Rust does have a keyword for that, return:\n\n\nfn foo(x: i32) -> i32 {\n    return x;\n\n    // We never run this code!\n    x + 1\n}\n\nUsing a return as the last line of a function works, but is considered poor style:\n\n\nfn foo(x: i32) -> i32 {\n    return x + 1;\n}\n\nThe previous definition without return may look a bit strange if you haven‚Äôt worked in an expression-based language before, but it becomes intuitive over time.\n\nDiverging functions\n\nRust has some special syntax for ‚Äòdiverging functions‚Äô, which are functions that do not return:\n\n\nfn diverges() -> ! {\n    panic!(\"This function never returns!\");\n}\n\npanic! is a macro, similar to println!() that we‚Äôve already seen. Unlike println!(), panic!() causes the current thread of execution to crash with the given message. Because this function will cause a crash, it will never return, and so it has the type ‚Äò!‚Äô, which is read ‚Äòdiverges‚Äô.\n\nIf you add a main function that calls diverges() and run it, you‚Äôll get some output that looks like this:\n\nthread ‚Äòmain‚Äô panicked at ‚ÄòThis function never returns!‚Äô, hello.rs:2\n\n\nIf you want more information, you can get a backtrace by setting the RUST_BACKTRACE environment variable:\n\n$ RUST_BACKTRACE=1 ./diverges\nthread 'main' panicked at 'This function never returns!', hello.rs:2\nSome details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\nstack backtrace:\n  hello::diverges\n        at ./hello.rs:2\n  hello::main\n        at ./hello.rs:6\n\n\nIf you want the complete backtrace and filenames:\n\n$ RUST_BACKTRACE=full ./diverges\nthread 'main' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n\n\nIf you need to override an already set RUST_BACKTRACE, in cases when you cannot just unset the variable, then set it to 0 to avoid getting a backtrace. Any other value (even no value at all) turns on backtrace.\n\n$ export RUST_BACKTRACE=1\n...\n$ RUST_BACKTRACE=0 ./diverges \nthread 'main' panicked at 'This function never returns!', hello.rs:2\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\n\nRUST_BACKTRACE also works with Cargo‚Äôs run command:\n\n$ RUST_BACKTRACE=full cargo run\n     Running `target/debug/diverges`\nthread 'main' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n\n\nA diverging function can be used as any type:\n\n\nlet x: i32 = diverges();\nlet x: String = diverges();\nFunction pointers\n\nWe can also create variable bindings which point to functions:\n\n\nlet f: fn(i32) -> i32;\n\nf is a variable binding which points to a function that takes an i32 as an argument and returns an i32. For example:\n\n\nfn plus_one(i: i32) -> i32 {\n    i + 1\n}\n\n// Without type inference:\nlet f: fn(i32) -> i32 = plus_one;\n\n// With type inference:\nlet f = plus_one;\n\nWe can then use f to call the function:\n\n\nlet six = f(5);"
  },
  {
    "title": "Variable Bindings - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/variable-bindings.html",
    "html": "Variable Bindings\n\nVirtually every non-'Hello World‚Äô Rust program uses variable bindings. They bind some value to a name, so it can be used later. let is used to introduce a binding, like this:\n\nfn main() {\n    let x = 5;\n}\n\n\nPutting fn main() { in each example is a bit tedious, so we‚Äôll leave that out in the future. If you‚Äôre following along, make sure to edit your main() function, rather than leaving it off. Otherwise, you‚Äôll get an error.\n\nPatterns\n\nIn many languages, a variable binding would be called a variable, but Rust‚Äôs variable bindings have a few tricks up their sleeves. For example the left-hand side of a let statement is a ‚Äòpattern‚Äô, not a variable name. This means we can do things like:\n\n\nlet (x, y) = (1, 2);\n\nAfter this statement is evaluated, x will be one, and y will be two. Patterns are really powerful, and have their own section in the book. We don‚Äôt need those features for now, so we‚Äôll keep this in the back of our minds as we go forward.\n\nType annotations\n\nRust is a statically typed language, which means that we specify our types up front, and they‚Äôre checked at compile time. So why does our first example compile? Well, Rust has this thing called ‚Äòtype inference‚Äô. If it can figure out what the type of something is, Rust doesn‚Äôt require you to explicitly type it out.\n\nWe can add the type if we want to, though. Types come after a colon (:):\n\n\nlet x: i32 = 5;\n\nIf I asked you to read this out loud to the rest of the class, you‚Äôd say ‚Äúx is a binding with the type i32 and the value 5.‚Äù\n\nIn this case we chose to represent x as a 32-bit signed integer. Rust has many different primitive integer types. They begin with i for signed integers and u for unsigned integers. The possible integer sizes are 8, 16, 32, and 64 bits.\n\nIn future examples, we may annotate the type in a comment. The examples will look like this:\n\nfn main() {\n    let x = 5; // x: i32\n}\n\n\nNote the similarities between this annotation and the syntax you use with let. Including these kinds of comments is not idiomatic Rust, but we'll occasionally include them to help you understand what the types that Rust infers are.\n\nMutability\n\nBy default, bindings are immutable. This code will not compile:\n\nlet x = 5;\nx = 10;\n\n\nIt will give you this error:\n\nerror: re-assignment of immutable variable `x`\n     x = 10;\n     ^~~~~~~\n\n\nIf you want a binding to be mutable, you can use mut:\n\n\nlet mut x = 5; // mut x: i32\nx = 10;\n\nThere is no single reason that bindings are immutable by default, but we can think about it through one of Rust‚Äôs primary focuses: safety. If you forget to say mut, the compiler will catch it, and let you know that you have mutated something you may not have intended to mutate. If bindings were mutable by default, the compiler would not be able to tell you this. If you did intend mutation, then the solution is quite easy: add mut.\n\nThere are other good reasons to avoid mutable state when possible, but they‚Äôre out of the scope of this guide. In general, you can often avoid explicit mutation, and so it is preferable in Rust. That said, sometimes, mutation is what you need, so it‚Äôs not forbidden.\n\nInitializing bindings\n\nRust variable bindings have one more aspect that differs from other languages: bindings are required to be initialized with a value before you're allowed to use them.\n\nLet‚Äôs try it out. Change your src/main.rs file to look like this:\n\nfn main() {\n    let x: i32;\n\n    println!(\"Hello world!\");\n}\n\n\nYou can use cargo build on the command line to build it. You‚Äôll get a warning, but it will still print \"Hello, world!\":\n\n   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\nsrc/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variables)]\n   on by default\nsrc/main.rs:2     let x: i32;\n                      ^\n\n\nRust warns us that we never use the variable binding, but since we never use it, no harm, no foul. Things change if we try to actually use this x, however. Let‚Äôs do that. Change your program to look like this:\n\nfn main() {\n    let x: i32;\n\n    println!(\"The value of x is: {}\", x);\n}\n\n\nAnd try to build it. You‚Äôll get an error:\n\n$ cargo build\n   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\nsrc/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\nsrc/main.rs:4     println!(\"The value of x is: {}\", x);\n                                                    ^\nnote: in expansion of format_args!\n<std macros>:2:23: 2:77 note: expansion site\n<std macros>:1:1: 3:2 note: in expansion of println!\nsrc/main.rs:4:5: 4:42 note: expansion site\nerror: aborting due to previous error\nCould not compile `hello_world`.\n\n\nRust will not let us use a value that has not been initialized.\n\nLet us take a minute to talk about this stuff we've added to println!.\n\nIf you include two curly braces ({}, some call them moustaches...) in your string to print, Rust will interpret this as a request to interpolate some sort of value. String interpolation is a computer science term that means \"stick in the middle of a string.\" We add a comma, and then x, to indicate that we want x to be the value we‚Äôre interpolating. The comma is used to separate arguments we pass to functions and macros, if you‚Äôre passing more than one.\n\nWhen you use the curly braces, Rust will attempt to display the value in a meaningful way by checking out its type. If you want to specify the format in a more detailed manner, there are a wide number of options available. For now, we'll stick to the default: integers aren't very complicated to print.\n\nScope and shadowing\n\nLet‚Äôs get back to bindings. Variable bindings have a scope - they are constrained to live in the block they were defined in. A block is a collection of statements enclosed by { and }. Function definitions are also blocks! In the following example we define two variable bindings, x and y, which live in different blocks. x can be accessed from inside the fn main() {} block, while y can be accessed only from inside the inner block:\n\nfn main() {\n    let x: i32 = 17;\n    {\n        let y: i32 = 3;\n        println!(\"The value of x is {} and value of y is {}\", x, y);\n    }\n    println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n}\n\n\nThe first println! would print \"The value of x is 17 and the value of y is 3\", but this example cannot be compiled successfully, because the second println! cannot access the value of y, since it is not in scope anymore. Instead we get this error:\n\n$ cargo build\n   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)\nmain.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]\nmain.rs:7     println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n                                                                       ^\nnote: in expansion of format_args!\n<std macros>:2:25: 2:56 note: expansion site\n<std macros>:1:1: 2:62 note: in expansion of print!\n<std macros>:3:1: 3:54 note: expansion site\n<std macros>:1:1: 3:58 note: in expansion of println!\nmain.rs:7:5: 7:65 note: expansion site\nmain.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation\nerror: aborting due to previous error\nCould not compile `hello`.\n\nTo learn more, run the command again with --verbose.\n\n\nAdditionally, variable bindings can be shadowed. This means that a later variable binding with the same name as another binding that is currently in scope will override the previous binding.\n\n\nlet x: i32 = 8;\n{\n    println!(\"{}\", x); // Prints \"8\".\n    let x = 12;\n    println!(\"{}\", x); // Prints \"12\".\n}\nprintln!(\"{}\", x); // Prints \"8\".\nlet x =  42;\nprintln!(\"{}\", x); // Prints \"42\".\n\nShadowing and mutable bindings may appear as two sides of the same coin, but they are two distinct concepts that can't always be used interchangeably. For one, shadowing enables us to rebind a name to a value of a different type. It is also possible to change the mutability of a binding. Note that shadowing a name does not alter or destroy the value it was bound to, and the value will continue to exist until it goes out of scope, even if it is no longer accessible by any means.\n\n\nlet mut x: i32 = 1;\nx = 7;\nlet x = x; // `x` is now immutable and is bound to `7`.\n\nlet y = 4;\nlet y = \"I can also be bound to text!\"; // `y` is now of a different type."
  },
  {
    "title": "Syntax and Semantics - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/syntax-and-semantics.html",
    "html": "Syntax and Semantics\n\nThis chapter breaks Rust down into small chunks, one for each concept.\n\nIf you‚Äôd like to learn Rust from the bottom up, reading this in order is a great way to do that.\n\nThese sections also form a reference for each concept, so if you‚Äôre reading another tutorial and find something confusing, you can find it explained somewhere in here."
  },
  {
    "title": "Tutorial: Guessing Game - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/guessing-game.html",
    "html": "Guessing Game\n\nLet‚Äôs learn some Rust! For our first project, we‚Äôll implement a classic beginner programming problem: the guessing game. Here‚Äôs how it works: Our program will generate a random integer between one and a hundred. It will then prompt us to enter a guess. Upon entering our guess, it will tell us if we‚Äôre too low or too high. Once we guess correctly, it will congratulate us. Sounds good?\n\nAlong the way, we‚Äôll learn a little bit about Rust. The next chapter, ‚ÄòSyntax and Semantics‚Äô, will dive deeper into each part.\n\nSet up\n\nLet‚Äôs set up a new project. Go to your projects directory. Remember how we had to create our directory structure and a Cargo.toml for hello_world? Cargo has a command that does that for us. Let‚Äôs give it a shot:\n\n$ cd ~/projects\n$ cargo new guessing_game --bin\n     Created binary (application) `guessing_game` project\n$ cd guessing_game\n\n\nWe pass the name of our project to cargo new, and then the --bin flag, since we‚Äôre making a binary, rather than a library.\n\nCheck out the generated Cargo.toml:\n\n[package]\n\nname = \"guessing_game\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <you@example.com>\"]\n\n\nCargo gets this information from your environment. If it‚Äôs not correct, go ahead and fix that.\n\nFinally, Cargo generated a ‚ÄòHello, world!‚Äô for us. Check out src/main.rs:\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nLet‚Äôs try compiling what Cargo gave us:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.53 secs\n\n\nExcellent! Open up your src/main.rs again. We‚Äôll be writing all of our code in this file.\n\nRemember the run command from last chapter? Try it out again here:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/guessing_game`\nHello, world!\n\n\nGreat! Our game is just the kind of project run is good for: we need to quickly test each iteration before moving on to the next one.\n\nProcessing a Guess\n\nLet‚Äôs get to it! The first thing we need to do for our guessing game is allow our player to input a guess. Put this in your src/main.rs:\n\nuse std::io;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {}\", guess);\n}\n\n\nThere‚Äôs a lot here! Let‚Äôs go over it, bit by bit.\n\nuse std::io;\n\n\nWe‚Äôll need to take user input, and then print the result as output. As such, we need the io library from the standard library. Rust only imports a few things by default into every program, the ‚Äòprelude‚Äô. If it‚Äôs not in the prelude, you‚Äôll have to use it directly. There is also a second ‚Äòprelude‚Äô, the io prelude, which serves a similar function: you import it, and it imports a number of useful, io-related things.\n\nfn main() {\n\n\nAs you‚Äôve seen before, the main() function is the entry point into your program. The fn syntax declares a new function, the ()s indicate that there are no arguments, and { starts the body of the function. Because we didn‚Äôt include a return type, it‚Äôs assumed to be (), an empty tuple.\n\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n\n\nWe previously learned that println!() is a macro that prints a string to the screen.\n\n    let mut guess = String::new();\n\n\nNow we‚Äôre getting interesting! There‚Äôs a lot going on in this little line. The first thing to notice is that this is a let statement, which is used to create ‚Äòvariable bindings‚Äô. They take this form:\n\nlet foo = bar;\n\n\nThis will create a new binding named foo, and bind it to the value bar. In many languages, this is called a ‚Äòvariable‚Äô, but Rust‚Äôs variable bindings have a few tricks up their sleeves.\n\nFor example, they‚Äôre immutable by default. That‚Äôs why our example uses mut: it makes a binding mutable, rather than immutable. let doesn‚Äôt take a name on the left hand side of the assignment, it actually accepts a ‚Äòpattern‚Äô. We‚Äôll use patterns later. It‚Äôs easy enough to use for now:\n\n\nlet foo = 5; // `foo` is immutable.\nlet mut bar = 5; // `bar` is mutable.\n\nOh, and // will start a comment, until the end of the line. Rust ignores everything in comments.\n\nSo now we know that let mut guess will introduce a mutable binding named guess, but we have to look at the other side of the = for what it‚Äôs bound to: String::new().\n\nString is a string type, provided by the standard library. A String is a growable, UTF-8 encoded bit of text.\n\nThe ::new() syntax uses :: because this is an ‚Äòassociated function‚Äô of a particular type. That is to say, it‚Äôs associated with String itself, rather than a particular instance of a String. Some languages call this a ‚Äòstatic method‚Äô.\n\nThis function is named new(), because it creates a new, empty String. You‚Äôll find a new() function on many types, as it‚Äôs a common name for making a new value of some kind.\n\nLet‚Äôs move forward:\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n\nThat‚Äôs a lot more! Let‚Äôs go bit-by-bit. The first line has two parts. Here‚Äôs the first:\n\nio::stdin()\n\n\nRemember how we used std::io on the first line of the program? We‚Äôre now calling an associated function on it. If we didn‚Äôt use std::io, we could have written this line as std::io::stdin().\n\nThis particular function returns a handle to the standard input for your terminal. More specifically, a std::io::Stdin.\n\nThe next part will use this handle to get input from the user:\n\n.read_line(&mut guess)\n\n\nHere, we call the read_line method on our handle. Methods are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We‚Äôre also passing one argument to read_line(): &mut guess.\n\nRemember how we bound guess above? We said it was mutable. However, read_line doesn‚Äôt take a String as an argument: it takes a &mut String. Rust has a feature called ‚Äòreferences‚Äô, which allows you to have multiple references to one piece of data, which can reduce copying. References are a complex feature, as one of Rust‚Äôs major selling points is how safe and easy it is to use references. We don‚Äôt need to know a lot of those details to finish our program right now, though. For now, all we need to know is that like let bindings, references are immutable by default. Hence, we need to write &mut guess, rather than &guess.\n\nWhy does read_line() take a mutable reference to a string? Its job is to take what the user types into standard input, and place that into a string. So it takes that string as an argument, and in order to add the input, it needs to be mutable.\n\nBut we‚Äôre not quite done with this line of code, though. While it‚Äôs a single line of text, it‚Äôs only the first part of the single logical line of code:\n\n        .expect(\"Failed to read line\");\n\n\nWhen you call a method with the .foo() syntax, you may introduce a newline and other whitespace. This helps you split up long lines. We could have done:\n\n    io::stdin().read_line(&mut guess).expect(\"Failed to read line\");\n\n\nBut that gets hard to read. So we‚Äôve split it up, two lines for two method calls. We already talked about read_line(), but what about expect()? Well, we already mentioned that read_line() puts what the user types into the &mut String we pass it. But it also returns a value: in this case, an io::Result. Rust has a number of types named Result in its standard library: a generic Result, and then specific versions for sub-libraries, like io::Result.\n\nThe purpose of these Result types is to encode error handling information. Values of the Result type, like any type, have methods defined on them. In this case, io::Result has an expect() method that takes a value it‚Äôs called on, and if it isn‚Äôt a successful one, panic!s with a message you passed it. A panic! like this will cause our program to crash, displaying the message.\n\nIf we do not call expect(), our program will compile, but we‚Äôll get a warning:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\nwarning: unused result which must be used, #[warn(unused_must_use)] on by default\n  --> src/main.rs:10:5\n   |\n10 |     io::stdin().read_line(&mut guess);\n   |     ^\n\n    Finished debug [unoptimized + debuginfo] target(s) in 0.42 secs\n\n\nRust warns us that we haven‚Äôt used the Result value. This warning comes from a special annotation that io::Result has. Rust is trying to tell you that you haven‚Äôt handled a possible error. The right way to suppress the error is to actually write error handling. Luckily, if we want to crash if there‚Äôs a problem, we can use expect(). If we can recover from the error somehow, we‚Äôd do something else, but we‚Äôll save that for a future project.\n\nThere‚Äôs only one line of this first example left:\n\n    println!(\"You guessed: {}\", guess);\n}\n\n\nThis prints out the string we saved our input in. The {}s are a placeholder, and so we pass it guess as an argument. If we had multiple {}s, we would pass multiple arguments:\n\n\nlet x = 5;\nlet y = 10;\n\nprintln!(\"x and y: {} and {}\", x, y);\n\nEasy.\n\nAnyway, that‚Äôs the tour. We can run what we have with cargo run:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.44 secs\n     Running `target/debug/guessing_game`\nGuess the number!\nPlease input your guess.\n6\nYou guessed: 6\n\n\nAll right! Our first part is done: we can get input from the keyboard, and then print it back out.\n\nGenerating a secret number\n\nNext, we need to generate a secret number. Rust does not yet include random number functionality in its standard library. The Rust team does, however, provide a rand crate. A ‚Äòcrate‚Äô is a package of Rust code. We‚Äôve been building a ‚Äòbinary crate‚Äô, which is an executable. rand is a ‚Äòlibrary crate‚Äô, which contains code that‚Äôs intended to be used with other programs.\n\nUsing external crates is where Cargo really shines. Before we can write the code using rand, we need to modify our Cargo.toml. Open it up, and add these few lines at the bottom:\n\n[dependencies]\n\nrand = \"0.3.0\"\n\n\nThe [dependencies] section of Cargo.toml is like the [package] section: everything that follows it is part of it, until the next section starts. Cargo uses the dependencies section to know what dependencies on external crates you have, and what versions you require. In this case, we‚Äôve specified version 0.3.0, which Cargo understands to be any release that‚Äôs compatible with this specific version. Cargo understands Semantic Versioning, which is a standard for writing version numbers. A bare number like above is actually shorthand for ^0.3.0, meaning \"anything compatible with 0.3.0\". If we wanted to use only 0.3.0 exactly, we could say rand = \"=0.3.0\" (note the two equal signs). We could also use a range of versions. Cargo‚Äôs documentation contains more details.\n\nNow, without changing any of our code, let‚Äôs build our project:\n\n$ cargo build\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n Downloading rand v0.3.14\n Downloading libc v0.2.17\n   Compiling libc v0.2.17\n   Compiling rand v0.3.14\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 5.88 secs\n\n\n(You may see different versions, of course.)\n\nLots of new output! Now that we have an external dependency, Cargo fetches the latest versions of everything from the registry, which is a copy of data from Crates.io. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.\n\nAfter updating the registry, Cargo checks our [dependencies] and downloads any we don‚Äôt have yet. In this case, while we only said we wanted to depend on rand, we‚Äôve also grabbed a copy of libc. This is because rand depends on libc to work. After downloading them, it compiles them, and then compiles our project.\n\nIf we run cargo build again, we‚Äôll get different output:\n\n$ cargo build\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n\n\nThat‚Äôs right, nothing was done! Cargo knows that our project has been built, and that all of its dependencies are built, and so there‚Äôs no reason to do all that stuff. With nothing to do, it simply exits. If we open up src/main.rs again, make a trivial change, and then save it again, we‚Äôll only see two lines:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.45 secs\n\n\nSo, we told Cargo we wanted any 0.3.x version of rand, and so it fetched the latest version at the time this was written, v0.3.14. But what happens when next week, version v0.3.15 comes out, with an important bugfix? While getting bugfixes is important, what if 0.3.15 contains a regression that breaks our code?\n\nThe answer to this problem is the Cargo.lock file you‚Äôll now find in your project directory. When you build your project for the first time, Cargo figures out all of the versions that fit your criteria, and then writes them to the Cargo.lock file. When you build your project in the future, Cargo will see that the Cargo.lock file exists, and then use that specific version rather than do all the work of figuring out versions again. This lets you have a repeatable build automatically. In other words, we‚Äôll stay at 0.3.14 until we explicitly upgrade, and so will anyone who we share our code with, thanks to the lock file.\n\nWhat about when we do want to use v0.3.15? Cargo has another command, update, which says ‚Äòignore the lock, figure out all the latest versions that fit what we‚Äôve specified. If that works, write those versions out to the lock file‚Äô. But, by default, Cargo will only look for versions larger than 0.3.0 and smaller than 0.4.0. If we want to move to 0.4.x, we‚Äôd have to update the Cargo.toml directly. When we do, the next time we cargo build, Cargo will update the index and re-evaluate our rand requirements.\n\nThere‚Äôs a lot more to say about Cargo and its ecosystem, but for now, that‚Äôs all we need to know. Cargo makes it really easy to re-use libraries, and so Rustaceans tend to write smaller projects which are assembled out of a number of sub-packages.\n\nLet‚Äôs get on to actually using rand. Here‚Äôs our next step:\n\nextern crate rand;\n\nuse std::io;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {}\", guess);\n}\n\n\nThe first thing we‚Äôve done is change the first line. It now says extern crate rand. Because we declared rand in our [dependencies], we can use extern crate to let Rust know we‚Äôll be making use of it. This also does the equivalent of a use rand; as well, so we can make use of anything in the rand crate by prefixing it with rand::.\n\nNext, we added another use line: use rand::Rng. We‚Äôre going to use a method in a moment, and it requires that Rng be in scope to work. The basic idea is this: methods are defined on something called ‚Äòtraits‚Äô, and for the method to work, it needs the trait to be in scope. For more about the details, read the traits section.\n\nThere are two other lines we added, in the middle:\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n\nWe use the rand::thread_rng() function to get a copy of the random number generator, which is local to the particular thread of execution we‚Äôre in. Because we use rand::Rng‚Äôd above, it has a gen_range() method available. This method takes two arguments, and generates a number between them. It‚Äôs inclusive on the lower bound, but exclusive on the upper bound, so we need 1 and 101 to get a number ranging from one to a hundred.\n\nThe second line prints out the secret number. This is useful while we‚Äôre developing our program, so we can easily test it out. But we‚Äôll be deleting it for the final version. It‚Äôs not much of a game if it prints out the answer when you start it up!\n\nTry running our new program a few times:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.55 secs\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 7\nPlease input your guess.\n4\nYou guessed: 4\n$ cargo run\n    Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 83\nPlease input your guess.\n5\nYou guessed: 5\n\n\nGreat! Next up: comparing our guess to the secret number.\n\nComparing guesses\n\nNow that we‚Äôve got user input, let‚Äôs compare our guess to the secret number. Here‚Äôs our next step, though it doesn‚Äôt quite compile yet:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {}\", guess);\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less    => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal   => println!(\"You win!\"),\n    }\n}\n\n\nA few new bits here. The first is another use. We bring a type called std::cmp::Ordering into scope. Then, five new lines at the bottom that use it:\n\nmatch guess.cmp(&secret_number) {\n    Ordering::Less    => println!(\"Too small!\"),\n    Ordering::Greater => println!(\"Too big!\"),\n    Ordering::Equal   => println!(\"You win!\"),\n}\n\n\nThe cmp() method can be called on anything that can be compared, and it takes a reference to the thing you want to compare it to. It returns the Ordering type we used earlier. We use a match statement to determine exactly what kind of Ordering it is. Ordering is an enum, short for ‚Äòenumeration‚Äô, which looks like this:\n\n\nenum Foo {\n    Bar,\n    Baz,\n}\n\nWith this definition, anything of type Foo can be either a Foo::Bar or a Foo::Baz. We use the :: to indicate the namespace for a particular enum variant.\n\nThe Ordering enum has three possible variants: Less, Equal, and Greater. The match statement takes a value of a type, and lets you create an ‚Äòarm‚Äô for each possible value. Since we have three types of Ordering, we have three arms:\n\nmatch guess.cmp(&secret_number) {\n    Ordering::Less    => println!(\"Too small!\"),\n    Ordering::Greater => println!(\"Too big!\"),\n    Ordering::Equal   => println!(\"You win!\"),\n}\n\n\nIf it‚Äôs Less, we print Too small!, if it‚Äôs Greater, Too big!, and if Equal, You win!. match is really useful, and is used often in Rust.\n\nI did mention that this won‚Äôt quite compile yet, though. Let‚Äôs try it:\n\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\nerror[E0308]: mismatched types\n  --> src/main.rs:23:21\n   |\n23 |     match guess.cmp(&secret_number) {\n   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable\n   |\n   = note: expected type `&std::string::String`\n   = note:    found type `&{integer}`\n\nerror: aborting due to previous error\n\nerror: Could not compile `guessing_game`.\n\nTo learn more, run the command again with --verbose.\n\n\nWhew! This is a big error. The core of it is that we have ‚Äòmismatched types‚Äô. Rust has a strong, static type system. However, it also has type inference. When we wrote let guess = String::new(), Rust was able to infer that guess should be a String, and so it doesn‚Äôt make us write out the type. And with our secret_number, there are a number of types which can have a value between one and a hundred: i32, a thirty-two-bit number, or u32, an unsigned thirty-two-bit number, or i64, a sixty-four-bit number or others. So far, that hasn‚Äôt mattered, and so Rust defaults to an i32. However, here, Rust doesn‚Äôt know how to compare the guess and the secret_number. They need to be the same type. Ultimately, we want to convert the String we read as input into a real number type, for comparison. We can do that with two more lines. Here‚Äôs our new program:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin().read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    let guess: u32 = guess.trim().parse()\n        .expect(\"Please type a number!\");\n\n    println!(\"You guessed: {}\", guess);\n\n    match guess.cmp(&secret_number) {\n        Ordering::Less    => println!(\"Too small!\"),\n        Ordering::Greater => println!(\"Too big!\"),\n        Ordering::Equal   => println!(\"You win!\"),\n    }\n}\n\n\nThe new two lines:\n\n    let guess: u32 = guess.trim().parse()\n        .expect(\"Please type a number!\");\n\n\nWait a minute, I thought we already had a guess? We do, but Rust allows us to ‚Äòshadow‚Äô the previous guess with a new one. This is often used in this exact situation, where guess starts as a String, but we want to convert it to an u32. Shadowing lets us re-use the guess name, rather than forcing us to come up with two unique names like guess_str and guess, or something else.\n\nWe bind guess to an expression that looks like something we wrote earlier:\n\nguess.trim().parse()\n\n\nHere, guess refers to the old guess, the one that was a String with our input in it. The trim() method on Strings will eliminate any white space at the beginning and end of our string. This is important, as we had to press the ‚Äòreturn‚Äô key to satisfy read_line(). This means that if we type 5 and hit return, guess looks like this: 5\\n. The \\n represents ‚Äònewline‚Äô, the enter key. trim() gets rid of this, leaving our string with only the 5. The parse() method on strings parses a string into some kind of number. Since it can parse a variety of numbers, we need to give Rust a hint as to the exact type of number we want. Hence, let guess: u32. The colon (:) after guess tells Rust we‚Äôre going to annotate its type. u32 is an unsigned, thirty-two bit integer. Rust has a number of built-in number types, but we‚Äôve chosen u32. It‚Äôs a good default choice for a small positive number.\n\nJust like read_line(), our call to parse() could cause an error. What if our string contained Aüëç%? There‚Äôd be no way to convert that to a number. As such, we‚Äôll do the same thing we did with read_line(): use the expect() method to crash if there‚Äôs an error.\n\nLet‚Äôs try our program out!\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.57 secs\n     Running `target/guessing_game`\nGuess the number!\nThe secret number is: 58\nPlease input your guess.\n  76\nYou guessed: 76\nToo big!\n\n\nNice! You can see I even added spaces before my guess, and it still figured out that I guessed 76. Run the program a few times, and verify that guessing the number works, as well as guessing a number too small.\n\nNow we‚Äôve got most of the game working, but we can only make one guess. Let‚Äôs change that by adding loops!\n\nLooping\n\nThe loop keyword gives us an infinite loop. Let‚Äôs add that in:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = guess.trim().parse()\n            .expect(\"Please type a number!\");\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => println!(\"You win!\"),\n        }\n    }\n}\n\n\nAnd try it out. But wait, didn‚Äôt we just add an infinite loop? Yup. Remember our discussion about parse()? If we give a non-number answer, we‚Äôll panic! and quit. Observe:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.58 secs\n     Running `target/guessing_game`\nGuess the number!\nThe secret number is: 59\nPlease input your guess.\n45\nYou guessed: 45\nToo small!\nPlease input your guess.\n60\nYou guessed: 60\nToo big!\nPlease input your guess.\n59\nYou guessed: 59\nYou win!\nPlease input your guess.\nquit\nthread 'main' panicked at 'Please type a number!'\n\n\nHa! quit actually quits. As does any other non-number input. Well, this is suboptimal to say the least. First, let‚Äôs actually quit when you win the game:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = guess.trim().parse()\n            .expect(\"Please type a number!\");\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\n\nBy adding the break line after the You win!, we‚Äôll exit the loop when we win. Exiting the loop also means exiting the program, since it‚Äôs the last thing in main(). We have only one more tweak to make: when someone inputs a non-number, we don‚Äôt want to quit, we want to ignore it. We can do that like this:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    println!(\"The secret number is: {}\", secret_number);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\n\nThese are the lines that changed:\n\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};\n\n\nThis is how you generally move from ‚Äòcrash on error‚Äô to ‚Äòactually handle the error‚Äô, by switching from expect() to a match statement. A Result is returned by parse(), this is an enum like Ordering, but in this case, each variant has some data associated with it: Ok is a success, and Err is a failure. Each contains more information: the successfully parsed integer, or an error type. In this case, we match on Ok(num), which sets the name num to the unwrapped Ok value (the integer), and then we return it on the right-hand side. In the Err case, we don‚Äôt care what kind of error it is, so we just use the catch all _ instead of a name. This catches everything that isn't Ok, and continue lets us move to the next iteration of the loop; in effect, this enables us to ignore all errors and continue with our program.\n\nNow we should be good! Let‚Äôs try:\n\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n    Finished debug [unoptimized + debuginfo] target(s) in 0.57 secs\n     Running `target/guessing_game`\nGuess the number!\nThe secret number is: 61\nPlease input your guess.\n10\nYou guessed: 10\nToo small!\nPlease input your guess.\n99\nYou guessed: 99\nToo big!\nPlease input your guess.\nfoo\nPlease input your guess.\n61\nYou guessed: 61\nYou win!\n\n\nAwesome! With one tiny last tweak, we have finished the guessing game. Can you think of what it is? That‚Äôs right, we don‚Äôt want to print out the secret number. It was good for testing, but it kind of ruins the game. Here‚Äôs our final source:\n\nextern crate rand;\n\nuse std::io;\nuse std::cmp::Ordering;\nuse rand::Rng;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin().read_line(&mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!(\"You guessed: {}\", guess);\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less    => println!(\"Too small!\"),\n            Ordering::Greater => println!(\"Too big!\"),\n            Ordering::Equal   => {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\nComplete!\n\nThis project showed you a lot: let, match, methods, associated functions, using external crates, and more.\n\nAt this point, you have successfully built the Guessing Game! Congratulations!"
  },
  {
    "title": "Introduction - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/README.html",
    "html": "The Rust Programming Language\n\nWelcome! This book will teach you about the Rust Programming Language. Rust is a systems programming language focused on three goals: safety, speed, and concurrency. It maintains these goals without having a garbage collector, making it a useful language for a number of use cases other languages aren‚Äôt good at: embedding in other languages, programs with specific space and time requirements, and writing low-level code, like device drivers and operating systems. It improves on current languages targeting this space by having a number of compile-time safety checks that produce no runtime overhead, while eliminating all data races. Rust also aims to achieve ‚Äòzero-cost abstractions‚Äô even though some of these abstractions feel like those of a high-level language. Even then, Rust still allows precise control like a low-level language would.\n\n‚ÄúThe Rust Programming Language‚Äù is split into chapters. This introduction is the first. After this:\n\nGetting started - Set up your computer for Rust development.\nTutorial: Guessing Game - Learn some Rust with a small project.\nSyntax and Semantics - Each bit of Rust, broken down into small chunks.\nEffective Rust - Higher-level concepts for writing excellent Rust code.\nGlossary - A reference of terms used in the book.\nBibliography - Background on Rust's influences, papers about Rust.\nContributing\n\nThe source files from which this book is generated can be found on GitHub.\n\nSecond edition of this book\n\nThere are two editions of \"The Rust Programming Language\", this being the first edition.\n\nThe second edition is a complete re-write. It is still under construction, though it is far enough along to learn most of Rust. We suggest reading the second edition and then checking out the first edition later to pick up some of the more esoteric parts of the language."
  },
  {
    "title": "Getting Started - The Rust Programming Language",
    "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/getting-started.html",
    "html": "Getting Started\n\nThis first chapter of the book will get us going with Rust and its tooling. First, we‚Äôll install Rust. Then, the classic ‚ÄòHello World‚Äô program. Finally, we‚Äôll talk about Cargo, Rust‚Äôs build system and package manager.\n\nWe‚Äôll be showing off a number of commands using a terminal, and those lines all start with $. You don't need to type in the $s, they are there to indicate the start of each command. We‚Äôll see many tutorials and examples around the web that follow this convention: $ for commands run as our regular user, and # for commands we should be running as an administrator.\n\nInstalling Rust\n\nThe first step to using Rust is to install it. Generally speaking, you‚Äôll need an Internet connection to run the commands in this section, as we‚Äôll be downloading Rust from the Internet.\n\nThe Rust compiler runs on, and compiles to, a great number of platforms, but is best supported on Linux, Mac, and Windows, on the x86 and x86-64 CPU architecture. There are official builds of the Rust compiler and standard library for these platforms and more. For full details on Rust platform support see the website.\n\nInstalling Rust\n\nAll you need to do on Unix systems like Linux and macOS is open a terminal and type this:\n\n$ curl https://sh.rustup.rs -sSf | sh\n\n\nIt will download a script, and start the installation. If everything goes well, you‚Äôll see this appear:\n\nRust is installed now. Great! \n\n\nInstalling on Windows is nearly as easy: download and run rustup-init.exe. It will start the installation in a console and present the above message on success.\n\nFor other installation options and information, visit the install page of the Rust website.\n\nUninstalling\n\nUninstalling Rust is as easy as installing it:\n\n$ rustup self uninstall\n\nTroubleshooting\n\nIf we've got Rust installed, we can open up a shell, and type this:\n\n$ rustc --version\n\n\nYou should see the version number, commit hash, and commit date.\n\nIf you do, Rust has been installed successfully! Congrats!\n\nIf you don't, that probably means that the PATH environment variable doesn't include Cargo's binary directory, ~/.cargo/bin on Unix, or %USERPROFILE%\\.cargo\\bin on Windows. This is the directory where Rust development tools live, and most Rust developers keep it in their PATH environment variable, which makes it possible to run rustc on the command line. Due to differences in operating systems, command shells, and bugs in installation, you may need to restart your shell, log out of the system, or configure PATH manually as appropriate for your operating environment.\n\nRust does not do its own linking, and so you‚Äôll need to have a linker installed. Doing so will depend on your specific system. For Linux-based systems, Rust will attempt to call cc for linking. On windows-msvc (Rust built on Windows with Microsoft Visual Studio), this depends on having Microsoft Visual C++ Build Tools installed. These do not need to be in %PATH% as rustc will find them automatically. In general, if you have your linker in a non-traditional location you can call rustc linker=/path/to/cc, where /path/to/cc should point to your linker path.\n\nIf you are still stuck, there are a number of places where we can get help. The easiest is the #rust-beginners IRC channel on irc.mozilla.org and for general discussion the #rust IRC channel on irc.mozilla.org, which we can access through Mibbit. Then we'll be chatting with other Rustaceans (a silly nickname we call ourselves) who can help us out. Other great resources include the user‚Äôs forum and Stack Overflow.\n\nThis installer also installs a copy of the documentation locally, so we can read it offline. It's only a rustup doc away!\n\nHello, world!\n\nNow that you have Rust installed, we'll help you write your first Rust program. It's traditional when learning a new language to write a little program to print the text ‚ÄúHello, world!‚Äù to the screen, and in this section, we'll follow that tradition.\n\nThe nice thing about starting with such a simple program is that you can quickly verify that your compiler is installed, and that it's working properly. Printing information to the screen is also a pretty common thing to do, so practicing it early on is good.\n\nNote: This book assumes basic familiarity with the command line. Rust itself makes no specific demands about your editing, tooling, or where your code lives, so if you prefer an IDE to the command line, that's an option. You may want to check out SolidOak, which was built specifically with Rust in mind. There are a number of extensions in development by the community, and the Rust team ships plugins for various editors. Configuring your editor or IDE is out of the scope of this tutorial, so check the documentation for your specific setup.\n\nCreating a Project File\n\nFirst, make a file to put your Rust code in. Rust doesn't care where your code lives, but for this book, I suggest making a projects directory in your home directory, and keeping all your projects there. Open a terminal and enter the following commands to make a directory for this particular project:\n\n$ mkdir ~/projects\n$ cd ~/projects\n$ mkdir hello_world\n$ cd hello_world\n\n\nNote: If you‚Äôre on Windows and not using PowerShell, the ~ may not work. Consult the documentation for your shell for more details.\n\nWriting and Running a Rust Program\n\nWe need to create a source file for our Rust program. Rust files always end in a .rs extension. If you are using more than one word in your filename, use an underscore to separate them; for example, you would use my_program.rs rather than myprogram.rs.\n\nNow, make a new file and call it main.rs. Open the file and type the following code:\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nSave the file, and go back to your terminal window. On Linux or macOS, enter the following commands:\n\n$ rustc main.rs\n$ ./main\nHello, world!\n\n\nIn Windows, replace main with main.exe. Regardless of your operating system, you should see the string Hello, world! print to the terminal. If you did, then congratulations! You've officially written a Rust program. That makes you a Rust programmer! Welcome.\n\nAnatomy of a Rust Program\n\nNow, let‚Äôs go over what just happened in your \"Hello, world!\" program in detail. Here's the first piece of the puzzle:\n\nfn main() {\n\n}\n\n\nThese lines define a function in Rust. The main function is special: it's the beginning of every Rust program. The first line says, ‚ÄúI‚Äôm declaring a function named main that takes no arguments and returns nothing.‚Äù If there were arguments, they would go inside the parentheses (( and )), and because we aren‚Äôt returning anything from this function, we can omit the return type entirely.\n\nAlso note that the function body is wrapped in curly braces ({ and }). Rust requires these around all function bodies. It's considered good style to put the opening curly brace on the same line as the function declaration, with one space in between.\n\nInside the main() function:\n\n\n    println!(\"Hello, world!\");\n\nThis line does all of the work in this little program: it prints text to the screen. There are a number of details that are important here. The first is that it‚Äôs indented with four spaces, not tabs.\n\nThe second important part is the println!() line. This is calling a Rust macro, which is how metaprogramming is done in Rust. If it were calling a function instead, it would look like this: println() (without the !). We'll discuss Rust macros in more detail later, but for now you only need to know that when you see a ! that means that you‚Äôre calling a macro instead of a normal function.\n\nNext is \"Hello, world!\" which is a string. Strings are a surprisingly complicated topic in a systems programming language, and this is a statically allocated string. We pass this string as an argument to println!, which prints the string to the screen. Easy enough!\n\nThe line ends with a semicolon (;). Rust is an expression-oriented language, which means that most things are expressions, rather than statements. The ; indicates that this expression is over, and the next one is ready to begin. Most lines of Rust code end with a ;.\n\nCompiling and Running Are Separate Steps\n\nIn \"Writing and Running a Rust Program\", we showed you how to run a newly created program. We'll break that process down and examine each step now.\n\nBefore running a Rust program, you have to compile it. You can use the Rust compiler by entering the rustc command and passing it the name of your source file, like this:\n\n$ rustc main.rs\n\n\nIf you come from a C or C++ background, you'll notice that this is similar to gcc or clang. After compiling successfully, Rust should output a binary executable, which you can see on Linux or macOS by entering the ls command in your shell as follows:\n\n$ ls\nmain  main.rs\n\n\nOn Windows, you'd enter:\n\n$ dir\nmain.exe\nmain.rs\n\n\nThis shows we have two files: the source code, with an .rs extension, and the executable (main.exe on Windows, main everywhere else). All that's left to do from here is run the main or main.exe file, like this:\n\n$ ./main  # or .\\main.exe on Windows\n\n\nIf main.rs were your \"Hello, world!\" program, this would print Hello, world! to your terminal.\n\nIf you come from a dynamic language like Ruby, Python, or JavaScript, you may not be used to compiling and running a program being separate steps. Rust is an ahead-of-time compiled language, which means that you can compile a program, give it to someone else, and they can run it even without Rust installed. If you give someone a .rb or .py or .js file, on the other hand, they need to have a Ruby, Python, or JavaScript implementation installed (respectively), but you only need one command to both compile and run your program. Everything is a tradeoff in language design.\n\nJust compiling with rustc is fine for simple programs, but as your project grows, you'll want to be able to manage all of the options your project has, and make it easy to share your code with other people and projects. Next, I'll introduce you to a tool called Cargo, which will help you write real-world Rust programs.\n\nHello, Cargo!\n\nCargo is Rust‚Äôs build system and package manager, and Rustaceans use Cargo to manage their Rust projects. Cargo manages three things: building your code, downloading the libraries your code depends on, and building those libraries. We call libraries your code needs ‚Äòdependencies‚Äô since your code depends on them.\n\nThe simplest Rust programs don‚Äôt have any dependencies, so right now, you'd only use the first part of its functionality. As you write more complex Rust programs, you‚Äôll want to add dependencies, and if you start off using Cargo, that will be a lot easier to do.\n\nAs the vast, vast majority of Rust projects use Cargo, we will assume that you‚Äôre using it for the rest of the book. Cargo comes installed with Rust itself, if you used the official installers. If you installed Rust through some other means, you can check if you have Cargo installed by typing:\n\n$ cargo --version\n\n\nInto a terminal. If you see a version number, great! If you see an error like ‚Äòcommand not found‚Äô, then you should look at the documentation for the system in which you installed Rust, to determine if Cargo is separate.\n\nConverting to Cargo\n\nLet‚Äôs convert the Hello World program to Cargo. To Cargo-fy a project, you need to do three things:\n\nPut your source file in the right directory.\nGet rid of the old executable (main.exe on Windows, main everywhere else).\nMake a Cargo configuration file.\n\nLet's get started!\n\nCreating a Source Directory and Removing the Old Executable\n\nFirst, go back to your terminal, move to your hello_world directory, and enter the following commands:\n\n$ mkdir src\n$ mv main.rs src/main.rs # or 'move main.rs src/main.rs' on Windows\n$ rm main  # or 'del main.exe' on Windows\n\n\nCargo expects your source files to live inside a src directory, so do that first. This leaves the top-level project directory (in this case, hello_world) for READMEs, license information, and anything else not related to your code. In this way, using Cargo helps you keep your projects nice and tidy. There's a place for everything, and everything is in its place.\n\nNow, move main.rs into the src directory, and delete the compiled file you created with rustc. As usual, replace main with main.exe if you're on Windows.\n\nThis example retains main.rs as the source filename because it's creating an executable. If you wanted to make a library instead, you'd name the file lib.rs. This convention is used by Cargo to successfully compile your projects, but it can be overridden if you wish.\n\nCreating a Configuration File\n\nNext, create a new file inside your hello_world directory, and call it Cargo.toml.\n\nMake sure to capitalize the C in Cargo.toml, or Cargo won't know what to do with the configuration file.\n\nThis file is in the TOML (Tom's Obvious, Minimal Language) format. TOML is similar to INI, but has some extra goodies, and is used as Cargo‚Äôs configuration format.\n\nInside this file, type the following information:\n\n[package]\n\nname = \"hello_world\"\nversion = \"0.0.1\"\nauthors = [ \"Your name <you@example.com>\" ]\n\n\nThe first line, [package], indicates that the following statements are configuring a package. As we add more information to this file, we‚Äôll add other sections, but for now, we only have the package configuration.\n\nThe other three lines set the three bits of configuration that Cargo needs to know to compile your program: its name, what version it is, and who wrote it.\n\nOnce you've added this information to the Cargo.toml file, save it to finish creating the configuration file.\n\nBuilding and Running a Cargo Project\n\nWith your Cargo.toml file in place in your project's root directory, you should be ready to build and run your Hello World program! To do so, enter the following commands:\n\n$ cargo build\n   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n$ ./target/debug/hello_world\nHello, world!\n\n\nBam! If all goes well, Hello, world! should print to the terminal once more.\n\nYou just built a project with cargo build and ran it with ./target/debug/hello_world, but you can actually do both in one step with cargo run as follows:\n\n$ cargo run\n     Running `target/debug/hello_world`\nHello, world!\n\n\nThe run command comes in handy when you need to rapidly iterate on a project.\n\nNotice that this example didn‚Äôt re-build the project. Cargo figured out that the file hasn‚Äôt changed, and so it just ran the binary. If you'd modified your source code, Cargo would have rebuilt the project before running it, and you would have seen something like this:\n\n$ cargo run\n   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n     Running `target/debug/hello_world`\nHello, world!\n\n\nCargo checks to see if any of your project‚Äôs files have been modified, and only rebuilds your project if they‚Äôve changed since the last time you built it.\n\nWith simple projects, Cargo doesn't bring a whole lot over just using rustc, but it will become useful in the future. This is especially true when you start using crates; these are synonymous with a ‚Äòlibrary‚Äô or ‚Äòpackage‚Äô in other programming languages. For complex projects composed of multiple crates, it‚Äôs much easier to let Cargo coordinate the build. Using Cargo, you can run cargo build, and it should work the right way.\n\nBuilding for Release\n\nWhen your project is ready for release, you can use cargo build --release to compile your project with optimizations. These optimizations make your Rust code run faster, but turning them on makes your program take longer to compile. This is why there are two different profiles, one for development, and one for building the final program you‚Äôll give to a user.\n\nWhat Is That Cargo.lock?\n\nRunning cargo build also causes Cargo to create a new file called Cargo.lock, which looks like this:\n\n[root]\nname = \"hello_world\"\nversion = \"0.0.1\"\n\n\nCargo uses the Cargo.lock file to keep track of dependencies in your application. This is the Hello World project's Cargo.lock file. This project doesn't have dependencies, so the file is a bit sparse. Realistically, you won't ever need to touch this file yourself; just let Cargo handle it.\n\nThat‚Äôs it! If you've been following along, you should have successfully built hello_world with Cargo.\n\nEven though the project is simple, it now uses much of the real tooling you‚Äôll use for the rest of your Rust career. In fact, you can expect to start virtually all Rust projects with some variation on the following commands:\n\n$ git clone someurl.com/foo\n$ cd foo\n$ cargo build\n\nMaking A New Cargo Project the Easy Way\n\nYou don‚Äôt have to go through that previous process every time you want to start a new project! Cargo can quickly make a bare-bones project directory that you can start developing in right away.\n\nTo start a new project with Cargo, enter cargo new at the command line:\n\n$ cargo new hello_world --bin\n\n\nThis command passes --bin because the goal is to get straight to making an executable application, as opposed to a library. Executables are often called binaries (as in /usr/bin, if you‚Äôre on a Unix system).\n\nCargo has generated two files and one directory for us: a Cargo.toml and a src directory with a main.rs file inside. These should look familiar, they‚Äôre exactly what we created by hand, above.\n\nThis output is all you need to get started. First, open Cargo.toml. It should look something like this:\n\n[package]\n\nname = \"hello_world\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[dependencies]\n\n\nDo not worry about the [dependencies] line, we will come back to it later.\n\nCargo has populated Cargo.toml with reasonable defaults based on the arguments you gave it and your git global configuration. You may notice that Cargo has also initialized the hello_world directory as a git repository.\n\nHere‚Äôs what should be in src/main.rs:\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nCargo has generated a \"Hello World!\" for you, and you‚Äôre ready to start coding!\n\nNote: If you want to look at Cargo in more detail, check out the official Cargo guide, which covers all of its features.\n\nClosing Thoughts\n\nThis chapter covered the basics that will serve you well through the rest of this book, and the rest of your time with Rust. Now that you‚Äôve got the tools down, we'll cover more about the Rust language itself.\n\nYou have two options: Dive into a project with ‚ÄòTutorial: Guessing Game‚Äô, or start from the bottom and work your way up with ‚ÄòSyntax and Semantics‚Äô. More experienced systems programmers will probably prefer ‚ÄòTutorial: Guessing Game‚Äô, while those from dynamic backgrounds may enjoy either. Different people learn differently! Choose whatever‚Äôs right for you."
  }
]